
Selected files
45 printable files

L476_USER_APP\Common\Binary_Keys\ECCKEY1.txt
L476_USER_APP\Common\KeysAndImages_Util\keys.py
L476_USER_APP\Common\KeysAndImages_Util\prepareimage.py
L476_USER_APP\Common\KeysAndImages_Util\readme.txt
L476_USER_APP\Common\KeysAndImages_Util\requirements.txt
L476_USER_APP\Common\KeysAndImages_Util\translate_key.py
L476_USER_APP\Common\Linker\mapping_export.h
L476_USER_APP\Common\Linker\mapping_fwimg.ld
L476_USER_APP\Common\Linker\mapping_sbsfu.ld
L476_USER_APP\Common\Linker\se_interface_app.ld
L476_USER_APP\Common\Scripts\postbuild.sh
L476_USER_APP\Common\Startup\se_key.s
L476_USER_APP\UserApp\.settings\language.settings.xml
L476_USER_APP\UserApp\.settings\org.eclipse.core.resources.prefs
L476_USER_APP\UserApp\Application\Core\Inc\com.h
L476_USER_APP\UserApp\Application\Core\Inc\common.h
L476_USER_APP\UserApp\Application\Core\Inc\flash_if.h
L476_USER_APP\UserApp\Application\Core\Inc\fw_update_app.h
L476_USER_APP\UserApp\Application\Core\Inc\main.h
L476_USER_APP\UserApp\Application\Core\Inc\se_user_code.h
L476_USER_APP\UserApp\Application\Core\Inc\sfu_app_new_image.h
L476_USER_APP\UserApp\Application\Core\Inc\stm32l4xx_hal_conf.h
L476_USER_APP\UserApp\Application\Core\Inc\stm32l4xx_it.h
L476_USER_APP\UserApp\Application\Core\Inc\test_protections.h
L476_USER_APP\UserApp\Application\Core\Inc\ymodem.h
L476_USER_APP\UserApp\Application\Core\Src\com.c
L476_USER_APP\UserApp\Application\Core\Src\common.c
L476_USER_APP\UserApp\Application\Core\Src\flash_if.c
L476_USER_APP\UserApp\Application\Core\Src\fw_update_app.c
L476_USER_APP\UserApp\Application\Core\Src\main.c
L476_USER_APP\UserApp\Application\Core\Src\se_user_code.c
L476_USER_APP\UserApp\Application\Core\Src\sfu_app_new_image.c
L476_USER_APP\UserApp\Application\Core\Src\stm32l4xx_it.c
L476_USER_APP\UserApp\Application\Core\Src\test_protections.c
L476_USER_APP\UserApp\Application\Core\Src\ymodem.c
L476_USER_APP\UserApp\Application\User\syscalls.c
L476_USER_APP\UserApp\Doc\readme.txt
L476_USER_APP\UserApp\Drivers\CMSIS\system_stm32l4xx.c
L476_USER_APP\UserApp\Output\crypto.txt
L476_USER_APP\UserApp\Output\output.txt
L476_USER_APP\UserApp\Startup\startup_stm32l476xx.s
L476_USER_APP\UserApp\.cproject
L476_USER_APP\UserApp\.project
L476_USER_APP\UserApp\STM32L476RGTx.ld
L476_USER_APP\.project

L476_USER_APP\Common\Binary_Keys\ECCKEY1.txt

-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIIEobnAEKh92mvSE+X70hQMvFb8LOg+TGB9Dqu4dyvO8oAoGCCqGSM49
AwEHoUQDQgAEuvKX+D7jB9wWw3F4HfGwPvCVsERUEoFI+yxmuVQ9pUroJgR2tzeL
PEbY/WpjYXxGw33pRkQxbtfhbbpw7US6Ag==
-----END EC PRIVATE KEY-----

L476_USER_APP\Common\KeysAndImages_Util\keys.py
1	# Copyright(c) 2018 STMicroelectronics International N.V.
2	# Copyright 2017 Linaro Limited
3	#
4	# Licensed under the Apache License, Version 2.0 (the "License");
5	# you may not use this file except in compliance with the License.
6	# You may obtain a copy of the License at
7	#
8	#     http://www.apache.org/licenses/LICENSE-2.0
9	#
10	# Unless required by applicable law or agreed to in writing, software
11	# distributed under the License is distributed on an "AS IS" BASIS,
12	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13	# See the License for the specific language governing permissions and
14	# limitations under the License.
15
16	import os
17	from Cryptodome.Cipher import AES
18	from Cryptodome.Hash import SHA256
19	from ecdsa import SigningKey, NIST256p, util
20	import hashlib
21	from struct import pack
22	import translate_key
23	import numpy
24	#for AES_CBC lambda pad to 16 bytes by adding the padded value
25	#(i.e 24 bytes : 0x08 is added  8 times
26	BS = 16
27	pad = lambda s: s + (BS - len(s) % BS) * pack("B", 0)
28
29	class AES_CBC():
30	    def __init__(self, key):
31	        """Construct an AES_CBC private key with the given key data"""
32	        self.key = key
33	        self.nonce = []
34	    @staticmethod
35	    def generate():
36	        #use random from platform
37	        return AES_CBC(os.urandom(16))
38	    def export_private(self, path):
39	        if "AES_CBC" not in path:
40	          print("path does not contains AES_CBC : AES_CBC key should contain AES_CBC string!!!")
41	          exit(1)
42	        else:
43	          with open(path, 'wb') as f:
44	             f.write(self.key)
45	    def encrypt(self, payload, nonce=[]):
46	        if payload == []:
47	            print("error")
48	        #Fix me AES CBC is possibly 12 bytes
49	        if nonce == []:
50	            nonce = os.urandom(16)
51	        m = hashlib.sha256()
52	        print("block size ="+str(AES.block_size))
53	        encryptor = AES.new(self.key, AES.MODE_CBC, nonce)
54	        encrypted = ""
55	        #check if buffer size is aligned on BS size
56	        if (0 == (len(payload) % BS)):
57	          # we do not need to pad
58	          buffer=payload
59	          encrypted =  encryptor.encrypt(buffer)
60	        else:
61	          # Buffer size is not correct (and we do not support ciphertext stealing mode "CBC-CS2" specified in NIST SP 800-38A any more)
62	          raise Exception("AES CBC encryption requires the Firmware Image size to be a multiple of the AES block size (16 bytes)")
63	        #compute sh256 on clear buffer without padding
64	        m.update(payload)
65	        signature = m.digest()
66	        #swap the last two block and truncate if required
67	        return encrypted,signature, nonce
68	    def trans(self,section, name, end, assembly, version):
69	        outcode = translate_key.function(section, name,assembly)
70	        outcode += translate_key.translate(self.key,end,assembly, version)
71	        return outcode
72	    def has_nonce(self):
73	        return True
74	    def has_sign(self):
75	        return False
76	    def has_encrypt(self):
77	        return True
78	    def get_key(self, type):
79	        return self.key
80
81	class AES_CTR():
82	    def __init__(self, key):
83	        """Construct an AES_CTR private key with the given key data"""
84	        self.key = key
85	        self.nonce = []
86	    @staticmethod
87	    def generate():
88	        #use random from platform
89	        return AES_CTR(os.urandom(16))
90	    def export_private(self, path):
91	        if "AES_CTR" not in path:
92	          print("path does not contains AES_CTR : AES_CTR key should contain AES_CTR string!!!")
93	          exit(1)
94	        else:
95	          with open(path, 'wb') as f:
96	             f.write(self.key)
97	    def encrypt(self, payload, address, nonce=[]):
98	        if payload == []:
99	          print("error")
100	        m = hashlib.sha256()
101	        #Swap bytes inside 16 bytes block
102	        inarr = numpy.asarray(list(payload), numpy.int8).reshape(-1, 16)
103	        outarr = numpy.fliplr(inarr)
104	        payload = bytearray(outarr)
105	        print("block size ="+str(AES.block_size))
106	        #Encryption
107	        if nonce == []:
108	          encryptor = AES.new(self.key, AES.MODE_CTR, initial_value=address);
109	        else:
110	          encryptor = AES.new(self.key, AES.MODE_CTR, nonce=nonce, initial_value=address);
111	        encrypted = ""
112	        #check if buffer size is aligned on BS size
113	        if (0 == (len(payload) % BS)):
114	          # we do not need to pad
115	          buffer=payload
116	          encrypted =  encryptor.encrypt(buffer)
117	          nonce = encryptor.nonce
118	        else:
119	          raise Exception("AES CTR encryption requires the Firmware Image size to be a multiple of the AES block size (16 bytes)")
120	        #Swap bytes inside 16 bytes block
121	        inarr = numpy.asarray(list(encrypted), numpy.int8).reshape(-1, 16)
122	        outarr = numpy.fliplr(inarr)
123	        encrypted = bytearray(outarr)
124	        #compute sh256 on encrypted buffer without padding
125	        m.update(encrypted)
126	        signature = m.digest()
127	        #swap the last two block and truncate if required
128	        return encrypted,signature,nonce
129	    def trans(self,section, name, end, assembly, version):
130	        outcode = translate_key.function(section, name,assembly)
131	        outcode += translate_key.translate(self.key,end,assembly, version)
132	        return outcode
133	    def has_nonce(self):
134	        return True
135	    def has_sign(self):
136	        return False
137	    def has_encrypt(self):
138	        return True
139	    def get_key(self, type):
140	        return self.key
141
142	class AES_GCM():
143	    def __init__(self, key):
144	        """Construct an AES_GCM private key with the given key data"""
145	        self.key = key
146	        self.nonce = []
147	    @staticmethod
148	    def generate():
149	        #use random from platform
150	        return AES_GCM(os.urandom(16))
151	    def export_private(self, path):
152	        if "AES_CBC" in path:
153	          print("path contains AES_CBC : AES_GCM key should not contain AES_CBC!!!")
154	          exit(1)
155	        else:
156	          with open(path, 'wb') as f:
157	              f.write(self.key)
158	    def encrypt(self, payload, nonce=[]):
159	        if payload == []:
160	            print("error")
161
162	        if nonce == []:
163	            nonce = os.urandom(12)
164	        encryptor = AES.new(self.key, AES.MODE_GCM, nonce)
165	        encrypted = encryptor.encrypt(payload)
166	        signature = encryptor.digest()
167	        return encrypted,signature, nonce
168	    def sign(self,payload, nonce):
169	        encryptor = AES.new(self.key, AES.MODE_GCM, nonce)
170	        encryptor.update(payload)
171	        signature =  encryptor.digest()
172	        return signature, nonce
173	    def trans(self,section, name, end, assembly, version):
174	        outcode = translate_key.function(section, name,assembly)
175	        outcode += translate_key.translate(self.key,end,assembly, version)
176	        return outcode
177	    def has_nonce(self):
178	        return True
179	    def has_sign(self):
180	        return True
181	    def has_encrypt(self):
182	        return True
183	    def get_key(self, type):
184	        return self.key
185
186
187	class ECDSA256P1():
188	    def __init__(self, key):
189	        """Construct an ECDSA P-256 private key"""
190	        self.key = key
191
192	    @staticmethod
193	    def generate():
194	        return ECDSA256P1(SigningKey.generate(curve=NIST256p))
195
196	    def export_private(self, path):
197	        with open(path, 'wb') as f:
198	            f.write(self.key.to_pem())
199	    def trans(self,section, name, end, assembly, version):
200	        vk = self.key.get_verifying_key()
201	        binarykey = vk.to_string()
202	        #generate asm code
203	        outcode = translate_key.function(section, name,assembly)
204	        outcode += translate_key.translate(binarykey,end,assembly, version )
205	        return outcode
206
207	    def sign(self, payload):
208	        # To make this fixed length, possibly pad with zeros.
209	        sig = self.key.sign(payload, hashfunc=hashlib.sha256)
210	        return sig
211
212	    def has_nonce(self):
213	        return False
214	    def has_sign(self):
215	        return True
216
217	    def has_encrypt(self):
218	        return False
219
220	    def get_key(self, type):
221	        if (type == "public"):
222	            vk = self.key.get_verifying_key()
223	            return vk.to_string()
224	        else:
225	            return self.key.to_pem()
226
227	class PAIRING():
228	    def __init__(self, key):
229	        """Construct an PAIRING private key with the given key data"""
230	        self.key = key
231	        self.nonce = []
232	    @staticmethod
233	    def generate():
234	        print("Pairing class unsupported !!")
235	        exit(1)
236	    def export_private(self, path):
237	        print("Pairing class unsupported !!")
238	        exit(1)
239	    def encrypt(self, payload, nonce=[]):
240	        print("Pairing class unsupported !!")
241	        exit(1)
242	    def sign(self,payload, nonce):
243	        print("Pairing class unsupported !!")
244	        exit(1)
245	    def trans(self,section, name, end, assembly, version):
246	        outcode = translate_key.function(section, name,assembly)
247	        outcode += translate_key.translate(self.key,end,assembly, version)
248	        return outcode
249	    def has_nonce(self):
250	        print("Pairing class unsupported !!")
251	        exit(1)
252	    def has_sign(self):
253	        print("Pairing class unsupported !!")
254	        exit(1)
255	    def has_encrypt(self):
256	        print("Pairing class unsupported !!")
257	        exit(1)
258	    def get_key(self, type):
259	        return self.key
260
261	def load(path):
262	    with open(path, 'rb') as f:
263	        pem = f.read()
264	    if len(pem) == 16:
265	        if "AES_CBC" in path:
266	          return AES_CBC(pem)
267	        elif "AES_CTR" in path:
268	          return AES_CTR(pem)
269	        else:
270	          return AES_GCM(pem)
271	    elif len(pem) == 32:
272	        return PAIRING(pem)
273	    else:
274	        key = SigningKey.from_pem(pem)
275	        if key.curve.name == 'NIST256p':
276	            return ECDSA256P1(key)
277	        else:
278	            raise Exception("Unsupported")
279
280
281
L476_USER_APP\Common\KeysAndImages_Util\prepareimage.py
1	# Copyright(c) 2018 STMicroelectronics International N.V.
2	# Copyright 2017 Linaro Limited
3	#
4	# Licensed under the Apache License, Version 2.0 (the "License");
5	# you may not use this file except in compliance with the License.
6	# You may obtain a copy of the License at
7	#
8	#     http://www.apache.org/licenses/LICENSE-2.0
9	#
10	# Unless required by applicable law or agreed to in writing, software
11	# distributed under the License is distributed on an "AS IS" BASIS,
12	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13	# See the License for the specific language governing permissions and
14	# limitations under the License.
15	#
16	import keys
17	import sys
18	import argparse
19	import os
20	import hashlib
21	import numpy
22	import elftools
23	#import string
24	from elftools.elf.elffile import ELFFile
25	from struct import pack
26
27	def gen_ecdsa_p256(args):
28	    keys.ECDSA256P1.generate().export_private(args.key)
29
30	def gen_aes_gcm(args):
31	    keys.AES_GCM.generate().export_private(args.key)
32
33	def gen_aes_cbc(args):
34	    keys.AES_CBC.generate().export_private(args.key)
35
36	def gen_aes_ctr(args):
37	    keys.AES_CTR.generate().export_private(args.key)
38
39
40	keygens = {
41	        'aes-gcm': gen_aes_gcm,
42	        'aes-cbc': gen_aes_cbc,
43	        'aes-ctr': gen_aes_ctr,
44	        'ecdsa-p256': gen_ecdsa_p256,
45	        }
46
47	def do_keygen(args):
48	    if args.type not in keygens:
49	        msg = "Unexpected key type: {}".format(args.type)
50	        raise argparse.ArgumentTypeError(msg)
51	    keygens[args.type](args)
52
53	def do_trans(args):
54	    key = keys.load(args.key)
55	    end = False
56	    if args.end:
57	        end = True
58	    if args.assembly=="ARM" or args.assembly=="IAR" or args.assembly=="GNU":
59	        if args.version=="V6M" or args.version=="V7M":
60	          out = key.trans(args.section, args.function, end, args.assembly, args.version)
61	          print (str(out))
62	        else:
63	          print ("-v option : Cortex M architecture not supported")
64	          exit(1)
65	    else:
66	        print ("-a option : assembly option not supported")
67	        exit(1)
68
69	def do_getpub(args):
70	    key = keys.load(args.key)
71	    key.emit_c()
72
73	def do_sign(args):
74	    payload = []
75	    with open(args.infile, 'rb') as f:
76	        payload = f.read()
77	    # Removing the padding because the hashlib pads properly (512 bit alignment) for SHA256
78	    # payload = pad(payload)
79	    key = keys.load(args.key) if args.key else None
80	    if key.has_sign():
81	        if key.has_nonce():
82	            nonce = []
83	            try:
84	                with open(args.nonce, 'rb') as f:
85	                    nonce = f.read()
86	            except:
87	                nonce= []
88	            encrytpted, signature , nonce_used = key.encrypt( payload, nonce)
89	            if nonce !=nonce_used:
90	                try:
91	                    f = open(args.nonce, 'wb')
92	                    f.write(nonce_used)
93	                    f.close()
94	                except:
95	                    print("nonce filename required")
96	                    exit(1)
97	        else:
98	            signature  = key.sign(payload)
99	        f = open(args.outfile,"wb")
100	        f.write(signature)
101	        f.close()
102	    else:
103	        print("Provided Key is not usable to sign ")
104	        exit(1)
105
106
107	def do_sha(args):
108	    payload = []
109	    with open(args.infile, 'rb') as f:
110	        payload = f.read()
111	    m = hashlib.sha256()
112	    buffer=payload
113	    m.update(buffer)
114	    signature = m.digest()
115	    f = open(args.outfile, "wb")
116	    f.write(signature)
117	    f.close()
118
119	def do_encrypt(args):
120	    payload = []
121	    with open(args.infile, 'rb') as f:
122	        payload = f.read()
123	        f.close()
124	    key = keys.load(args.key) if args.key else None
125	    if key.has_encrypt():
126	        if key.has_nonce():
127	            nonce = []
128	            if args.nonce and args.iv:
129	                print("either IV or Nonce Required for this key!!!")
130	                exit(1)
131	            if args.nonce:
132	                iv_nonce=args.nonce
133	            elif args.iv:
134	                iv_nonce=args.iv
135	            else:
136	                print("either IV or Nonce Required for this key!!!")
137	                exit(1)
138	            if os.path.isfile(iv_nonce):
139	                with open(iv_nonce, 'rb') as f:
140	                    nonce = f.read()
141	            if args.poffset:
142	                with open(args.poffset, 'r') as f:
143	                  offset = int(f.read())
144	                # AES CTR : remove 4 LSB bits to the address
145	                offset = int(offset / 16)
146	            else:
147	                offset = 0
148	            if args.address:
149	                address = args.address + offset
150	                encrypted , signature , nonce_used = key.encrypt(payload, address, nonce)
151	            else:
152	                encrypted , signature , nonce_used = key.encrypt(payload, nonce)
153	            if nonce !=nonce_used:
154	                f = open(iv_nonce, 'wb')
155	                f.write(nonce_used)
156	                f.close()
157	        else:
158	            encrypted ,signature = key.encrypt(payload)
159
160	        f=open(args.outfile,"wb")
161	        f.write(encrypted)
162	        f.close()
163	    else:
164	        print("Key does not support encrypt")
165	        exit(1)
166
167	def do_header_lib(args):
168	    if (os.path.isfile(args.firmware)):
169	        size = os.path.getsize(args.firmware)
170	    else:
171	        print("no fw file")
172	        exit(1)
173	    if os.path.isfile(args.tag):
174	        f=open(args.tag, 'rb')
175	        tag = f.read()
176	    if args.cert_fw_leaf :
177	      if os.path.isfile(args.cert_fw_leaf):
178	          print("Loading cert: "+args.cert_fw_leaf)
179	          f=open(args.cert_fw_leaf, 'rb')
180	          cert_fw_leaf = f.read()
181	    if args.cert_fw_inter :
182	      if os.path.isfile(args.cert_fw_inter):
183	          print("Loading cert: "+args.cert_fw_inter)
184	          f=open(args.cert_fw_inter, 'rb')
185	          cert_fw_inter = f.read()
186
187	    key = keys.load(args.key) if args.key else None
188	    #empty nonce
189	    nonce = b''
190	    protocol = args.protocol
191	    magic = args.magic.encode()
192	    version = args.version
193	    reserved = b'\0'*args.reserved
194	    if args.nonce and args.iv:
195	        print("either IV or Nonce Required !!!")
196	        exit(1)
197	    iv_nonce=""
198	    if args.nonce:
199	        iv_nonce=args.nonce
200	    elif args.iv:
201	        iv_nonce=args.iv
202	    if iv_nonce:
203	        with open(iv_nonce, 'rb') as f:
204	            nonce = f.read()
205	    if args.pfw:
206	        pfwsize = os.path.getsize(args.pfw)
207	    else:
208	        pfwsize = size
209	    if args.poffset:
210	        with open(args.poffset, 'r') as f:
211	            pfwoffset = int(f.read())
212	    else:
213	        pfwoffset = 0
214	    if args.ptag:
215	        f=open(args.ptag, 'rb')
216	        pfwtag = f.read()
217	        f.close()
218	    else:
219	        pfwtag=tag
220	    print("Magic: "+str(magic)+"!!")
221	    header = pack('<'+str(len(magic))+'sHHIII'+str(len(tag))+'s'+str(len(pfwtag))+'s'+str(len(nonce))+'s'+str(args.reserved)+'s',
222	                    magic, protocol, version, size, pfwoffset, pfwsize, tag, pfwtag, nonce, reserved)
223	    #add certs
224	    # Add certificates
225	    if args.cert_fw_leaf :
226	        print("adding leaf cert of length "+str(str(len(cert_fw_leaf))))
227	        header +=pack(str(len(cert_fw_leaf))+'s',cert_fw_leaf)
228	    if args.cert_fw_inter :
229	        print("adding intermediate cert of length "+str(str(len(cert_fw_inter))))
230	        header +=pack(str(len(cert_fw_inter))+'s',cert_fw_inter)
231	    # Pad, leaving 64 bytes for signature + 3*32 bytes for image state + 32 Fingerprint
232	    if (args.cert_fw_leaf or args.cert_fw_inter):
233	        if 'pack' in args.subcmd:
234	            padding = args.offset - (len(header) + 3*32 + 32 + 64)
235	        else:
236	            padding = args.offset - (len(header) + 3*32 + 32 + 64)
237	        if (padding<0):
238	            print("Invalid padding: "+str(padding))
239	            exit(1)
240	        else:
241	            print("Adding padding: "+str(padding))
242	        header += b'\0'*padding
243	    #GCM needs Nonce to sign
244	    #AES cannot sign
245	    if key.has_sign():
246	        if key.has_nonce() and iv_nonce=="":
247	            print("sign key required nonce, provide nonce")
248	            exit(1)
249	        if key.has_nonce():
250	            if nonce != b'':
251	                signature , nonce_used = key.sign(header, nonce)
252	                if nonce_used !=nonce:
253	                    print("error nonce used differs")
254	                    exit(1)
255	            else:
256	                print("nonce required for this key")
257	                exit(1)
258	        else:
259	            signature = key.sign(header)
260	        header +=pack(str(len(signature))+'s',signature)
261	    else:
262	        print("Provided Key is not usable to sign header")
263	        exit(1)
264
265	    if 'pack' in args.subcmd:
266	        # image state = new
267	        header += b'\xFF'*96
268	    else:
269	        # image state = valid
270	        header += b'\xFF'*32
271	        header += b'\x00'*64
272	    # UpdateSourceFingerpr­int - init to 0x00
273	    header += b'\x00'*32
274	    return header, signature
275
276	#header is used only to build install header for merge .elf tool
277	def do_header(args):
278	    header ,signature  = do_header_lib(args)
279	    f=open(args.outfile,"wb")
280	    if len(signature) == 16:
281	        signature = 2*signature
282	    elif len(signature) == 64:
283	        signature = signature[0:32]
284	    else:
285	        print("Unexpected signature size : "+str(len(signature))+"!!")
286	    f.write(header)
287	    padding = args.offset - (len(header))
288	    while (padding != 0):
289	        f.write(b'\xff')
290	        padding = padding - 1
291	    f.close()
292
293	def do_conf(args):
294	    if (os.path.isfile(args.infile)):
295	        f = open(args.infile)
296	        for myline in f:
297	            if args.define in myline:
298	                myword = myline.split()
299	                if myword[1] == args.define:
300	                    print(myword[2])
301	                    f.close()
302	                    return
303	        f.close()
304	        print("#DEFINE "+args.define+" not found")
305	        exit(1)
306
307	def do_extract(args):
308	    if (os.path.isfile(args.infile)):
309	        f = open(args.infile)
310	        for myline in f:
311	            if args.define in myline:
312	                myword = myline.split('0x')
313	                print('0x'+ myword[1][:8])
314	                f.close()
315	                return
316	        f.close()
317	        print(args.define+" not found")
318	        exit(1)
319
320	def do_pack(args):
321	    header,signature = do_header_lib(args)
322	    f=open(args.outfile,"wb")
323	    f.write(header)
324	    if len(header) > args.offset:
325	        print("error header is larger than offset before binary")
326	        sys.exit(1)
327
328	    #create the string to padd
329	    tmp = (args.offset-len(header))*b'\xff'
330	    #write to file
331	    f.write(tmp)
332	    if args.pfw:
333	        #recopy encrypted partial file
334	        binary=open(args.pfw,'rb')
335	    else:
336	        #recopy encrypted complete file
337	        binary=open(args.firmware,'rb')
338	    tmp=binary.read()
339	    f.write(tmp)
340	    binary.close()
341	#find lowest sction to fix base address not matching
342	def find_lowest_section(elffile):
343	     lowest_addr = 0
344	     lowest_size = 0
345	     for s in elffile.iter_sections():
346	        if (s.header['sh_flags'] & elftools.elf.constants.SH_FLAGS.SHF_ALLOC) and (s.header.sh_type != 'SHT_NOBITS'):
347	            sh_addr =  s.header['sh_addr'];
348	            if lowest_addr == 0:
349	                lowest_addr = sh_addr
350	            elif sh_addr < lowest_addr:
351	                lowest_addr = sh_addr
352	                lowest_size = s.header['sh_size']
353	     return lowest_addr, lowest_size
354
355	#return base address of segment, and a binary array,
356	#add padding pattern
357	def get_binary(elffile,pad=0xff, elftype=0):
358	    num = elffile.num_segments()
359	    print("number of segment :"+str(num))
360	    for i in range(0,num):
361	        segment= elffile.get_segment(i)
362	        if segment['p_type'] == 'PT_LOAD':
363	          if i!=0:
364	            print(hex(nextaddress))
365	            if (len(segment.data())):
366	                padd_size=segment.__getitem__("p_paddr")- nextaddress
367	                binary+=padd_size*pack("B",pad)
368	                binary+=segment.data()
369	                nextaddress = segment.__getitem__("p_paddr") + len(segment.data())
370	          else:
371	            binary=segment.data()
372	            if elftype == 0:
373	              base_address =  segment.__getitem__("p_paddr")
374	            else:
375	              base_address , lowest_size =  find_lowest_section(elffile)
376	              offset = base_address - segment.__getitem__("p_paddr")
377	              binary = binary[offset:]
378	            nextaddress = base_address + len(binary)
379	    return binary, base_address
380
381	def do_merge(args):
382	    #get the different element to compute the big binary
383	    if args.userapp:
384	      with open(args.userapp, 'rb') as f:
385	          # get the data
386	          my_elffile = ELFFile(f)
387	          appli_binary, appli_base = get_binary(my_elffile, args.value,args.elf)
388	    with open(args.sbsfu, 'rb') as f:
389	        my_elffile = ELFFile(f)
390	        sbsfu_binary, sbsfu_base = get_binary(my_elffile, args.value, args.elf)
391	    with open(args.install, 'rb') as f:
392	        header_binary = f.read()
393	    if args.loader:
394	        with open(args.loader, 'rb') as f:
395	            # get the data
396	            my_elffile = ELFFile(f)
397	            loader_binary, loader_base = get_binary(my_elffile, args.value,args.elf)
398	    #merge the three or four elements and padd in between , add some extra byte to
399	    #appli for aes cbc support
400	    address_just_after_s­bsfu = len(sbsfu_binary)+sbsfu_base
401	    if args.loader:
402	        beginaddress_loader = loader_base
403	        address_just_after_l­oader = len(loader_binary)+loader_base
404	    if args.header:
405	      beginaddress_header = args.header
406	    else:
407	      beginaddress_header = appli_base - len(header_binary)
408	    if args.loader and (beginaddress_loader < address_just_after_s­bsfu):
409	        print("sbsfu is too large to merge with loader !!")
410	        exit(2)
411	    elif args.loader and (beginaddress_header < address_just_after_l­oader):
412	        print("loader is too large to merge with appli !!")
413	        exit(3)
414	    else:
415	        print("Merging")
416	        print("SBSFU Base = "+hex(sbsfu_base))
417	        if args.loader:
418	            print("Loader Base = "+hex(loader_base))
419	        print("Writing header = "+hex(beginaddress_header))
420	        if args.userapp:
421	            print("APPLI Base = "+hex(appli_base))
422	        if args.loader:
423	            padd_before_loader = beginaddress_loader - address_just_after_s­bsfu
424	            padd_before_header =   beginaddress_header - address_just_after_l­oader
425	            big_binary = sbsfu_binary + padd_before_loader * pack("B",args.value)+ loader_binary + padd_before_header * pack("B",args.value) + header_binary + appli_binary
426	        elif args.header:
427	            if args.userapp:
428	                # header not contiguous : SBSFU + pad + header + pad + header(fake) + UserApp
429	                padd_before_header = beginaddress_header - address_just_after_s­bsfu
430	                padd_before_appli = appli_base - len(header_binary) - padd_before_header - len(header_binary) - address_just_after_s­bsfu
431	                big_binary = sbsfu_binary + padd_before_header * pack("B",args.value) + header_binary + padd_before_appli * pack("B",args.value) + header_binary + appli_binary
432	            else:
433	                # header not contiguous : SBSFU + header + SBSFU (loader part)
434	                offset_header = beginaddress_header - sbsfu_base
435	                big_binary = sbsfu_binary[:offset_header] + header_binary + sbsfu_binary[offset_header + len(header_binary):]
436	        else:
437	            padd_before_header =   beginaddress_header - address_just_after_s­bsfu
438	            big_binary = sbsfu_binary + padd_before_header * pack("B",args.value) + header_binary + appli_binary
439
440	    print("Writing to "+str(args.outfile)+" "+str(len(big_binary)))
441	    with open(args.outfile, 'wb') as f:
442	        f.write(big_binary)
443
444	def sub_mergev2(args, bb_dict, bin, bin_base, bin_end):
445	    #print("Current BB : "+hex(bb_dict["bb_base"])+" > "+hex(bb_dict["bb_end"]))
446	    #print("Add segment: "+hex(bin_base)+" > "+hex(bin_end))
447	    # injection
448	    # 6 cases:
449	    #  Elf is strictly inside BB range  => First check there is no useful data in BB range that will be erased by elf file, then copy elf contents into BB
450	    if (bin_base > bb_dict["bb_base"]) and (bin_end < bb_dict["bb_end"]):
451	        # Check overlap data
452	        overlapzone = bb_dict["big_binary"][bin_base-bb_dict["bb_base"]+1:(bin_base-bb_dict["bb_base"])+len(bin)-1]
453	        for b in overlapzone:
454	          if b != args.value:
455	            print("ERROR: overlapped zone is not empty")
456	            exit(3)
457	        # Create new BB
458	        bb_dict["big_binary"] = bb_dict["big_binary"][:bin_base-bb_dict["bb_base"]] + bin + bb_dict["big_binary"][(bin_base-bb_dict["bb_base"])+len(bin):]
459	        # bb_dict["bb_base"] and bb_dict["bb_end"] do not change
460	    #  Elf is before BB range  => No issue, paste both with padding in between
461	    elif (bin_end <= bb_dict["bb_base"]):
462	        bb_dict["big_binary"] = bin + (bb_dict["bb_base"] - bin_end) * pack("B",args.value) + bb_dict["big_binary"]
463	        bb_dict["bb_base"] = bin_base
464	        # bb_dict["bb_end"] do not change
465	    #  Elf is after BB range   => No issue, paste both with padding in between
466	    elif (bin_base >= bb_dict["bb_end"]):
467	        bb_dict["big_binary"] = bb_dict["big_binary"] + (bin_base - bb_dict["bb_end"]) * pack("B",args.value) + bin
468	        bb_dict["bb_end"] = bin_end
469	        # bb_start do not change
470	    #  Elf starts before BB start and ends inside BB range => !!! abnormal case not supported !!!
471	    elif (bin_base <= bb_dict["bb_base"]) and (bin_end <= bb_dict["bb_end"]):
472	        print("ERROR current binary is overlapping with previously aggregated binaries !!")
473	        exit(2)
474	    #  Elf starts inside BB range and ends after BB end    => !!! abnormal case not supported !!!
475	    elif (bin_base >= bb_dict["bb_base"]) and (bin_end >= bb_dict["bb_end"]):
476	        print("ERROR current binary is overlapping with previously aggregated binaries !!")
477	        exit(2)
478	    #  Elf starts before BB start and ends after BB end  => First check there is no useful data in ELF file range that will be erased by BB, then copy BB contents into elf file binary that becomes new BB
479	    elif (bin_base < bb_dict["bb_base"]) and (bin_end > bb_dict["bb_end"]):
480	        # Check overlap data
481	        overlapzone = bin[bb_dict["bb_base"]-bin_base+1:(bb_dict["bb_base"]-bin_base)+len(bb_dict["big_binary"])-1]
482	        for b in overlapzone:
483	          if b != args.value:
484	            print("ERROR: overlapped zone is not empty")
485	            exit(3)
486	        # Create new BB
487	        bb_dict["big_binary"] = bin[:bb_dict["bb_base"]-bin_base] + bb_dict["big_binary"] + bin[(bb_dict["bb_base"]-bin_base)+len(bb_dict["big_binary"]):]
488	        bb_dict["bb_base"] = bin_base
489	        bb_dict["bb_end"] = bin_end
490	    else:
491	        print("ERROR segment configuration is generating not managed case !!")
492	        exit(99)
493
494	def do_mergev2(args):
495	    bb_dict=dict()
496	    # loop on elf files
497	    if args.files:
498	      elffiles = args.files.split(';')
499	      for ef in elffiles:
500	        with open(ef, 'rb') as f:
501	            # get the data
502	            my_elffile = ELFFile(f)
503	            elf_binary, elf_base = get_binary(my_elffile, args.value,args.elf)
504	            elf_end = elf_base + len(elf_binary)
505	            print("Adding ELF file: "+ef+" from "+hex(elf_base)+" to "+hex(elf_end))
506	            # check if first file or injection needed
507	            if 'big_binary' in bb_dict:
508	              sub_mergev2(args, bb_dict, elf_binary, elf_base, elf_end)
509	            else:
510	              # first copy
511	              bb_dict['big_binary'] = elf_binary
512	              bb_dict['bb_base'] = elf_base
513	              bb_dict['bb_end'] = elf_end
514	    # loop on binary files
515	    binfiles = args.binaries.split(';')
516	    for bf in binfiles:
517	      #print(bf)
518	      _bf, _add = bf.split('@')
519	      with open(_bf, 'rb') as f:
520	          # get the data
521	          bin_binary = f.read()
522	          bin_base = auto_int(_add) & 0xffffffff
523	          bin_end = bin_base + len(bin_binary)
524	          print("Adding BIN file: "+_bf+" from "+hex(bin_base)+" to "+hex(bin_end))
525	          # check if first file or injection needed
526	          if 'big_binary' in bb_dict:
527	            sub_mergev2(args, bb_dict, bin_binary, bin_base, bin_end)
528	          else:
529	            # first copy
530	            bb_dict['big_binary'] = bin_binary
531	            bb_dict['bb_base'] = bin_base
532	            bb_dict['bb_end'] = bin_end
533
534	    print("Writing to "+str(args.outfile)+" "+str(len(bb_dict['big_binary'])))
535	    with open(args.outfile, 'wb') as f:
536	        f.write(bb_dict['big_binary'])
537	    with open(args.outfile+".baseadd", 'w') as f:
538	        f.write(hex(bb_dict['bb_base']))
539
540
541	def do_append(args):
542	    #get the different element to compute the binary
543	    with open(args.userapp, 'rb') as f:
544	        my_elffile = ELFFile(f)
545	        appli_binary, appli_base = get_binary(my_elffile, args.value,args.elf)
546	    with open(args.binary, 'rb') as f:
547	        input_binary = f.read()
548	    with open(args.install, 'rb') as f:
549	        header_binary = f.read()
550
551	    #Add header + user application to the existing binary and padd in between
552	    input_binary_base = args.address
553	    address_just_after_i­nput_binary = len(input_binary) + input_binary_base
554	    if args.header:
555	      beginaddress_header = args.header
556	    else:
557	      beginaddress_header = appli_base - len(header_binary)
558	    print("Merging")
559	    print("Binary base = "+hex(input_binary_base))
560	    print("Writing header = "+hex(beginaddress_header))
561	    print("APPLI base = "+hex(appli_base))
562	    if beginaddress_header < address_just_after_i­nput_binary:
563	        # header not contiguous : input binary + header + input binary (remaining part) + pad + header(fake) + UserApp
564	         padd_before_appli = appli_base - len(header_binary) - address_just_after_i­nput_binary
565	         offset_header = beginaddress_header - input_binary_base
566	         output_binary = input_binary[:offset_header] + header_binary + input_binary[offset_header + len(header_binary):] + padd_before_appli * pack("B",args.value) + header_binary + appli_binary
567	    else:
568	        # header not contiguous : input binary + pad + header + UserApp
569	         padd_before_appli = appli_base - len(header_binary) - address_just_after_i­nput_binary
570	         output_binary = input_binary + + padd_before_appli * pack("B",args.value) + header_binary + appli_binary
571	    print("Writing to "+str(args.outfile)+" "+str(len(output_binary)))
572	    with open(args.outfile, 'wb') as f:
573	        f.write(output_binary)
574
575	def do_diff(args):
576	    # Check args
577	    if args.align == 0:
578	        msg = "Wrong alignment value, must be greater than 0"
579	        raise argparse.ArgumentTypeError(msg)
580	    if args.begin % args.align > 0:
581	        msg = "Wrong begin value ({}), must be a modulo of the specified alignment ({})".format(args.begin, args.align)
582	        raise argparse.ArgumentTypeError(msg)
583	    if args.end > 0 and (args.end + 1) % args.align > 0:
584	        msg = "Wrong end value ({}), must be last offset of a block defined by alignment ({})".format(args.end, args.align)
585	        raise argparse.ArgumentTypeError(msg)
586
587	    # Append the file 1 to get a size modulo alignment
588	    arr1 = numpy.fromfile(args.file1, numpy.int8)
589	    size = args.align - (arr1.size % args.align)
590	    for ite in range(0, size):
591	        arr1 = numpy.append(arr1, [0])
592	    arr1 = arr1.reshape(-1, args.align)
593
594	    # Append the file 2 to get a size modulo alignment
595	    arr2 = numpy.fromfile(args.file2, numpy.int8)
596	    arr2size = arr2.size
597	    size = args.align - (arr2.size % args.align)
598	    for ite in range(0, size):
599	        arr2 = numpy.append(arr2, [0])
600	    arr2 = arr2.reshape(-1, args.align)
601
602	    if args.end > 0 and args.end >= arr2.size:
603	        msg = "Wrong end set ({}), must be a within secondary binary file range ({})".format(args.end, arr2.size)
604	        raise argparse.ArgumentTypeError(msg)
605
606	    if arr1.size == arr2.size:
607	        # Both files to compare have same size
608	        if args.end > 0 and args.end < arr1.size:
609	            # args.end is specified within file size
610	            end_cmp = args.end
611	        else:
612	            # args.end is not specified or is out of file size
613	            end_cmp = arr1.size - 1
614	        # No additional data, copy stops at end of comparison
615	        end_cpy = -1
616	    elif arr1.size > arr2.size:
617	        # Primary file bigger than secondary
618	        if args.end > 0 and args.end < arr2.size:
619	            # args.end is specified within secondary file size
620	            end_cmp = args.end
621	        else:
622	            # args.end is not specified or is out of secondary file size
623	            end_cmp = arr2.size - 1
624	        # No additional data, copy stops at end of comparison
625	        end_cpy = -1
626	    else:  # arr2.size > arr1.size
627	        if args.end > 0 and args.end < arr1.size:
628	            # args.end is specified within primary file size
629	            end_cmp = args.end
630	            # No additional data, copy stops at end of comparison
631	            end_cpy = -1
632	        else:
633	            # args.end is not specified or is out of primary file size
634	            end_cmp = arr1.size - 1
635	            if args.end > 0 and args.end < arr2.size:
636	                # Additional data to copy till specified args.end
637	                end_cpy = args.end
638	            else:
639	                # Additional data to copy till end of secondary file
640	                end_cpy = arr2.size - 1
641
642	    first_diff = -1
643	    last_diff = -1
644	    for ite in range(int(args.begin/args.align), int(end_cmp/args.align)+1):
645	        if not numpy.array_equal(arr1[ite], arr2[ite]):
646	            if first_diff == -1:
647	                first_diff = ite
648	                if end_cpy == -1:
649	                    last_diff = ite
650	                else:
651	                    # Additional data to copy, set last_diff to end of copy and exit loop
652	                    last_diff = int(end_cpy/args.align)
653	                    break
654	            else:
655	                last_diff = ite
656
657	    if first_diff == -1:
658	        if end_cpy == -1:
659	            sys.stderr.write("Input files are identical within comparison range ({},{})".format(args.begin, end_cmp))
660	            last_diff = -1
661	            first_diff = 0
662	        else:
663	            # No comparison differences detected, but additional data needs to be copied
664	            # Set first_diff & last_diff to first & last additional data to copy
665	            first_diff = int(arr1.size/args.align)
666	            last_diff = int(end_cpy/args.align)
667
668	    arrout = numpy.zeros((last_diff - first_diff + 1) * args.align, numpy.int8).reshape(-1, args.align)
669	    for ite in range(0, last_diff - first_diff + 1):
670	        arrout[ite] = arr2[first_diff + ite]
671
672	    # If last block concerned, remove the additional bytes appended at the beginning of the function
673	    arrout = arrout.reshape(1, -1)
674	    if ((last_diff + 1)* args.align) > arr2size :
675	        #last block is partial
676	        size = (last_diff - first_diff) * args.align + arr2size % args.align
677	    else:
678	        # all blocks are complete
679	        size = (last_diff - first_diff + 1) * args.align
680	    # keep only the useful part
681	    arrout = arrout[0,:size]
682	    # Store to outfile binary file
683	    arrout.tofile(args.outfile)
684	    # Store offset in file if specified
685	    with open(args.poffset, 'w') as f:
686	        f.write(str(first_diff*args.align))
687
688	def do_inject(args):
689	    if args.key:
690	      key = keys.load(args.key)
691	      np_key = numpy.frombuffer(key.get_key(args.type), numpy.uint8)
692	    elif args.cert:
693	      np_key = numpy.fromfile(args.cert, numpy.uint8)
694	    else:
695	      raise argparse.ArgumentTypeError("Unknown error while parsing arguments")
696	    # DEBUG_______________­_______________
697	    #print(key.get_key("public"))
698	    #l = list()
699	    #for ite in range(0, np_key.size):
700	    #  l.append(np_key[ite])
701	    #print(l)
702	    # DEBUG_______________­_______________
703	    with open(args.file, 'r') as f:
704	      with open(args.outfile, 'w') as o:
705	        for line in f.readlines():
706	          # DEBUG_______________­_______________
707	          #print(line)
708	          # DEBUG_______________­_______________
709	          if args.pattern in line:
710	            # DEBUG_______________­_______________
711	            #print("Found:{}".format(line))
712	            # DEBUG_______________­_______________
713	            if "CKA_VALUE" in line:
714	              value = "{},".format(np_key.size)
715	              for ite in range(0, int(np_key.size/4+0.75)):  # int() truncate to integer part. +0,75 so that is reman of the division exist, it will be truncated to next int value
716	                  if ite*4+3 < np_key.size:
717	                    value += " 0x{:02x}{:02x}{:02x}{:02x}U,".format(np_key[ite*4],np_key[ite*4+1],np_key[ite*4+2],np_key[ite*4+3])
718	                  elif ite*4+2 < np_key.size:
719	                    value += " 0x{:02x}{:02x}{:02x}U,".format(np_key[ite*4],np_key[ite*4+1],np_key[ite*4+2])
720	                  elif ite*4+1 < np_key.size:
721	                    value += " 0x{:02x}{:02x}U,".format(np_key[ite*4],np_key[ite*4+1])
722	                  else:
723	                    value += " 0x{:02x}U,".format(np_key[ite*4])
724	              # DEBUG_______________­_______________
725	              #print("Value:{}".format(value))
726	              # DEBUG_______________­_______________
727	              line = line.replace(args.pattern, value)
728	            elif "CKA_EC_POINT"  in line:
729	              np_key2 = numpy.zeros(np_key.size+3, numpy.uint8)
730	              for ite in range(0, np_key.size):
731	                np_key2[ite+3] = np_key[ite]
732	              np_key2[0] = 0x04;              # Octet string
733	              np_key2[1] = np_key.size + 1;   # Octet length
734	              np_key2[2] = 0x04;              # X9.62 uncompressed format
735	              value = "{},".format(np_key2.size)
736	              for ite in range(0, int(np_key2.size/4+0.75)):
737	                  if ite*4+3 < np_key2.size:
738	                    value += " 0x{:02x}{:02x}{:02x}{:02x}U,".format(np_key2[ite*4],np_key2[ite*4+1],np_key2[ite*4+2],np_key2[ite*4+3])
739	                  elif ite*4+2 < np_key2.size:
740	                    value += " 0x{:02x}{:02x}{:02x}U,".format(np_key2[ite*4],np_key2[ite*4+1],np_key2[ite*4+2])
741	                  elif ite*4+1 < np_key2.size:
742	                    value += " 0x{:02x}{:02x}U,".format(np_key2[ite*4],np_key2[ite*4+1])
743	                  else:
744	                    value += " 0x{:02x}U,".format(np_key2[ite*4])
745	              # DEBUG_______________­_______________
746	              #print("Value:{}".format(value))
747	              # DEBUG_______________­_______________
748	              line = line.replace(args.pattern, value)
749	            # DEBUG_______________­_______________
750	            #print("Altered line:{}".format(line))
751	            # DEBUG_______________­_______________
752	          o.write(line)
753	        o.close()
754
755	#    end = False
756	#    if args.end:
757	#        end = True
758	#    if args.assembly=="ARM" or args.assembly=="IAR" or args.assembly=="GNU":
759	#        if args.version=="V6M" or args.version=="V7M":
760	#          out = key.trans(args.section, args.function, end, args.assembly, args.version)
761	#          print (str(out))
762	#        else:
763	#          print ("-v option : Cortex M architecture not supported")
764	#          exit(1)
765	#    else:
766	#        print ("-a option : assembly option not supported")
767	#        exit(1)
768
769	subcmds = {
770	        'keygen': do_keygen,
771	        'trans':do_trans,
772	        'getpub': do_getpub,
773	        #sign a binary with a givent key
774	        # nonce is required for aes gcm  , if nonce not existing the file is
775	        # created
776	        # -k keyfilename -n nonce file
777	        'sign': do_sign,
778	        #hash a file with sha256 and provide result in in a file
779	        'sha256': do_sha,
780	        #return define value from crpto configuration from .h file
781	        #define to search default SECBOOT_CRYPTO_SCHEM­E, -d
782	        'conf': do_conf,
783	        #define to search , -d
784	        'extract': do_extract,
785	        #encrypt binary file with provided key
786	        # -k -n
787	        'enc': do_encrypt,
788	        # give what to put  in header and provide the key to compute hmac
789	        # magic (4 bytes) required, -m
790	        # protocol version(2 bytes) required , -p
791	        # nonce optional , -n
792	        # fwversion (required) 2 bytes, -ver
793	        # fw file (to get the size)
794	        # fw tag  (file)
795	        # reserved size
796	        # key
797	        # offset default 512
798	        'header':do_header,
799	        # give what to pack a single file header
800	        # magic (4 bytes) required, -m
801	        # protocol version(2 bytes) required , -p
802	        # nonce optional , -n
803	        # fwversion (required) 2 bytes, -ver
804	        # fw file (to get the size)
805	        # fw tag  (file)
806	        # reserved size
807	        # key
808	        # offset default 512
809	        #
810	        'pack':do_pack,
811	        #
812	        'diff':do_diff,
813	        #merge appli.elf , header binary and sbsfu elf in a big binary
814	        #input file appli.elf
815	        #-h header file
816	        #-s sbsfu.elf
817	        #output file binary to merge
818	        #-v byte pattern to fill between the different segment default 0xff
819	        #-p padding length to add to appli binary
820	        'merge':do_merge,
821	        'mergev2':do_mergev2,
822	        'diff':do_diff,
823	        #append appli.elf and header binary to an existing big binary
824	        'append':do_append,
825	        #inject key into file by replacing pattern
826	        'inject':do_inject,
827	        }
828
829	def auto_int(x):
830	    if x.startswith("0x"):
831	        return int(x,16)
832	    else:
833	        return int(x)
834
835	def args():
836	    parser = argparse.ArgumentParser()
837	    subs = parser.add_subparsers(help='subcommand help', dest='subcmd')
838	    keygenp = subs.add_parser('keygen', help='Generate pub/private keypair')
839	    keygenp.add_argument('-k', '--key', metavar='filename', required=True)
840	    keygenp.add_argument('-t', '--type', metavar='type',
841	            choices=['aes-gcm', 'ecdsa-p256','aes-cbc','aes-ctr'],
842	            required=True)
843	    trans =  subs.add_parser('trans', help='translate key to execute only code')
844	    trans.add_argument('-k', '--key', metavar='filename', required=True)
845	    trans.add_argument('-f', '--function', type=str, required = True)
846	    trans.add_argument('-s', '--section', type=str, default="")
847	    trans.add_argument('-a', '--assembly',help='fix assembly type IAR or ARM or GNU', type=str,required = False, default="IAR")
848	    trans.add_argument('-v', '--version',help='fix CORTEX M architecture', type=str,required = False, default="V7M")
849	    trans.add_argument('-e', '--end')
850
851	    getpub = subs.add_parser('getpub', help='Get public key from keypair')
852	    getpub.add_argument('-k', '--key', metavar='filename', required=True)
853
854	    sign = subs.add_parser('sign', help='Sign an image with a private key')
855	    sign.add_argument('-k', '--key', metavar='filename', required = True)
856	    sign.add_argument('-n', '--nonce', metavar='filename', required = False)
857	    sign.add_argument("infile")
858	    sign.add_argument("outfile")
859	    sha = subs.add_parser('sha256', help='hash a file with sha256')
860	    sha.add_argument("infile")
861	    sha.add_argument("outfile")
862	    sha.add_argument('-p', '--padding',type=int, required = False, default=0, help='pad to be a multiple of the given size if needed')
863	    config = subs.add_parser('conf', help='get crypto config from .h file')
864	    config.add_argument('-d', '--define', type=str, default='SECBOOT_CRYPTO_SCHEM­E')
865	    config.add_argument("infile")
866	    extract = subs.add_parser('extract', help='get value definition from text file')
867	    extract.add_argument('-d', '--define', type=str, help='defintion searched in file')
868	    extract.add_argument("infile")
869	    enc = subs.add_parser('enc', help='encrypt an image with a private key')
870	    enc.add_argument('-k', '--key', metavar='filename', required = True)
871	    enc.add_argument('-n', '--nonce', metavar='filename')
872	    enc.add_argument('-i', '--iv', metavar='filename')
873	    enc.add_argument('-a', '--address', type=auto_int, help='part of IV for AES CTR. address = Slot0_FW_Start_Addre­ss[31:4]')
874	    enc.add_argument('--poffset', help ='file that contains offset at which the partial firmware should be applied', type=str, metavar='filename')
875	    enc.add_argument("infile")
876	    enc.add_argument("outfile")
877
878	    head = subs.add_parser('header', help='build  installed header file and compute mac according to provided key')
879	    head.add_argument('-k', '--key', metavar='filename', required = True)
880	    head.add_argument('-n', '--nonce', metavar='filename')
881	    head.add_argument('-i', '--iv', metavar='filename')
882	    head.add_argument('-f', '--firmware', metavar='filename', required = True)
883	    head.add_argument('-t', '--tag', metavar='filename', required = True)
884	    head.add_argument('-v', '--version',type=int, required = True)
885	    head.add_argument('-m', '--magic',type=str, default="SFUM")
886	    head.add_argument('-p', '--protocol',type=int,  default = 0x1)
887	    head.add_argument('-r', '--reserved',type=int, default=8)
888	    head.add_argument('-o', '--offset', type=int, default = 512, required = False)
889	    head.add_argument('--cert_fw_leaf', metavar='filename', required = False)
890	    head.add_argument('--cert_fw_inter', metavar='filename', required = False)
891	    head.add_argument('--pfw', help ='partial firmware', metavar='filename', required = ('--poffset' in sys.argv) or ('--ptag' in sys.argv))
892	    head.add_argument('--poffset', help ='file that contains offset at which the partial firmware should be applied', type=str, metavar='filename', required = ('--pfw' in sys.argv) or ('--ptag' in sys.argv))
893	    head.add_argument('--ptag', metavar='filename', required = ('--pfw' in sys.argv) or ('--poffset' in sys.argv))
894	    head.add_argument("outfile")
895	    pack = subs.add_parser('pack', help='build header file and compute mac according to key provided')
896	    pack.add_argument('-k', '--key', metavar='filename', required = True)
897	    pack.add_argument('-n', '--nonce', metavar='filename')
898	    pack.add_argument('-i', '--iv', metavar='filename')
899	    pack.add_argument('-f', '--firmware', metavar='filename', required = True)
900	    pack.add_argument('-t', '--tag', metavar='filename', required = True)
901	    pack.add_argument('-v', '--version',type=int, required = True)
902	    pack.add_argument('-m', '--magic',type=str, default="SFUM")
903	    pack.add_argument('-p', '--protocol',type=int, default = 0x1)
904	    pack.add_argument('-r', '--reserved',type=int, default=8)
905	    pack.add_argument('-o', '--offset', help='offset between start of header and binary', type=int, default=512)
906	    pack.add_argument('-e', '--elf', help='elf type set to 1 for GNU, 0 for other by default', type=int, default=1)
907	    pack.add_argument('--cert_fw_leaf', metavar='filename', required = False)
908	    pack.add_argument('--cert_fw_inter', metavar='filename', required = False)
909	    pack.add_argument('--pfw', help ='partial firmware', metavar='filename', required = ('--poffset' in sys.argv) or ('--ptag' in sys.argv))
910	    pack.add_argument('--poffset', help ='file that contains offset at which the partial firmware should be applied', type=str, metavar='filename', required = ('--pfw' in sys.argv) or ('--ptag' in sys.argv))
911	    pack.add_argument('--ptag', metavar='filename', required = ('--pfw' in sys.argv) or ('--poffset' in sys.argv))
912	    pack.add_argument("outfile")
913
914	    diff = subs.add_parser('diff', help='compute differences between 2 binary files ')
915	    diff.add_argument('-1', '--file1', type=str, metavar='filename', required=True, help="first binary file to compare")
916	    diff.add_argument('-2', '--file2', type=str, metavar='filename', required=True, help="second binary file to compare")
917	    diff.add_argument('-p', '--poffset', type=str, metavar='filename', required=True, help="file that will contain offset at which the difference binary files should be applied")
918	    diff.add_argument('-b', '--begin', type=auto_int, metavar='filename', default='0x0', required=False, help="offset from which beginning comparison - in bytes (default: 0)")
919	    diff.add_argument('-e', '--end',   type=auto_int, metavar='filename', default='0x0', required=False, help="offset at which ending comparison - in bytes. use 0 to specify end of given binary files (default: 0)")
920	    diff.add_argument('-a', '--align', type=int, metavar='align', default=2, required=False, help="difference binary file alignment in bytes (default: 2)")
921	    diff.add_argument("outfile")
922
923	    mrg = subs.add_parser('merge', help='merge elf appli , install header and sbsfu.elf in a contiguous binary')
924	    mrg.add_argument('-i', '--install', metavar='filename',  help="filename of installed binary header", required = True)
925	    mrg.add_argument('-s', '--sbsfu', metavar='filename', help="filename of sbsfu elf", required = True)
926	    mrg.add_argument('-l', '--loader', metavar='filename', help="filename of loader elf", required = False)
927	    mrg.add_argument('-v', '--value', help= "byte padding pattern", required = False, type=int, default=0xff)
928	    mrg.add_argument('-p', '--padding', help='pad to add to appli binary, a multiple of the given size if needed',type=int, required = False, default=0)
929	    mrg.add_argument('-e', '--elf', help='elf type set to 1 for GNU, 0 for other by default', type=int, default=1)
930	    mrg.add_argument('-x', '--header', type=auto_int, help='Header address, when header not contiguous with FW',required = False)
931	    mrg.add_argument('-u', '--userapp', metavar='filename', help="filename of appli elf file", required = False)
932	    mrg.add_argument("outfile", help = "filename of contiguous binary")
933
934	    mrgv2 = subs.add_parser('mergev2', help='merge elf files and binaries in a contiguous binary')
935	    mrgv2.add_argument('-b', '--binaries', type=str,  help="binaries to merge files list (ex:'f1.bin@0x08004500;f1.bin@0x08006000'", required = True)
936	    mrgv2.add_argument('-f', '--files', type=str,  help="elf files to merge list (ex:'f1.elf;f2.elf'", required = False)
937	    mrgv2.add_argument('-v', '--value', help= "byte padding pattern", required = False, type=int, default=0xff)
938	    mrgv2.add_argument('-e', '--elf', help='elf type set to 1 for GNU, 0 for other by default', type=int, default=1)
939	    mrgv2.add_argument("outfile", help = "filename of contiguous binary")
940
941	    app = subs.add_parser('append', help='append elf appli and install header to an existing binary')
942	    app.add_argument('-i', '--install', metavar='filename',  help="filename of installed binary header", required = True)
943	    app.add_argument('-b', '--binary', metavar='filename', help="filename of existing binary", required = True)
944	    app.add_argument('-v', '--value', help= "byte padding pattern", required = False, type=int, default=0xff)
945	    app.add_argument('-e', '--elf', help='elf type set to 1 for GNU, 0 for other by default', type=int, default=1)
946	    app.add_argument('-x', '--header', type=auto_int, help='Header address',required = False)
947	    app.add_argument('-a', '--address', type=auto_int, help='Base address of input binary',required = False)
948	    app.add_argument('-u', '--userapp', metavar='filename', help="filename of user application elf file", required = False)
949	    app.add_argument("outfile", help = "filename of contiguous binary")
950
951	    inject =  subs.add_parser('inject', help='inject key to KMS embedded keys code')
952	    inject.add_argument('-k', '--key', metavar='filename', required=('--cert' not in sys.argv) and ('-c' not in sys.argv))
953	    inject.add_argument('-c', '--cert', metavar='filename', help = "Certificate .der file", required=('--key' not in sys.argv) and ('-k' not in sys.argv))
954	    inject.add_argument('-p', '--pattern', type=str, required=True)
955	    inject.add_argument('-f', '--file', metavar='filename', required=True)
956	    inject.add_argument('-t', '--type', type=str, default="public")
957	    inject.add_argument("outfile", help = "generated output file")
958
959	    args = parser.parse_args()
960	    if args.subcmd is None:
961	        print('Must specify a subcommand')
962	        sys.exit(1)
963	    subcmds[args.subcmd](args)
964
965	if __name__ == '__main__':
966	    args()
967
968
L476_USER_APP\Common\KeysAndImages_Util\readme.txt

=================================
Overview
=================================
The python scripts contained in this directory are used by pre and post processing scripts in the SE_CoreBin and UserApp projects.

1) These scripts will generate the appropriate .s files implementing the functions declared in se_key.h.
2) They are also used by the post-processing script to  generate the FW image and header files (.sfu and .sfuh) and the single binary file (header + FW image).

To use these scripts you need to make sure you have installed the appropriate python modules listed in "requirements.txt":
> pip install -r requirements.txt

Please note that you do not need to call these scripts manually as they are integrated in the IDE.
They will be called as pre and post build scripts when building the projects with your IDE.


=================================
'prepareimage.py' functionalities
=================================
The 'prepareimage.py' script is the main item of this folder.
This script can be used to perform 5 types of operations:

* generate some keys ('keygen' command):
      ** symmetric key for Firmware encryption (AES CBC or AES GCM) and authentication when AES GCM is used.
      ** asymmetric keys for authentication when ECDSA is used.

* generate the ARM assembler code to load the keys from FLASH into RAM
      This is the 'trans' command.
      It generates the .s file to build in the context of the SE_CoreBin project.

* encrypt the firmware image ('enc' command)
      This is a symmetric encryption: AES CBC or AES GCM.

* generate the tag to authenticate the firmware ('sign' command or 'sha256' command)
      ** When AES GCM is used for authentication, this is the "sign" command: generates the FW tag.
      ** When SHA256 with ECDSA is used for authentication, this is the "sha256" command: generates the sha256 digest

* generate the Firmware header (metadata) and the single binary file to be downloaded (header+ clear or encrypted firmware )
      This is the 'pack' command.

* generate partial update clear binary from old & new clear binaries
      This is the 'diff' command.

=================================
Some examples
=================================

Example for AES-CBC:
--------------------
[1] Generate the keys - OPTION
python prepareimage.py keygen -k AES_CBC.bin -t aes-cbc
=> for aes_cbc , "AES_CBC"  must be in file name else key is not created, this
is used to discriminate AES_GCM key versus AES_CBC key
python prepareimage.py  keygen  -k ECCKEY.txt -t ecdsa-p256

This step is not mandatory but if you do so, please make sure:
* to copy the content of  ECCKEY.txt in SECoreBin\Binary
* to use AES_CBC.bin instead of OEM_KEY_COMPANY1_key.bin
Then the prebuild operations (SE_CoreBin) must be performed.

[2] Encrypt the image
python prepareimage.py  enc -k AES_CBC.bin -i iv.bin UserApp.bin UserApp.sfu

[3] Generate the clear FW tag (SHA256 of the clear FW)
python prepareimage.py sha256  UserApp.bin  UserApp.sign

[4] Generate the .sfb FW metadata (header) and encrypted binary
python prepareimage.py  pack -k ECCKEY.txt -r 28 -p 1 -v 2 -i iv.bin -f UserApp.sfu -t UserApp.sign UserApp.sfb
(Please note the use of -r 28 to have a FW header length of 192 bytes. This is needed to match the FLASH constraint.)

The step 1 is optional, the steps 2,3 and 4 are handled by the post-build scripts already integrated in the IAR IDE.

Example for AES-GCM :
---------------------
[1] Generate the keys - OPTION
python prepareimage.py keygen -k OEM_KEY_COMPANY1_key.bin  -t aes-gcm

This step is not mandatory but if you do so, please make sure:
* to copy the content OEM_KEY_COMPANY1_key.bin  in SECoreBin\Binary
Then the prebuild operations (SE_CoreBin) must be performed.

[2] Encrypt the image
python prepareimage.py  enc -k OEM_KEY_COMPANY1_key.bin -n nonce.bin UserApp.bin UserApp.sfu

[3] Generate the clear FW tag with AES-GCM
python prepareimage.py sign -k OEM_KEY_COMPANY1_key.bin -n nonce.bin UserApp.bin  UserApp.sign

[4] Generate the .sfb FW metadata (header) and encrypted binary
python prepareimage.py  pack -k OEM_KEY_COMPANY1_key.bin  -r 28 -p 1 -v 2 -n nonce.bin -f UserApp.sfu -t UserApp.sign UserApp.sfb
(Please note the use of -r 28 to have a FW header length of 192 bytes. This is needed to match the FLASH constraint.)

The step 1 is optional, the steps 2,3 and 4 are handled by the post-build scripts already integrated in the IAR IDE.

Example for partial update :
----------------------------

[0] Generate partial image
python prepareimage.py  diff -1 UserApp_v1.bin -2 UserApp_v2.bin UserApp_partial.bin -a 16 --poffset UserApp_partial.offset
(-a 16: align partial binary on 16 bytes. Partial binary size will also be aligned on 16 bytes)

[1] Generate the keys - OPTION
python prepareimage.py keygen -k AES_CBC.bin -t aes-cbc
=> for aes_cbc , "AES_CBC"  must be in file name else key is not created, this
is used to discriminate AES_GCM key versus AES_CBC key
python prepareimage.py  keygen  -k ECCKEY.txt -t ecdsa-p256

This step is not mandatory but if you do so, please make sure:
* to copy the content of  ECCKEY.txt in SECoreBin\Binary
* to use AES_CBC.bin instead of OEM_KEY_COMPANY1_key.bin
Then the prebuild operations (SE_CoreBin) must be performed.

[2] Encrypt the complete image
python prepareimage.py  enc -k AES_CBC.bin -i iv.bin UserApp_v2.bin UserApp_v2.sfu

[3] Encrypt the partial image
python prepareimage.py  enc -k AES_CBC.bin -i iv.bin UserApp_partial.bin UserApp_partial.sfu

[4] Generate the clear complete FW tag (SHA256 of the clear FW)
python prepareimage.py sha256  UserApp_v2.bin  UserApp_v2.sign

[5] Generate the clear partial FW tag (SHA256 of the clear FW)
python prepareimage.py sha256  UserApp_partial.bin  UserApp_partial.sign

[6] Generate the .sfb FW metadata (header) and encrypted partial binary
python prepareimage.py  pack -k ECCKEY.txt -r 28 -p 1 -v 2 -i iv.bin -f UserApp_v2.sfu -t UserApp_v2.sign --pfw UserApp_partial.sfu --ptag UserApp_partial.sign --poffset UserApp_partial.offset UserApp_partial.sfb
(Please note the use of -r 28 to have a FW header length of 192 bytes. This is needed to match the FLASH constraint.)

=================================
Windows executable(s)
=================================
Two windows executables are provided:
(a) Firmware/Middlewares/ST/STM32_Secure_Engine/Utilities/KeysAndImages/win/prepareimage.exe
    ==> this file contains all the required element to run but is slower at execution time.

(b) Firmware/Middlewares/ST/STM32_Secure_Engine/Utilities/KeysAndImages/win/prepareimage/prepareimage.exe
    ==> this file requires additional items (provided in its sub-folder) but is faster at execution time.

By default, the scripts use (b).

=================================
Rebuilding windows executable
=================================
It is also possible to generate windows executables to avoid using the python scripts directly.

This requires some additional Python libraries and tools:
>pip install pyinstaller

Follow method (a) or (b).
Method (a) produces a single file while method (b) provides a folder (execution can be faster).

(a) Building in "one file" mode:
>pyinstaller --onefile prepareimage.py
>cp -p dist/prepareimage.exe win/

OR

(b) Building in "onefolder" mode:
>pyinstaller --clean --onedir prepareimage.py
Then copy the folder "Firmware/Middlewares/ST/STM32_Secure_Engine/Utilities/KeysAndImages/dist/prepareimage"
in "Firmware/Middlewares/ST/STM32_Secure_Engine/Utilities/KeysAndImages/win"

Then decide if you want to use:
(a) Firmware/Middlewares/ST/STM32_Secure_Engine/Utilities/KeysAndImages/win/prepareimage.exe
or
(b) Firmware/Middlewares/ST/STM32_Secure_Engine/Utilities/KeysAndImages/win/prepareimage/prepareimage.exe
and update the scripts accordingly.

L476_USER_APP\Common\KeysAndImages_Util\requirements.txt

pycryptodome
pycryptodomex
ecdsa
pyelftools
numpy

L476_USER_APP\Common\KeysAndImages_Util\translate_key.py
1	# Copyright(c) 2018 STMicroelectronics International N.V.
2	#
3	# Licensed under the Apache License, Version 2.0 (the "License");
4	# you may not use this file except in compliance with the License.
5	# You may obtain a copy of the License at
6	#
7	#     http://www.apache.org/licenses/LICENSE-2.0
8	#
9	# Unless required by applicable law or agreed to in writing, software
10	# distributed under the License is distributed on an "AS IS" BASIS,
11	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12	# See the License for the specific language governing permissions and
13	# limitations under the License.
14	import os
15	from array import array
16	#generating execute only code function for ARMV7M
17	#based on :
18	# 0xABCD
19	#    MOVW Rn, #0xBA
20	#    MOVT Rn  #0xCD
21	# AREA KEY, CODE
22	# EXPORT ReadKey
23	# 16 bytes AEG_GCM key
24	#PUSH {R4, R7}
25	# 32 bytes (pub_x, pub_y)
26	#PUSH {R4, R11}
27	def build_mov(reg, val, version):
28	    if version == "V7M":
29	        #build the 2 16bits to write
30	        out ="\tMOVW R"+str(reg)+", #"+hex(val[1]*256+val[0])+"\n"
31	        out +="\tMOVT R"+str(reg)+", #"+hex(val[3]*256+val[2])+"\n"
32	    elif version == "V6M":
33	        #build the 8 8bits to write
34	        out ="\tMOVS R"+str(reg)+", #"+hex(val[3])+"\n"
35	        out +="\tLSLS R"+str(reg)+", R"+str(reg)+", #24\n"
36	        out +="\tMOVS R5, #"+hex(val[2])+"\n"
37	        out +="\tLSLS R5, R5, #16\n"
38	        out +="\tADD R"+str(reg)+", R"+str(reg)+", R5\n"
39	        out +="\tMOVS R5, #"+hex(val[1])+"\n"
40	        out +="\tLSLS R5, R5, #8\n"
41	        out +="\tADD R"+str(reg)+", R"+str(reg)+", R5\n"
42	        out +="\tMOVS R5, #"+hex(val[0])+"\n"
43	        out +="\tADD R"+str(reg)+", R"+str(reg)+", R5\n"
44	    else:
45	        exit(1)
46	    return out
47
48	def translate(key, end=False, assembly="IAR", version="V7M"):
49	    if version == "V7M":
50	        STMR0 = "\tSTM R0"
51	        ADDR0 = "\tADD R0"
52	    elif version == "V6M":
53	        STMR0 = "\tSTM R0!"
54	    else:
55	        exit(1)
56
57	    key=bytearray(key)
58	    if len(key) <= 16:
59	        endreg = int((len(key)+3)/4)
60	        loop = 1
61	    elif len(key) == 32:
62	        endreg = int(4)
63	        loop = 2
64	    elif len(key) == 64:
65	        endreg = int(4)
66	        loop = 4
67	    else:
68	        return ""
69	    output = "\tPUSH {R1-R5}\n"
70	    for j in range(0,loop):
71	        if j!=0:
72	            output+= STMR0 +", {R1-R"+str(endreg)+"}\n"
73	            if version == "V7M":
74	                output+= ADDR0 +", R0,#16\n"
75	        for i in range(0,endreg):
76	            output+=build_mov(i+1, key[16*j+i*4:16*j+i*4+4], version)
77	    output += STMR0 + ", {R1-R"+str(endreg)+"}\n"
78	    output += "\tPOP {R1-R5}\n"
79	    output += "\tBX LR\n"
80	    if end:
81	        if assembly == "GNU":
82	            output +="\t.end"
83	        else:
84	            output +="\tEND"
85	    return output
86
87	def function(section, name, assembly="IAR" ):
88	    if assembly == "IAR":
89	      section_name="section "
90	      separator=":CODE\n"
91	    elif assembly == "ARM":
92	      section_name="AREA |"
93	      separator="|, CODE\n"
94	    elif assembly == "GNU":
95	      section_name=".section "
96	      separator=""","a",%progbits\n .syntax unified \n .thumb \n
97	      """
98	    else:
99	      exit(1)
100	    if section !="":
101	        out = "\t"+str(section_name)+str(section)+str(separator)
102	    else:
103	        out=""
104	    if assembly == "GNU":
105	        out += "\t.global "+str(name)+"\n"
106	        out += str(name)+":\n"
107	    else:
108	        out += "\tEXPORT "+str(name)+"\n"
109	        out += str(name)+"\n"
110	    return out
111	if __name__ == '__main__':
112	    assembly = "GNU"
113	    outcode = function(".SE_Key_Data", "SE_ReadKey")
114	    #key = os.urandom(32)
115	    key="OEM_KEY_COMPANY1".encode()
116	    outcode +=translate(key, version="V6M")
117	    key = bytearray([0xce, 0x40, 0x14, 0xc6, 0x88, 0x11, 0xf9, 0xa2, 0x1a, 0x1f, 0xdb, 0x2c, 0x0e,
118	    0x61, 0x13, 0xe0, 0x6d, 0xb7, 0xca, 0x93, 0xb7, 0x40, 0x4e, 0x78, 0xdc, 0x7c,
119	    0xcd, 0x5c, 0xa8, 0x9a, 0x4c, 0xa9])
120	    outcode += function("", "SE_ReadKey_PubY")
121	    outcode += translate(key, version="V6M")
122	    outcode += function("", "SE_ReadKey_PubX")
123	    key = bytearray([ 0x1c, 0xcb, 0xe9, 0x1c, 0x07, 0x5f, 0xc7, 0xf4, 0xf0, 0x33, 0xbf, 0xa2, 0x48,
124	    0xdb, 0x8f, 0xcc, 0xd3, 0x56, 0x5d, 0xe9, 0x4b, 0xbf, 0xb1, 0x2f, 0x3c, 0x59,
125	    0xff, 0x46, 0xc2, 0x71, 0xbf, 0x83])
126
127	    outcode +=translate(key,version="V6M")
128	    if assembly == "GNU":
129	      outcode +="\t.end"
130	    else:
131	      outcode +="\tEND"
132	    print(outcode)
133	#bytearray([0x13, 0x00, 0x00, 0x00, 0x08, 0x00])
134	#key = bytearray([0xaa, 0xbb, 0xcc, 0xdd])
135	    print(str(key))
136
137
138
139
L476_USER_APP\Common\Linker\mapping_export.h
1	/**
2	  ******************************************************************************
3	  * @file    mapping_export.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains the definitions exported from mapping linker files.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef MAPPING_EXPORT_H
21	#define MAPPING_EXPORT_H
22
23	#ifdef __cplusplus
24	extern "C" {
25	#endif
26
27	/** @addtogroup SFU Secure Boot / Secure Firmware Update
28	  * @{
29	  */
30
31	/** @addtogroup SFU_CORE SBSFU Application
32	  * @{
33	  */
34
35	/** @addtogroup SFU_APP SFU Application Configuration
36	  * @{
37	  */
38
39	/** @defgroup SFU_APP_Exported_Typ­es Exported Types
40	  * @{
41	  */
42	/** @defgroup SFU_CONFIG_SBSFU_MEM­ORY_MAPPING SBSFU Memory Mapping
43	  * @{
44	  */
45	#if defined (__ICCARM__) || defined(__GNUC__)
46	extern uint32_t __ICFEDIT_intvec_sta­rt__;
47	#define INTVECT_START ((uint32_t)& __ICFEDIT_intvec_sta­rt__)
48	extern uint32_t __ICFEDIT_SE_Startup­_region_ROM_start__;
49	#define SE_STARTUP_REGION_RO­M_START ((uint32_t)& __ICFEDIT_SE_Startup­_region_ROM_start__)
50	extern uint32_t __ICFEDIT_SE_Code_re­gion_ROM_start__;
51	#define SE_CODE_REGION_ROM_S­TART ((uint32_t)& __ICFEDIT_SE_Code_re­gion_ROM_start__)
52	extern uint32_t __ICFEDIT_SE_Code_re­gion_ROM_end__;
53	#define SE_CODE_REGION_ROM_E­ND ((uint32_t)& __ICFEDIT_SE_Code_re­gion_ROM_end__)
54	extern uint32_t __ICFEDIT_SE_IF_regi­on_ROM_start__;
55	#define SE_IF_REGION_ROM_STA­RT ((uint32_t)& __ICFEDIT_SE_IF_regi­on_ROM_start__)
56	extern uint32_t __ICFEDIT_SE_IF_regi­on_ROM_end__;
57	#define SE_IF_REGION_ROM_END­ ((uint32_t)& __ICFEDIT_SE_IF_regi­on_ROM_end__)
58	extern uint32_t __ICFEDIT_SE_Key_reg­ion_ROM_start__;
59	#define SE_KEY_REGION_ROM_ST­ART ((uint32_t)& __ICFEDIT_SE_Key_reg­ion_ROM_start__)
60	extern uint32_t __ICFEDIT_SE_Key_reg­ion_ROM_end__;
61	#define SE_KEY_REGION_ROM_EN­D ((uint32_t)& __ICFEDIT_SE_Key_reg­ion_ROM_end__)
62	extern uint32_t __ICFEDIT_SE_CallGat­e_region_ROM_start__­;
63	#define SE_CALLGATE_REGION_R­OM_START ((uint32_t)& __ICFEDIT_SE_CallGat­e_region_ROM_start__­)
64	extern uint32_t __ICFEDIT_SB_region_­ROM_start__;
65	#define SB_REGION_ROM_START ((uint32_t)& __ICFEDIT_SB_region_­ROM_start__)
66	extern uint32_t __ICFEDIT_SB_region_­ROM_end__;
67	#define SB_REGION_ROM_END ((uint32_t)& __ICFEDIT_SB_region_­ROM_end__)
68	extern uint32_t __ICFEDIT_SE_region_­RAM_start__;
69	#define SE_REGION_RAM_START ((uint32_t)& __ICFEDIT_SE_region_­RAM_start__)
70	extern uint32_t __ICFEDIT_SE_region_­RAM_end__ ;
71	#define SE_REGION_RAM_END ((uint32_t)& __ICFEDIT_SE_region_­RAM_end__)
72	extern uint32_t __ICFEDIT_SB_region_­RAM_start__ ;
73	#define SB_REGION_RAM_START ((uint32_t)& __ICFEDIT_SB_region_­RAM_start__)
74	extern uint32_t __ICFEDIT_SB_region_­RAM_end__ ;
75	#define SB_REGION_RAM_END ((uint32_t)& __ICFEDIT_SB_region_­RAM_end__)
76	extern uint32_t __ICFEDIT_SE_region_­RAM_stack_top__;
77	#define SE_REGION_RAM_STACK_­TOP ((uint32_t)& __ICFEDIT_SE_region_­RAM_stack_top__)
78	#elif defined(__CC_ARM)
79	extern uint32_t Image$$vector_start$$Base;
80	#define  INTVECT_START ((uint32_t)& Image$$vector_start$$Base)
81	#endif
82
83
84	/**
85	  * @}
86	  */
87
88	/** @defgroup SFU_CONFIG_FW_MEMORY­_MAPPING Firmware Slots Memory Mapping
89	  * @{
90	  */
91	#if defined (__ICCARM__) || defined(__GNUC__)
92	extern uint32_t __ICFEDIT_SLOT_Activ­e_1_header__;
93	#define SLOT_ACTIVE_1_HEADER­ ((uint32_t)& __ICFEDIT_SLOT_Activ­e_1_header__)
94	extern uint32_t __ICFEDIT_SLOT_Activ­e_1_start__;
95	#define SLOT_ACTIVE_1_START ((uint32_t)& __ICFEDIT_SLOT_Activ­e_1_start__)
96	extern uint32_t __ICFEDIT_SLOT_Activ­e_1_end__;
97	#define SLOT_ACTIVE_1_END ((uint32_t)& __ICFEDIT_SLOT_Activ­e_1_end__)
98	extern uint32_t __ICFEDIT_SLOT_Activ­e_2_header__;
99	#define SLOT_ACTIVE_2_HEADER­ ((uint32_t)& __ICFEDIT_SLOT_Activ­e_2_header__)
100	extern uint32_t __ICFEDIT_SLOT_Activ­e_2_start__;
101	#define SLOT_ACTIVE_2_START ((uint32_t)& __ICFEDIT_SLOT_Activ­e_2_start__)
102	extern uint32_t __ICFEDIT_SLOT_Activ­e_2_end__;
103	#define SLOT_ACTIVE_2_END ((uint32_t)& __ICFEDIT_SLOT_Activ­e_2_end__)
104	extern uint32_t __ICFEDIT_SLOT_Activ­e_3_header__;
105	#define SLOT_ACTIVE_3_HEADER­ ((uint32_t)& __ICFEDIT_SLOT_Activ­e_3_header__)
106	extern uint32_t __ICFEDIT_SLOT_Activ­e_3_start__;
107	#define SLOT_ACTIVE_3_START ((uint32_t)& __ICFEDIT_SLOT_Activ­e_3_start__)
108	extern uint32_t __ICFEDIT_SLOT_Activ­e_3_end__;
109	#define SLOT_ACTIVE_3_END ((uint32_t)& __ICFEDIT_SLOT_Activ­e_3_end__)
110	extern uint32_t __ICFEDIT_SLOT_Dwl_1­_start__;
111	#define SLOT_DWL_1_START ((uint32_t)& __ICFEDIT_SLOT_Dwl_1­_start__)
112	extern uint32_t __ICFEDIT_SLOT_Dwl_1­_end__;
113	#define SLOT_DWL_1_END ((uint32_t)& __ICFEDIT_SLOT_Dwl_1­_end__)
114	extern uint32_t __ICFEDIT_SLOT_Dwl_2­_start__;
115	#define SLOT_DWL_2_START ((uint32_t)& __ICFEDIT_SLOT_Dwl_2­_start__)
116	extern uint32_t __ICFEDIT_SLOT_Dwl_2­_end__;
117	#define SLOT_DWL_2_END ((uint32_t)& __ICFEDIT_SLOT_Dwl_2­_end__)
118	extern uint32_t __ICFEDIT_SLOT_Dwl_3­_start__;
119	#define SLOT_DWL_3_START ((uint32_t)& __ICFEDIT_SLOT_Dwl_3­_start__)
120	extern uint32_t __ICFEDIT_SLOT_Dwl_3­_end__;
121	#define SLOT_DWL_3_END ((uint32_t)& __ICFEDIT_SLOT_Dwl_3­_end__)
122	extern uint32_t __ICFEDIT_SWAP_start­__;
123	#define SWAP_START ((uint32_t)& __ICFEDIT_SWAP_start­__)
124	extern uint32_t __ICFEDIT_SWAP_end__­;
125	#define SWAP_END ((uint32_t)& __ICFEDIT_SWAP_end__­)
126	#endif
127
128	/**
129	  * @}
130	  */
131	/**
132	  * @}
133	  */
134
135	/**
136	  * @}
137	  */
138
139	/**
140	  * @}
141	  */
142
143	#ifdef __cplusplus
144	}
145	#endif
146
147	#endif /* MAPPING_EXPORT_H */
148
149
L476_USER_APP\Common\Linker\mapping_fwimg.ld

/*
*****************************************************************************
**
**  File        : LinkerScript.ld
**
**  Abstract    : Linker script for STM32L476RGTx Device with
**                1024KByte FLASH, 96KByte RAM
**
**                Set heap size, stack size and stack location according
**                to application requirements.
**
**                Set memory bank area and size if external memory is used.
**
**  Target      : STMicroelectronics STM32
**
**
**  Distribution: The file is distributed as is, without any warranty
**                of any kind.
**
**  (c)Copyright Ac6.
**  You may use this file as-is or modify it according to the needs of your
**  project. Distribution of this file (unmodified or modified) is not
**  permitted. Ac6 permit registered System Workbench for MCU users the
**  rights to distribute the assembled, compiled & linked contents of this
**  file as part of an application binary file, provided that it is built
**  using the System Workbench for MCU toolchain.
**
*****************************************************************************
*/

/* Slots must be aligned on 2048 bytes (0x800) */

/* swap (8 kbytes) */
__ICFEDIT_SWAP_start__           = 0x080F0000;
__ICFEDIT_SWAP_end__             = 0x080F1FFF;

/* Active slot #1 (424 kbytes) */
__ICFEDIT_SLOT_Active_1_start__  = 0x08086000;
__ICFEDIT_SLOT_Active_1_end__    = 0x080EFFFF;
__ICFEDIT_SLOT_Active_1_header__ = __ICFEDIT_SLOT_Active_1_start__;

/* Dwl slot #1 (424 kbytes) */
__ICFEDIT_SLOT_Dwl_1_start__     = 0x08010000;
__ICFEDIT_SLOT_Dwl_1_end__       = 0x08079fff;


/* Slots not configured */
__ICFEDIT_SLOT_Active_2_header__ = 0x00000000;
__ICFEDIT_SLOT_Active_2_start__  = 0x00000000;
__ICFEDIT_SLOT_Active_2_end__    = 0x00000000;
__ICFEDIT_SLOT_Active_3_header__ = 0x00000000;
__ICFEDIT_SLOT_Active_3_start__  = 0x00000000;
__ICFEDIT_SLOT_Active_3_end__    = 0x00000000;
__ICFEDIT_SLOT_Dwl_2_start__     = 0x00000000;
__ICFEDIT_SLOT_Dwl_2_end__       = 0x00000000;
__ICFEDIT_SLOT_Dwl_3_start__     = 0x00000000;
__ICFEDIT_SLOT_Dwl_3_end__       = 0x00000000;

L476_USER_APP\Common\Linker\mapping_sbsfu.ld

/*
*****************************************************************************
**
**  File        : LinkerScript.ld
**
**  Abstract    : Linker script for STM32L476RGTx Device with
**                1024KByte FLASH, 96KByte RAM
**
**                Set heap size, stack size and stack location according
**                to application requirements.
**
**                Set memory bank area and size if external memory is used.
**
**  Target      : STMicroelectronics STM32
**
**
**  Distribution: The file is distributed as is, without any warranty
**                of any kind.
**
**  (c)Copyright Ac6.
**  You may use this file as-is or modify it according to the needs of your
**  project. Distribution of this file (unmodified or modified) is not
**  permitted. Ac6 permit registered System Workbench for MCU users the
**  rights to distribute the assembled, compiled & linked contents of this
**  file as part of an application binary file, provided that it is built
**  using the System Workbench for MCU toolchain.
**
*****************************************************************************
*/

/* SE Code region protected by firewall */
VECTOR_SIZE = 0x200;
__ICFEDIT_SE_Code_region_ROM_start__       = 0x08000000 + VECTOR_SIZE;
__ICFEDIT_SE_CallGate_region_ROM_start__   = __ICFEDIT_SE_Code_region_ROM_start__;  /* No need to do +4 as we have dummy bytes in SE_CoreBin .ld file */
__ICFEDIT_SE_CallGate_region_ROM_end__     = __ICFEDIT_SE_Code_region_ROM_start__ + 0x1FF;

/* SE key region protected by firewall */
__ICFEDIT_SE_Key_region_ROM_start__        = __ICFEDIT_SE_CallGate_region_ROM_end__ + 0x1;
__ICFEDIT_SE_Key_region_ROM_end__          = __ICFEDIT_SE_Key_region_ROM_start__ + 0xFF;

/* SE Startup: call before enabling firewall*/
__ICFEDIT_SE_Startup_region_ROM_start__    = __ICFEDIT_SE_Key_region_ROM_end__ + 0x1;
__ICFEDIT_SE_Code_nokey_region_ROM_start__ = __ICFEDIT_SE_Startup_region_ROM_start__ + 0x100;
__ICFEDIT_SE_Code_region_ROM_end__         = __ICFEDIT_SE_Startup_region_ROM_start__ + 0x4FFF;

/* SE IF ROM: used to locate Secure Engine interface code out of firewall */
__ICFEDIT_SE_IF_region_ROM_start__         = __ICFEDIT_SE_Code_region_ROM_end__ + 1;
__ICFEDIT_SE_IF_region_ROM_end__           = __ICFEDIT_SE_IF_region_ROM_start__ + 0x5FF;

/* SBSFU Code region */
__ICFEDIT_SB_region_ROM_start__            = __ICFEDIT_SE_IF_region_ROM_end__ + 0x1;
__ICFEDIT_SB_region_ROM_end__              = 0x0800FFFF;

SE_Entry_Secure_ROM_Region_Length = __ICFEDIT_SE_CallGate_region_ROM_end__ - __ICFEDIT_SE_CallGate_region_ROM_start__ + 1;
SE_Key_region_ROM_Length          = __ICFEDIT_SE_Key_region_ROM_end__ - __ICFEDIT_SE_Key_region_ROM_start__ + 1;
SE_Startup_region_ROM_Length      = __ICFEDIT_SE_Code_nokey_region_ROM_start__ - __ICFEDIT_SE_Startup_region_ROM_start__ ;
SE_ROM_region_Length              = __ICFEDIT_SE_Code_region_ROM_end__ - __ICFEDIT_SE_Code_nokey_region_ROM_start__ + 1;
SE_IF_region_ROM_Length           = __ICFEDIT_SE_IF_region_ROM_end__ - __ICFEDIT_SE_IF_region_ROM_start__ + 1;
SB_ROM_region_Length              = __ICFEDIT_SB_region_ROM_end__ - __ICFEDIT_SB_region_ROM_start__ + 1;

/* RAM section */
/* SE RAM1 region protected by firewall */
/* SE stack is placed 1st in RAM, stack overflow does not write on other RAM area */
__ICFEDIT_SE_region_RAM_start__     = 0x20000000;
__ICFEDIT_SE_region_RAM_stack_top__ = 0x20000400;
__ICFEDIT_SE_region_RAM_end__       = 0x20000FFF;

/* SBSFU RAM1 region */
__ICFEDIT_SB_region_RAM_start__     = __ICFEDIT_SE_region_RAM_end__ + 1;
__ICFEDIT_SB_region_RAM_end__       = 0x20017FFF;

SE_RAM_region_Length = __ICFEDIT_SE_region_RAM_end__ - __ICFEDIT_SE_region_RAM_stack_top__ + 1;
SB_RAM_region_Length = __ICFEDIT_SB_region_RAM_end__ - __ICFEDIT_SB_region_RAM_start__ + 1;

MEMORY
{
 SE_Entry_Secure_ROM_Region (rx)     : ORIGIN = __ICFEDIT_SE_CallGate_region_ROM_start__, LENGTH = SE_Entry_Secure_ROM_Region_Length
 SE_Key_region_ROM (rx)              : ORIGIN = __ICFEDIT_SE_Key_region_ROM_start__, LENGTH = SE_Key_region_ROM_Length
 SE_Startup_region_ROM (rx)          : ORIGIN = __ICFEDIT_SE_Startup_region_ROM_start__, LENGTH = SE_Startup_region_ROM_Length
 SE_ROM_region (rx)                  : ORIGIN = __ICFEDIT_SE_Code_nokey_region_ROM_start__, LENGTH = SE_ROM_region_Length
 SE_IF_region_ROM (rx)               : ORIGIN = __ICFEDIT_SE_IF_region_ROM_start__, LENGTH = SE_IF_region_ROM_Length
 SB_ROM_region (rx)                  : ORIGIN = __ICFEDIT_SB_region_ROM_start__, LENGTH = SB_ROM_region_Length
 SE_RAM_region (xrw)               : ORIGIN = __ICFEDIT_SE_region_RAM_stack_top__, LENGTH = SE_RAM_region_Length
 SB_RAM_region (xrw)               : ORIGIN = __ICFEDIT_SB_region_RAM_start__, LENGTH = SB_RAM_region_Length
}


L476_USER_APP\Common\Linker\se_interface_app.ld

SE_APP_GetActiveFwInfo = 0x08005500;

L476_USER_APP\Common\Scripts\postbuild.sh
1	#!/bin/bash -
2	set -euo pipefail
3
4	# --- Debug Configuration ---
5	# Set to 1 to enable detailed variable logging, 0 to disable for release.
6	DEBUG=1
7
8	# --- Helper Functions ---
9	# A logging function that prints messages only when DEBUG is enabled.
10	# It includes the script name and line number for easy tracing.
11	log_info() {
12	  if [[ "${DEBUG:-0}" -eq 1 ]]; then
13	    # Use >&2 to print to stderr, so it doesn't pollute stdout or log files
14	    echo "[${0##*/}:${BASH_LINENO[0]}] $1" >&2
15	  fi
16	}
17
18	# --- Argument Parsing ---
19	# arg1: build directory (e.g., .../UserApp/Debug)
20	# arg2: elf file path+name
21	# arg3: bin file path+name
22	# arg4: firmware Id (1/2/3)
23	# arg5: version
24	# arg6: (optional) forces "bigelf" generation
25
26	if [[ $# -lt 5 ]]; then
27	  echo "Usage: $0 <build_dir> <elf_file> <bin_file> <fw_id> <version> [bigelf_flag]"
28	  exit 1
29	fi
30
31	# --- Path and Variable Initialization ---
32	log_info "--- Initializing Paths and Variables ---"
33
34	# # Get absolute paths for script arguments to handle spaces and relative paths
35	# projectdir=$(cd "$1" && pwd)
36	# log_info "projectdir=${projectdir}"
37
38	# elf_file=$(cd "$(dirname "$2")" && pwd)/$(basename "$2")
39	# log_info "elf_file=${elf_file}"
40
41	# bin_file=$(cd "$(dirname "$3")" && pwd)/$(basename "$3")
42	# log_info "bin_file=${bin_file}"
43
44	# fwid=$4
45	# log_info "fwid=${fwid}"
46
47	# version=$5
48	# log_info "version=${version}"
49
50	# # Derive other paths from the initial, absolute ones
51	# FileName=${bin_file##*/}
52	# execname=${FileName%.*}
53	# log_info "execname=${execname}"
54
55	# # This is the key: find the Common directory relative to this script's location
56	# script_dir=$(cd "$(dirname "$0")" && pwd)
57	# Common_dir=$(cd "${script_dir}/.." && pwd)
58	# log_info "Common_dir=${Common_dir}"
59
60	# # The output directory for generated binaries (e.g., .sfb, .sfu)
61	# userAppBinary_dir="${projectdir}/../Binary"
62	# log_info "userAppBinary_dir=${userAppBinary_dir}"
63
64	# # --- Toolchain and Key Paths ---
65	# log_info "--- Locating Tools and Keys ---"
66
67	# prepareimage_util_di­r="${Common_dir}/KeysAndImages_Util"
68	# log_info "prepareimage_util_di­r=${prepareimage_util_di­r}"
69
70	# nonce="${Common_dir}/Binary_Keys/nonce.bin"
71	# log_info "nonce=${nonce}"
72
73	# oemkey="${Common_dir}/Binary_Keys/OEM_KEY_COMPANY${fwid}_key_AES_GCM.bin"
74	# log_info "oemkey=${oemkey}"
75
76	# # This path needs to be configured to point to the BFU (SBSFU) project's output ELF
77	# # For now, this is a placeholder. You might need to pass it as an argument
78	# # or define it in your IDE's build variables.
79	# sbsfuelf_placeholder­="${Common_dir}/../L476_SBSFU/BFU/Debug/BFU.elf" #<-- IMPORTANT: VERIFY THIS PATH
80	# log_info "sbsfuelf_placeholder­=${sbsfuelf_placeholder­}"
81
82	# # --- Generated File Paths ---
83	# log_info "--- Defining Output File Paths ---"
84	# sfu="${userAppBinary_dir}/${execname}.sfu"
85	# sfb="${userAppBinary_dir}/${execname}.sfb"
86	# sign="${userAppBinary_dir}/${execname}.sign"
87	# headerbin="${userAppBinary_dir}/${execname}sfuh.bin"
88	# bigbinary="${userAppBinary_dir}/SBSFU_${execname}.bin"
89	# elfbackup="${userAppBinary_dir}/SBSFU_${execname}.elf"
90
91	# # --- Static Configuration ---
92	# magic="SFU${fwid}"
93	# offset=512
94	# alignment=16
95
96	# # --- Tool Selection (prepareimage) ---
97	# log_info "--- Selecting prepareimage tool ---"
98
99	# uname | grep -i -e windows -e mingw >/dev/null 2>&1
100	# if [[ $? -eq 0 && -f "${prepareimage_util_di­r}/win/prepareimage/prepareimage.exe" ]]; then
101	#   log_info "Using Windows executable: prepareimage.exe"
102	#   prepareimage_cmd="${prepareimage_util_di­r}/win/prepareimage/prepareimage.exe"
103	# else
104	#   log_info "Using Python script: prepareimage.py"
105	#   # Determine python command
106	#   py_cmd="python"
107	#   if ! command -v python &> /dev/null && command -v python3 &> /dev/null; then
108	#       py_cmd="python3"
109	#   fi
110	#   prepareimage_cmd="${py_cmd} ${prepareimage_util_di­r}/prepareimage.py"
111	# fi
112	# log_info "prepareimage_cmd=${prepareimage_cmd}"
113
114	# # --- Main Logic ---
115	# log_info "--- Starting Image Processing ---"
116
117	# # Create output directory if it doesn't exist
118	# mkdir -p "${userAppBinary_dir}"
119
120	# output_log="${projectdir}/output.txt"
121	# echo "Post-build script started at $(date)" > "${output_log}"
122
123	# last_command=""
124
125	# run_command() {
126	#   last_command="$*"
127	#   log_info "Executing: ${last_command}"
128	#   eval "${last_command}" >> "${output_log}" 2>&1
129	#   return $?
130	# }
131
132	# # 1. Encrypt the binary
133	# run_command "${prepareimage_cmd} enc -k \"${oemkey}\" -n \"${nonce}\" \"${bin_file}\" \"${sfu}\"" && \
134	# # 2. Sign the original binary
135	# run_command "${prepareimage_cmd} sign -k \"${oemkey}\" -n \"${nonce}\" \"${bin_file}\" \"${sign}\"" && \
136	# # 3. Pack the encrypted firmware and signature into a secure binary
137	# run_command "${prepareimage_cmd} pack -m \"${magic}\" -k \"${oemkey}\" -r 112 -v \"${version}\" -n \"${nonce}\" -f \"${sfu}\" -t \"${sign}\" \"${sfb}\" -o \"${offset}\"" && \
138	# # 4. Generate the firmware header
139	# run_command "${prepareimage_cmd} header -m \"${magic}\" -k \"${oemkey}\" -r 112 -v \"${version}\" -n \"${nonce}\" -f \"${sfu}\" -t \"${sign}\" -o \"${offset}\" \"${headerbin}\"" && \
140	# # 5. Merge with the bootloader ELF (if the flag is set)
141	# if [[ $# -eq 6 ]]; then
142	#   log_info "--- Merging with BFU to create big binary ---"
143	#   run_command "${prepareimage_cmd} merge -v 0 -e 1 -i \"${headerbin}\" -s \"${sbsfuelf_placeholder­}\" -u \"${elf_file}\" \"${bigbinary}\""
144	# fi
145
146	# ret=$?
147
148	# # --- Cleanup ---
149	# if [[ ${ret} -eq 0 ]]; then
150	#   log_info "--- Build successful, cleaning up intermediate files ---"
151	#   rm -f "${sign}" "${sfu}" "${headerbin}"
152	#   log_info "Post-build finished successfully."
153	#   exit 0
154	# else
155	#   log_info "!!! Post-build FAILED at command: ${last_command} !!!"
156	#   echo "ERROR: Post-build failed. Check log at ${output_log}" >&2
157	#   # Optional: keep intermediate files for debugging on failure
158	#   # rm -f "${elf_file}" "${elfbackup}"
159	#   exit 1
160	# fi
161
162
L476_USER_APP\Common\Startup\se_key.s

	.section .SE_Key_Data,"a",%progbits
	.syntax unified
	.thumb
	.global SE_ReadKey_1
SE_ReadKey_1:
	PUSH {R1-R5}
	MOVW R1, #0x454f
	MOVT R1, #0x5f4d
	MOVW R2, #0x454b
	MOVT R2, #0x5f59
	MOVW R3, #0x4f43
	MOVT R3, #0x504d
	MOVW R4, #0x4e41
	MOVT R4, #0x3159
	STM R0, {R1-R4}
	POP {R1-R5}
	BX LR

    .end

L476_USER_APP\UserApp\.settings\language.settings.xml
1	<?xml version="1.0" encoding="UTF-8" standalone="no"?>
2	<project>
3		<configuration id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.433848364" name="Debug">
4			<extension point="org.eclipse.cdt.core.LanguageSettingsProv­ider">
5				<provider copy-of="extension" id="org.eclipse.cdt.ui.UserLanguageSettings­Provider"/>
6				<provider-reference id="org.eclipse.cdt.core.ReferencedProjectsLa­nguageSettingsProvid­er" ref="shared-provider"/>
7				<provider-reference id="org.eclipse.cdt.managedbuilder.core.MBSLanguageSettingsP­rovider" ref="shared-provider"/>
8				<provider class="com.st.stm32cube.ide.mcu.toolchain.armnone.setup.CrossBuiltinSpecsDet­ector" console="false" env-hash="-1200567310933719700" id="com.st.stm32cube.ide.mcu.toolchain.armnone.setup.CrossBuiltinSpecsDet­ector" keep-relative-paths="false" name="MCU ARM GCC Built-in Compiler Settings" parameter="${COMMAND} ${FLAGS} -E -P -v -dD &quot;${INPUTS}&quot;" prefer-non-shared="true">
9					<language-scope id="org.eclipse.cdt.core.gcc"/>
10					<language-scope id="org.eclipse.cdt.core.g++"/>
11				</provider>
12			</extension>
13		</configuration>
14	</project>
L476_USER_APP\UserApp\.settings\org.eclipse.core.resources.prefs

eclipse.preferences.version=1
encoding/<project>=UTF-8

L476_USER_APP\UserApp\Application\Core\Inc\com.h
1	/**
2	  ******************************************************************************
3	  * @file    com.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for COM module functionalities.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef COM_H
21	#define COM_H
22
23	#ifdef __cplusplus
24	extern "C" {
25	#endif
26
27	/** @addtogroup USER_APP User App Example
28	  * @{
29	  */
30
31	/** @addtogroup USER_APP_COMMON Common
32	  * @{
33	  */
34
35	/* Includes ------------------------------------------------------------------*/
36	#include <stdint.h>
37	#include <stdio.h>
38	#include "stm32l4xx.h"
39
40	/** @defgroup  COM_Exported_Constan­ts Exported Constants
41	  * @{
42	  */
43	/** @defgroup COM_UART  UART Configuration
44	  * @{
45	  */
46
47	#define COM_UART                                USART2
48	#define COM_UART_CLK_ENABLE()                   __HAL_RCC_USART2_CLK­_ENABLE()
49	#define COM_UART_CLK_DISABLE­()                  __HAL_RCC_USART2_CLK­_DISABLE()
50
51	#define COM_UART_TX_AF                          GPIO_AF7_USART2
52	#define COM_UART_TX_GPIO_POR­T                   GPIOA
53	#define COM_UART_TX_PIN                         GPIO_PIN_2
54	#define COM_UART_TX_GPIO_CLK­_ENABLE()           __HAL_RCC_GPIOA_CLK_­ENABLE()
55	#define COM_UART_TX_GPIO_CLK­_DISABLE()          __HAL_RCC_GPIOA_CLK_­DISABLE()
56
57	#define COM_UART_RX_AF                          GPIO_AF7_USART2
58	#define COM_UART_RX_GPIO_POR­T                   GPIOA
59	#define COM_UART_RX_PIN                         GPIO_PIN_3
60	#define COM_UART_RX_GPIO_CLK­_ENABLE()           __HAL_RCC_GPIOA_CLK_­ENABLE()
61	#define COM_UART_RX_GPIO_CLK­_DISABLE()          __HAL_RCC_GPIOA_CLK_­DISABLE()
62
63	/* Maximum Timeout values for flags waiting loops.
64	   You may modify these timeout values depending on CPU frequency and application
65	   conditions (interrupts routines ...). */
66	#define COM_UART_TIMEOUT_MAX­                   1000U
67
68	/**
69	  * @}
70	  */
71
72	/**
73	  * @}
74	  */
75
76	/** @addtogroup  COM_Exported_Functio­ns
77	  * @{
78	  */
79
80	HAL_StatusTypeDef  COM_Init(void);
81	HAL_StatusTypeDef  COM_DeInit(void);
82	HAL_StatusTypeDef  COM_Transmit(uint8_t *Data, uint16_t uDataLength, uint32_t uTimeout);
83	HAL_StatusTypeDef  COM_Receive(uint8_t *Data, uint16_t uDataLength, uint32_t uTimeout);
84	HAL_StatusTypeDef  COM_Flush(void);
85
86	HAL_StatusTypeDef Ymodem_HeaderPktRxCp­ltCallback(uint32_t uFileSize);
87	HAL_StatusTypeDef Ymodem_DataPktRxCplt­Callback(uint8_t *pData, uint32_t uFlashDestination, uint32_t uSize);
88	/**
89	  * @}
90	  */
91
92	/**
93	  * @}
94	  */
95
96	/**
97	  * @}
98	  */
99
100	#ifdef __cplusplus
101	}
102	#endif
103
104	#endif /* COM_H */
105
L476_USER_APP\UserApp\Application\Core\Inc\common.h
1	/**
2	  ******************************************************************************
3	  * @file    common.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for COMMON module functionalities.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef COMMON_H
21	#define COMMON_H
22
23	/** @addtogroup USER_APP User App Example
24	  * @{
25	  */
26
27	/** @addtogroup USER_APP_COMMON Common
28	  * @{
29	  */
30
31	/* Includes ------------------------------------------------------------------*/
32	#include "stm32l4xx.h"
33
34	/* Exported types ------------------------------------------------------------*/
35	/* Exported constants --------------------------------------------------------*/
36	/* Constants used by Serial Command Line Mode */
37	#define TX_TIMEOUT          ((uint32_t)100U)
38	#define RX_TIMEOUT          ((uint32_t)2000U)
39
40	/* Exported macro ------------------------------------------------------------*/
41	#define IS_CAP_LETTER(c)    (((c) >= 'A') && ((c) <= 'F'))
42	#define IS_LC_LETTER(c)     (((c) >= 'a') && ((c) <= 'f'))
43	#define IS_09(c)            (((c) >= '0') && ((c) <= '9'))
44	#define ISVALIDHEX(c)       (IS_CAP_LETTER(c) || IS_LC_LETTER(c) || IS_09(c))
45	#define ISVALIDDEC(c)       IS_09(c)
46	#define CONVERTDEC(c)       (c - '0')
47
48	#define CONVERTHEX_ALPHA(c) (IS_CAP_LETTER(c) ? ((c) - 'A'+10) : ((c) - 'a'+10))
49	#define CONVERTHEX(c)       (IS_09(c) ? ((c) - '0') : CONVERTHEX_ALPHA(c))
50
51	/* Exported functions ------------------------------------------------------- */
52	uint32_t Str2Int(uint8_t *pInputStr, uint32_t *pIntNum);
53	HAL_StatusTypeDef Serial_PutByte(uint8_t uParam);
54
55
56	/**
57	  * @}
58	  */
59
60	/**
61	  * @}
62	  */
63
64	#endif  /* COMMON_H */
65
L476_USER_APP\UserApp\Application\Core\Inc\flash_if.h
1	/**
2	  ******************************************************************************
3	  * @file    flash_if.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for FLASH Interface functionalities.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef FLASH_IF_H
21	#define FLASH_IF_H
22
23	/** @addtogroup USER_APP User App Example
24	  * @{
25	  */
26
27	/** @addtogroup USER_APP_COMMON Common
28	  * @{
29	  */
30
31	/* Includes ------------------------------------------------------------------*/
32	#include "stm32l4xx.h"
33
34	/* Exported types ------------------------------------------------------------*/
35	/* Exported constants --------------------------------------------------------*/
36	#define FLASH_IF_MIN_WRITE_L­EN (8U)  /* Flash programming by 64 bits */
37	/* Exported functions ------------------------------------------------------- */
38
39	HAL_StatusTypeDef FLASH_If_Init(void);
40	HAL_StatusTypeDef FLASH_If_Write(void *pDestination, const void *pSource, uint32_t uLength);
41	HAL_StatusTypeDef FLASH_If_Read(void *pDestination, const void *pSource, uint32_t uLength);
42	HAL_StatusTypeDef FLASH_If_Erase_Size(void *pStart, uint32_t uLength);
43	HAL_StatusTypeDef FLASH_INT_Init(void);
44	HAL_StatusTypeDef FLASH_INT_If_Write(void *pDestination, const void *pSource, uint32_t uLength);
45	HAL_StatusTypeDef FLASH_INT_If_Read(void *pDestination, const void *pSource, uint32_t uLength);
46	HAL_StatusTypeDef FLASH_INT_If_Erase_S­ize(void *pStart, uint32_t uLength);
47	HAL_StatusTypeDef FLASH_EXT_Init(void);
48	HAL_StatusTypeDef FLASH_EXT_If_Write(void *pDestination, const void *pSource, uint32_t uLength);
49	HAL_StatusTypeDef FLASH_EXT_If_Read(void *pDestination, const void *pSource, uint32_t uLength);
50	HAL_StatusTypeDef FLASH_EXT_If_Erase_S­ize(void *pStart, uint32_t uLength);
51
52
53	/**
54	  * @}
55	  */
56
57	/**
58	  * @}
59	  */
60
61	#endif  /* FLASH_IF_H */
62
L476_USER_APP\UserApp\Application\Core\Inc\fw_update_app.h
1	/**
2	  ******************************************************************************
3	  * @file    fw_update_app.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for Firmware Update module
6	  *          functionalities.
7	  ******************************************************************************
8	  * @attention
9	  *
10	  * Copyright (c) 2017 STMicroelectronics.
11	  * All rights reserved.
12	  *
13	  * This software is licensed under terms that can be found in the LICENSE file in
14	  * the root directory of this software component.
15	  * If no LICENSE file comes with this software, it is provided AS-IS.
16	  *
17	  ******************************************************************************
18	  */
19
20	/* Define to prevent recursive inclusion -------------------------------------*/
21	#ifndef FW_UPDATE_APP_H
22	#define FW_UPDATE_APP_H
23
24	#ifdef __cplusplus
25	extern "C" {
26	#endif
27
28
29	/* Includes ------------------------------------------------------------------*/
30	#include <stdint.h>
31
32	void FW_UPDATE_Run(void);
33	void FW_UPDATE_MULTIPLE_R­unMenu(void);
34	void FW_VALIDATE_RunMenu(void);
35
36	#ifdef __cplusplus
37	}
38	#endif
39
40	#endif /* FW_UPDATE_APP_H */
41
L476_USER_APP\UserApp\Application\Core\Inc\main.h
1	/**
2	  ******************************************************************************
3	  * @file    main.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for main application file.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef MAIN_H
21	#define MAIN_H
22
23	/* Includes ------------------------------------------------------------------*/
24	#include "stm32l4xx_hal.h"
25	#include "stm32l4xx_nucleo.h"
26	#include "com.h"
27
28	/* Exported types ------------------------------------------------------------*/
29	/* Exported constants --------------------------------------------------------*/
30	/* User can use this section to tailor UARTx instance used and associated
31	   resources */
32
33	#define BUTTON_INIT()         BSP_PB_Init(BUTTON_USER,BUTTON_MODE_GPIO);
34	#define BUTTON_PUSHED()      (BSP_PB_GetState(BUTTON_USER) == GPIO_PIN_RESET)
35
36	/* Definition for USARTx clock resources */
37	#define SFU_UART                                USART2
38	#define SFU_UART_CLK_ENABLE()                   __HAL_RCC_USART2_CLK­_ENABLE()
39	#define SFU_UART_CLK_DISABLE­()                  __HAL_RCC_USART2_CLK­_DISABLE()
40
41	#define SFU_UART_TX_AF                          GPIO_AF7_USART2
42	#define SFU_UART_TX_GPIO_POR­T                   GPIOA
43	#define SFU_UART_TX_PIN                         GPIO_PIN_2
44	#define SFU_UART_TX_GPIO_CLK­_ENABLE()           __HAL_RCC_GPIOA_CLK_­ENABLE()
45	#define SFU_UART_TX_GPIO_CLK­_DISABLE()          __HAL_RCC_GPIOA_CLK_­DISABLE()
46
47	#define SFU_UART_RX_AF                          GPIO_AF7_USART2
48	#define SFU_UART_RX_GPIO_POR­T                   GPIOA
49	#define SFU_UART_RX_PIN                         GPIO_PIN_3
50	#define SFU_UART_RX_GPIO_CLK­_ENABLE()           __HAL_RCC_GPIOA_CLK_­ENABLE()
51	#define SFU_UART_RX_GPIO_CLK­_DISABLE()          __HAL_RCC_GPIOA_CLK_­DISABLE()
52
53	/* Maximum Timeout values for flags waiting loops.
54	   You may modify these timeout values depending on CPU frequency and application
55	   conditions (interrupts routines ...). */
56	#define SFU_UART_TIMEOUT_MAX­                   1000U
57
58	/* Exported macro ------------------------------------------------------------*/
59	/* Exported functions ------------------------------------------------------- */
60
61	#endif /* MAIN_H */
62
L476_USER_APP\UserApp\Application\Core\Inc\se_user_code.h
1	/**
2	  ******************************************************************************
3	  * @file    se_user_code.h
4	  * @author  MCD Application Team
5	  * @brief   Secure Engine User code example module.
6	  *          This file demonstrates how to call user defined services running
7	  *          in Secure Engine.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Define to prevent recursive inclusion -------------------------------------*/
22	#ifndef SE_USER_CODE_H
23	#define SE_USER_CODE_H
24
25	#ifdef __cplusplus
26	extern "C" {
27	#endif
28
29	/** @addtogroup USER_APP User App Example
30	  * @{
31	  */
32
33	/** @addtogroup SE_USER_CODE Secure Engine User Code Example
34	  * @{
35	  */
36
37	/* Includes ------------------------------------------------------------------*/
38
39	/** @addtogroup  SE_USER_CODE_Exporte­d_Functions
40	  * @{
41	  */
42
43	void SE_USER_CODE_RunMenu­(void);
44
45	/**
46	  * @}
47	  */
48
49	/**
50	  * @}
51	  */
52
53	/**
54	  * @}
55	  */
56
57	#ifdef __cplusplus
58	}
59	#endif
60
61	#endif /* SE_USER_CODE_H */
62
L476_USER_APP\UserApp\Application\Core\Inc\sfu_app_new_image.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_app_new_image.h
4	  * @author  MCD Application Team
5	  * @brief   This file provides set of firmware functions to manage the New
6	  *          Firmware Image storage and installation.
7	  *          This file contains the services the bootloader and the user application
8	  *          can use to know where to store a new FW image and request its installation.
9	  ******************************************************************************
10	  * @attention
11	  *
12	  * Copyright (c) 2017 STMicroelectronics.
13	  * All rights reserved.
14	  *
15	  * This software is licensed under terms that can be found in the LICENSE file in
16	  * the root directory of this software component.
17	  * If no LICENSE file comes with this software, it is provided AS-IS.
18	  *
19	  ******************************************************************************
20	  */
21
22	/* Define to prevent recursive inclusion -------------------------------------*/
23	#ifndef SFU_APP_NEW_IMAGE_H
24	#define SFU_APP_NEW_IMAGE_H
25
26	#ifdef __cplusplus
27	extern "C" {
28	#endif
29
30	/* Includes ------------------------------------------------------------------*/
31	#include "sfu_def.h"
32
33	/* Exported types ------------------------------------------------------------*/
34	/**
35	  * @brief Specifies a structure containing values related to the management of multi-images in Flash.
36	  */
37	typedef struct
38	{
39	  uint32_t  MaxSizeInBytes;        /*!< The maximum allowed size for the FwImage in User Flash (in Bytes) */
40	  uint32_t  DownloadAddr;          /*!< The download address for the FwImage in UserFlash */
41	  uint32_t  ImageOffsetInBytes;    /*!< Image write starts at this offset */
42	  uint32_t  ExecutionAddr;         /*!< The execution address for the FwImage in UserFlash */
43	} SFU_FwImageFlashType­Def;
44
45	/* Exported functions ------------------------------------------------------- */
46	HAL_StatusTypeDef SFU_APP_InstallAtNex­tReset(uint8_t *fw_header);
47	void SFU_APP_GetDownloadA­reaInfo(uint32_t DwlSlot, SFU_FwImageFlashType­Def *pArea);
48
49	#ifdef __cplusplus
50	}
51	#endif
52
53	#endif /* SFU_APP_NEW_IMAGE_H */
54
L476_USER_APP\UserApp\Application\Core\Inc\stm32l4xx_hal_conf.h
1	/**
2	  ******************************************************************************
3	  * @file    stm32l4xx_hal_conf.h
4	  * @author  MCD Application Team
5	  * @brief   HAL configuration file.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef STM32L4xx_HAL_CONF_H­
21	#define STM32L4xx_HAL_CONF_H­
22
23	#ifdef __cplusplus
24	 extern "C" {
25	#endif
26
27	/* Exported types ------------------------------------------------------------*/
28	/* Exported constants --------------------------------------------------------*/
29
30	/* ########################## Module Selection ############################## */
31	/**
32	  * @brief This is the list of modules to be used in the HAL driver
33	  */
34	#define HAL_MODULE_ENABLED
35	/* #define HAL_ADC_MODULE_ENABL­ED */
36	/* #define HAL_CAN_MODULE_ENABL­ED */
37	/* #define HAL_CAN_LEGACY_MODUL­E_ENABLED */
38	/* #define HAL_COMP_MODULE_ENAB­LED */
39	#define HAL_CORTEX_MODULE_EN­ABLED
40	#define HAL_CRC_MODULE_ENABL­ED
41	/* #define HAL_CRYP_MODULE_ENAB­LED */
42	/* #define HAL_DAC_MODULE_ENABL­ED */
43	/* #define HAL_DCMI_MODULE_ENAB­LED */
44	/* #define HAL_DFSDM_MODULE_ENA­BLED */
45	#define HAL_DMA_MODULE_ENABL­ED
46	/* #define HAL_DMA2D_MODULE_ENA­BLED */
47	/* #define HAL_DSI_MODULE_ENABL­ED */
48	/* #define HAL_EXTI_MODULE_ENAB­LED */
49	/* #define HAL_FIREWALL_MODULE_­ENABLED */
50	#define HAL_FLASH_MODULE_ENA­BLED
51	/* #define HAL_GFXMMU_MODULE_EN­ABLED */
52	#define HAL_GPIO_MODULE_ENAB­LED
53	/* #define HAL_HASH_MODULE_ENAB­LED */
54	/* #define HAL_HCD_MODULE_ENABL­ED */
55	/* #define HAL_I2C_MODULE_ENABL­ED */
56	/* #define HAL_IRDA_MODULE_ENAB­LED */
57	#define HAL_IWDG_MODULE_ENAB­LED
58	/* #define HAL_LCD_MODULE_ENABL­ED */
59	/* #define HAL_LPTIM_MODULE_ENA­BLED */
60	/* #define HAL_LTDC_MODULE_ENAB­LED */
61	/* #define HAL_MMC_MODULE_ENABL­ED */
62	/* #define HAL_NAND_MODULE_ENAB­LED */
63	/* #define HAL_NOR_MODULE_ENABL­ED */
64	/* #define HAL_OPAMP_MODULE_ENA­BLED */
65	/* #define HAL_OSPI_MODULE_ENAB­LED */
66	/* #define HAL_PCD_MODULE_ENABL­ED */
67	#define HAL_PWR_MODULE_ENABL­ED
68	/* #define HAL_QSPI_MODULE_ENAB­LED */
69	#define HAL_RCC_MODULE_ENABL­ED
70	/* #define HAL_RNG_MODULE_ENABL­ED */
71	#define HAL_RTC_MODULE_ENABL­ED
72	/* #define HAL_SAI_MODULE_ENABL­ED */
73	/* #define HAL_SD_MODULE_ENABLE­D */
74	/* #define HAL_SMARTCARD_MODULE­_ENABLED */
75	/* #define HAL_SMBUS_MODULE_ENA­BLED */
76	/* #define HAL_SPI_MODULE_ENABL­ED */
77	/* #define HAL_SRAM_MODULE_ENAB­LED */
78	/* #define HAL_SWPMI_MODULE_ENA­BLED */
79	/* #define HAL_TIM_MODULE_ENABL­ED */
80	/* #define HAL_TSC_MODULE_ENABL­ED */
81	#define HAL_UART_MODULE_ENAB­LED
82	/* #define HAL_USART_MODULE_ENA­BLED */
83	/* #define HAL_WWDG_MODULE_ENAB­LED */
84
85
86	/* ########################## Oscillator Values adaptation ####################*/
87	/**
88	  * @brief Adjust the value of External High Speed oscillator (HSE) used in your application.
89	  *        This value is used by the RCC HAL module to compute the system frequency
90	  *        (when HSE is used as system clock source, directly or through the PLL).
91	  */
92	#if !defined  (HSE_VALUE)
93	  #define HSE_VALUE    8000000U /*!< Value of the External oscillator in Hz */
94	#endif /* HSE_VALUE */
95
96	#if !defined  (HSE_STARTUP_TIMEOUT)
97	  #define HSE_STARTUP_TIMEOUT    100U   /*!< Time out for HSE start up, in ms */
98	#endif /* HSE_STARTUP_TIMEOUT */
99
100	/**
101	  * @brief Internal Multiple Speed oscillator (MSI) default value.
102	  *        This value is the default MSI range value after Reset.
103	  */
104	#if !defined  (MSI_VALUE)
105	  #define MSI_VALUE    4000000U /*!< Value of the Internal oscillator in Hz*/
106	#endif /* MSI_VALUE */
107
108	/**
109	  * @brief Internal High Speed oscillator (HSI) value.
110	  *        This value is used by the RCC HAL module to compute the system frequency
111	  *        (when HSI is used as system clock source, directly or through the PLL).
112	  */
113	#if !defined  (HSI_VALUE)
114	  #define HSI_VALUE    16000000U /*!< Value of the Internal oscillator in Hz*/
115	#endif /* HSI_VALUE */
116
117	/**
118	  * @brief Internal High Speed oscillator (HSI48) value for USB FS, SDMMC and RNG.
119	  *        This internal oscillator is mainly dedicated to provide a high precision clock to
120	  *        the USB peripheral by means of a special Clock Recovery System (CRS) circuitry.
121	  *        When the CRS is not used, the HSI48 RC oscillator runs on it default frequency
122	  *        which is subject to manufacturing process variations.
123	  */
124	#if !defined  (HSI48_VALUE)
125	  #define HSI48_VALUE   48000000U             /*!< Value of the Internal High Speed oscillator for USB FS/SDMMC/RNG in Hz.
126	                                               The real value my vary depending on manufacturing process variations.*/
127	#endif /* HSI48_VALUE */
128
129	/**
130	  * @brief Internal Low Speed oscillator (LSI) value.
131	  */
132	#if !defined  (LSI_VALUE)
133	  #define LSI_VALUE  32000U                 /*!< LSI Typical Value in Hz*/
134	#endif /* LSI_VALUE */                      /*!< Value of the Internal Low Speed oscillator in Hz
135	                                              The real value may vary depending on the variations
136	                                              in voltage and temperature.*/
137	/**
138	  * @brief External Low Speed oscillator (LSE) value.
139	  *        This value is used by the UART, RTC HAL module to compute the system frequency
140	  */
141	#if !defined  (LSE_VALUE)
142	  #define LSE_VALUE    32768U /*!< Value of the External oscillator in Hz*/
143	#endif /* LSE_VALUE */
144
145	#if !defined  (LSE_STARTUP_TIMEOUT)
146	  #define LSE_STARTUP_TIMEOUT    5000U  /*!< Time out for LSE start up, in ms */
147	#endif /* HSE_STARTUP_TIMEOUT */
148
149	/**
150	  * @brief External clock source for SAI1 peripheral
151	  *        This value is used by the RCC HAL module to compute the SAI1 & SAI2 clock source
152	  *        frequency.
153	  */
154	#if !defined  (EXTERNAL_SAI1_CLOCK_­VALUE)
155	  #define EXTERNAL_SAI1_CLOCK_­VALUE    48000U /*!< Value of the SAI1 External clock source in Hz*/
156	#endif /* EXTERNAL_SAI1_CLOCK_­VALUE */
157
158	/**
159	  * @brief External clock source for SAI2 peripheral
160	  *        This value is used by the RCC HAL module to compute the SAI1 & SAI2 clock source
161	  *        frequency.
162	  */
163	#if !defined  (EXTERNAL_SAI2_CLOCK_­VALUE)
164	  #define EXTERNAL_SAI2_CLOCK_­VALUE    48000U /*!< Value of the SAI2 External clock source in Hz*/
165	#endif /* EXTERNAL_SAI2_CLOCK_­VALUE */
166
167	/* Tip: To avoid modifying this file each time you need to use different HSE,
168	   ===  you can define the HSE value in your toolchain compiler preprocessor. */
169
170	/* ########################### System Configuration ######################### */
171	/**
172	  * @brief This is the HAL system configuration section
173	  */
174	#define  VDD_VALUE                    3300U /*!< Value of VDD in mv */
175	#define  TICK_INT_PRIORITY            0x0FU /*!< tick interrupt priority */
176	#define  USE_RTOS                     0U
177	#define  PREFETCH_ENABLE              0U
178	#define  INSTRUCTION_CACHE_EN­ABLE     1U
179	#define  DATA_CACHE_ENABLE            1U
180
181	/* ########################## Assert Selection ############################## */
182	/**
183	  * @brief Uncomment the line below to expanse the "assert_param" macro in the
184	  *        HAL drivers code
185	  */
186	/* #define USE_FULL_ASSERT               1U */
187
188	/* ################## Register callback feature configuration ############### */
189	/**
190	  * @brief Set below the peripheral configuration  to "1U" to add the support
191	  *        of HAL callback registration/deregistration feature for the HAL
192	  *        driver(s). This allows user application to provide specific callback
193	  *        functions thanks to HAL_PPP_RegisterCall­back() rather than overwriting
194	  *        the default weak callback functions (see each stm32l4xx_hal_ppp.h file
195	  *        for possible callback identifiers defined in HAL_PPP_CallbackIDTy­peDef
196	  *        for each PPP peripheral).
197	  */
198	#define USE_HAL_ADC_REGISTER­_CALLBACKS        0U
199	#define USE_HAL_CAN_REGISTER­_CALLBACKS        0U
200	#define USE_HAL_COMP_REGISTE­R_CALLBACKS       0U
201	#define USE_HAL_CRYP_REGISTE­R_CALLBACKS       0U
202	#define USE_HAL_DAC_REGISTER­_CALLBACKS        0U
203	#define USE_HAL_DCMI_REGISTE­R_CALLBACKS       0U
204	#define USE_HAL_DFSDM_REGIST­ER_CALLBACKS      0U
205	#define USE_HAL_DMA2D_REGIST­ER_CALLBACKS      0U
206	#define USE_HAL_DSI_REGISTER­_CALLBACKS        0U
207	#define USE_HAL_GFXMMU_REGIS­TER_CALLBACKS     0U
208	#define USE_HAL_HASH_REGISTE­R_CALLBACKS       0U
209	#define USE_HAL_HCD_REGISTER­_CALLBACKS        0U
210	#define USE_HAL_I2C_REGISTER­_CALLBACKS        0U
211	#define USE_HAL_IRDA_REGISTE­R_CALLBACKS       0U
212	#define USE_HAL_LPTIM_REGIST­ER_CALLBACKS      0U
213	#define USE_HAL_LTDC_REGISTE­R_CALLBACKS       0U
214	#define USE_HAL_MMC_REGISTER­_CALLBACKS        0U
215	#define USE_HAL_OPAMP_REGIST­ER_CALLBACKS      0U
216	#define USE_HAL_OSPI_REGISTE­R_CALLBACKS       0U
217	#define USE_HAL_PCD_REGISTER­_CALLBACKS        0U
218	#define USE_HAL_QSPI_REGISTE­R_CALLBACKS       0U
219	#define USE_HAL_RNG_REGISTER­_CALLBACKS        0U
220	#define USE_HAL_RTC_REGISTER­_CALLBACKS        0U
221	#define USE_HAL_SAI_REGISTER­_CALLBACKS        0U
222	#define USE_HAL_SD_REGISTER_­CALLBACKS         0U
223	#define USE_HAL_SMARTCARD_RE­GISTER_CALLBACKS  0U
224	#define USE_HAL_SMBUS_REGIST­ER_CALLBACKS      0U
225	#define USE_HAL_SPI_REGISTER­_CALLBACKS        0U
226	#define USE_HAL_SWPMI_REGIST­ER_CALLBACKS      0U
227	#define USE_HAL_TIM_REGISTER­_CALLBACKS        0U
228	#define USE_HAL_TSC_REGISTER­_CALLBACKS        0U
229	#define USE_HAL_UART_REGISTE­R_CALLBACKS       0U
230	#define USE_HAL_USART_REGIST­ER_CALLBACKS      0U
231	#define USE_HAL_WWDG_REGISTE­R_CALLBACKS       0U
232
233	/* ################## SPI peripheral configuration ########################## */
234
235	/* CRC FEATURE: Use to activate CRC feature inside HAL SPI Driver
236	 * Activated: CRC code is present inside driver
237	 * Deactivated: CRC code cleaned from driver
238	 */
239
240	#define USE_SPI_CRC                   1U
241
242	/* Includes ------------------------------------------------------------------*/
243	/**
244	  * @brief Include module's header file
245	  */
246
247	#ifdef HAL_RCC_MODULE_ENABL­ED
248	  #include "stm32l4xx_hal_rcc.h"
249	#endif /* HAL_RCC_MODULE_ENABL­ED */
250
251	#ifdef HAL_GPIO_MODULE_ENAB­LED
252	  #include "stm32l4xx_hal_gpio.h"
253	#endif /* HAL_GPIO_MODULE_ENAB­LED */
254
255	#ifdef HAL_DMA_MODULE_ENABL­ED
256	  #include "stm32l4xx_hal_dma.h"
257	#endif /* HAL_DMA_MODULE_ENABL­ED */
258
259	#ifdef HAL_DFSDM_MODULE_ENA­BLED
260	  #include "stm32l4xx_hal_dfsdm.h"
261	#endif /* HAL_DFSDM_MODULE_ENA­BLED */
262
263	#ifdef HAL_CORTEX_MODULE_EN­ABLED
264	  #include "stm32l4xx_hal_cortex­.h"
265	#endif /* HAL_CORTEX_MODULE_EN­ABLED */
266
267	#ifdef HAL_ADC_MODULE_ENABL­ED
268	  #include "stm32l4xx_hal_adc.h"
269	#endif /* HAL_ADC_MODULE_ENABL­ED */
270
271	#ifdef HAL_CAN_MODULE_ENABL­ED
272	  #include "stm32l4xx_hal_can.h"
273	#endif /* HAL_CAN_MODULE_ENABL­ED */
274
275	#ifdef HAL_CAN_LEGACY_MODUL­E_ENABLED
276	  #include "Legacy/stm32l4xx_hal_can_le­gacy.h"
277	#endif /* HAL_CAN_LEGACY_MODUL­E_ENABLED */
278
279	#ifdef HAL_COMP_MODULE_ENAB­LED
280	  #include "stm32l4xx_hal_comp.h"
281	#endif /* HAL_COMP_MODULE_ENAB­LED */
282
283	#ifdef HAL_CRC_MODULE_ENABL­ED
284	  #include "stm32l4xx_hal_crc.h"
285	#endif /* HAL_CRC_MODULE_ENABL­ED */
286
287	#ifdef HAL_CRYP_MODULE_ENAB­LED
288	  #include "stm32l4xx_hal_cryp.h"
289	#endif /* HAL_CRYP_MODULE_ENAB­LED */
290
291	#ifdef HAL_DAC_MODULE_ENABL­ED
292	  #include "stm32l4xx_hal_dac.h"
293	#endif /* HAL_DAC_MODULE_ENABL­ED */
294
295	#ifdef HAL_DCMI_MODULE_ENAB­LED
296	  #include "stm32l4xx_hal_dcmi.h"
297	#endif /* HAL_DCMI_MODULE_ENAB­LED */
298
299	#ifdef HAL_DMA2D_MODULE_ENA­BLED
300	  #include "stm32l4xx_hal_dma2d.h"
301	#endif /* HAL_DMA2D_MODULE_ENA­BLED */
302
303	#ifdef HAL_DSI_MODULE_ENABL­ED
304	  #include "stm32l4xx_hal_dsi.h"
305	#endif /* HAL_DSI_MODULE_ENABL­ED */
306
307	#ifdef HAL_EXTI_MODULE_ENAB­LED
308	  #include "stm32l4xx_hal_exti.h"
309	#endif /* HAL_EXTI_MODULE_ENAB­LED */
310
311	#ifdef HAL_GFXMMU_MODULE_EN­ABLED
312	  #include "stm32l4xx_hal_gfxmmu­.h"
313	#endif /* HAL_GFXMMU_MODULE_EN­ABLED */
314
315	#ifdef HAL_FIREWALL_MODULE_­ENABLED
316	  #include "stm32l4xx_hal_firewa­ll.h"
317	#endif /* HAL_FIREWALL_MODULE_­ENABLED */
318
319	#ifdef HAL_FLASH_MODULE_ENA­BLED
320	  #include "stm32l4xx_hal_flash.h"
321	#endif /* HAL_FLASH_MODULE_ENA­BLED */
322
323	#ifdef HAL_HASH_MODULE_ENAB­LED
324	  #include "stm32l4xx_hal_hash.h"
325	#endif /* HAL_HASH_MODULE_ENAB­LED */
326
327	#ifdef HAL_HCD_MODULE_ENABL­ED
328	  #include "stm32l4xx_hal_hcd.h"
329	#endif /* HAL_HCD_MODULE_ENABL­ED */
330
331	#ifdef HAL_I2C_MODULE_ENABL­ED
332	  #include "stm32l4xx_hal_i2c.h"
333	#endif /* HAL_I2C_MODULE_ENABL­ED */
334
335	#ifdef HAL_IRDA_MODULE_ENAB­LED
336	  #include "stm32l4xx_hal_irda.h"
337	#endif /* HAL_IRDA_MODULE_ENAB­LED */
338
339	#ifdef HAL_IWDG_MODULE_ENAB­LED
340	  #include "stm32l4xx_hal_iwdg.h"
341	#endif /* HAL_IWDG_MODULE_ENAB­LED */
342
343	#ifdef HAL_LCD_MODULE_ENABL­ED
344	  #include "stm32l4xx_hal_lcd.h"
345	#endif /* HAL_LCD_MODULE_ENABL­ED */
346
347	#ifdef HAL_LPTIM_MODULE_ENA­BLED
348	  #include "stm32l4xx_hal_lptim.h"
349	#endif /* HAL_LPTIM_MODULE_ENA­BLED */
350
351	#ifdef HAL_LTDC_MODULE_ENAB­LED
352	  #include "stm32l4xx_hal_ltdc.h"
353	#endif /* HAL_LTDC_MODULE_ENAB­LED */
354
355	#ifdef HAL_MMC_MODULE_ENABL­ED
356	  #include "stm32l4xx_hal_mmc.h"
357	#endif /* HAL_MMC_MODULE_ENABL­ED */
358
359	#ifdef HAL_NAND_MODULE_ENAB­LED
360	  #include "stm32l4xx_hal_nand.h"
361	#endif /* HAL_NAND_MODULE_ENAB­LED */
362
363	#ifdef HAL_NOR_MODULE_ENABL­ED
364	  #include "stm32l4xx_hal_nor.h"
365	#endif /* HAL_NOR_MODULE_ENABL­ED */
366
367	#ifdef HAL_OPAMP_MODULE_ENA­BLED
368	  #include "stm32l4xx_hal_opamp.h"
369	#endif /* HAL_OPAMP_MODULE_ENA­BLED */
370
371	#ifdef HAL_OSPI_MODULE_ENAB­LED
372	  #include "stm32l4xx_hal_ospi.h"
373	#endif /* HAL_OSPI_MODULE_ENAB­LED */
374
375	#ifdef HAL_PCD_MODULE_ENABL­ED
376	  #include "stm32l4xx_hal_pcd.h"
377	#endif /* HAL_PCD_MODULE_ENABL­ED */
378
379	#ifdef HAL_PWR_MODULE_ENABL­ED
380	  #include "stm32l4xx_hal_pwr.h"
381	#endif /* HAL_PWR_MODULE_ENABL­ED */
382
383	#ifdef HAL_QSPI_MODULE_ENAB­LED
384	  #include "stm32l4xx_hal_qspi.h"
385	#endif /* HAL_QSPI_MODULE_ENAB­LED */
386
387	#ifdef HAL_RNG_MODULE_ENABL­ED
388	  #include "stm32l4xx_hal_rng.h"
389	#endif /* HAL_RNG_MODULE_ENABL­ED */
390
391	#ifdef HAL_RTC_MODULE_ENABL­ED
392	  #include "stm32l4xx_hal_rtc.h"
393	#endif /* HAL_RTC_MODULE_ENABL­ED */
394
395	#ifdef HAL_SAI_MODULE_ENABL­ED
396	  #include "stm32l4xx_hal_sai.h"
397	#endif /* HAL_SAI_MODULE_ENABL­ED */
398
399	#ifdef HAL_SD_MODULE_ENABLE­D
400	  #include "stm32l4xx_hal_sd.h"
401	#endif /* HAL_SD_MODULE_ENABLE­D */
402
403	#ifdef HAL_SMARTCARD_MODULE­_ENABLED
404	  #include "stm32l4xx_hal_smartc­ard.h"
405	#endif /* HAL_SMARTCARD_MODULE­_ENABLED */
406
407	#ifdef HAL_SMBUS_MODULE_ENA­BLED
408	  #include "stm32l4xx_hal_smbus.h"
409	#endif /* HAL_SMBUS_MODULE_ENA­BLED */
410
411	#ifdef HAL_SPI_MODULE_ENABL­ED
412	  #include "stm32l4xx_hal_spi.h"
413	#endif /* HAL_SPI_MODULE_ENABL­ED */
414
415	#ifdef HAL_SRAM_MODULE_ENAB­LED
416	  #include "stm32l4xx_hal_sram.h"
417	#endif /* HAL_SRAM_MODULE_ENAB­LED */
418
419	#ifdef HAL_SWPMI_MODULE_ENA­BLED
420	  #include "stm32l4xx_hal_swpmi.h"
421	#endif /* HAL_SWPMI_MODULE_ENA­BLED */
422
423	#ifdef HAL_TIM_MODULE_ENABL­ED
424	  #include "stm32l4xx_hal_tim.h"
425	#endif /* HAL_TIM_MODULE_ENABL­ED */
426
427	#ifdef HAL_TSC_MODULE_ENABL­ED
428	  #include "stm32l4xx_hal_tsc.h"
429	#endif /* HAL_TSC_MODULE_ENABL­ED */
430
431	#ifdef HAL_UART_MODULE_ENAB­LED
432	  #include "stm32l4xx_hal_uart.h"
433	#endif /* HAL_UART_MODULE_ENAB­LED */
434
435	#ifdef HAL_USART_MODULE_ENA­BLED
436	  #include "stm32l4xx_hal_usart.h"
437	#endif /* HAL_USART_MODULE_ENA­BLED */
438
439	#ifdef HAL_WWDG_MODULE_ENAB­LED
440	  #include "stm32l4xx_hal_wwdg.h"
441	#endif /* HAL_WWDG_MODULE_ENAB­LED */
442
443	/* Exported macro ------------------------------------------------------------*/
444	#ifdef  USE_FULL_ASSERT
445	/**
446	  * @brief  The assert_param macro is used for function's parameters check.
447	  * @param  expr: If expr is false, it calls assert_failed function
448	  *         which reports the name of the source file and the source
449	  *         line number of the call that failed.
450	  *         If expr is true, it returns no value.
451	  * @retval None
452	  */
453	  #define assert_param(expr) ((expr) ? (void)0U : assert_failed((uint8_t *)__FILE__, __LINE__))
454	/* Exported functions ------------------------------------------------------- */
455	  void assert_failed(uint8_t *file, uint32_t line);
456	#else
457	  #define assert_param(expr) ((void)0U)
458	#endif /* USE_FULL_ASSERT */
459
460	#ifdef __cplusplus
461	}
462	#endif
463
464	#endif /* STM32L4xx_HAL_CONF_H­ */
465
L476_USER_APP\UserApp\Application\Core\Inc\stm32l4xx_it.h
1	/**
2	  ******************************************************************************
3	  * @file    stm32l4xx_it.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains the headers of the interrupt handlers.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef STM32L4xx_IT_H
21	#define STM32L4xx_IT_H
22
23	/** @addtogroup USER_APP User App Example
24	  * @{
25	  */
26
27	/** @addtogroup USER_APP_COMMON Common
28	  * @{
29	  */
30
31	#ifdef __cplusplus
32	extern "C" {
33	#endif
34
35	/* Includes ------------------------------------------------------------------*/
36	/* Exported types ------------------------------------------------------------*/
37	/* Exported constants --------------------------------------------------------*/
38	/* Exported macro ------------------------------------------------------------*/
39	/* Exported functions ------------------------------------------------------- */
40
41	void NMI_Handler(void);
42	void HardFault_Handler(void);
43	void MemManage_Handler(void);
44	void BusFault_Handler(void);
45	void UsageFault_Handler(void);
46	void SVC_Handler(void);
47	void DebugMon_Handler(void);
48	void PendSV_Handler(void);
49	void SysTick_Handler(void);
50	void FLASH_IRQHandler(void);
51	void TAMP_STAMP_IRQHandle­r(void);
52
53	/**
54	  * @}
55	  */
56
57	/**
58	  * @}
59	  */
60
61	#ifdef __cplusplus
62	}
63	#endif
64
65	#endif /* STM32L4xx_IT_H */
66
L476_USER_APP\UserApp\Application\Core\Inc\test_protections.h
1	/**
2	  ******************************************************************************
3	  * @file    test_protections.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for Test Protections functionalities.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef TEST_PROTECTIONS_H
21	#define TEST_PROTECTIONS_H
22
23	#ifdef __cplusplus
24	extern "C" {
25	#endif
26
27	/* Includes ------------------------------------------------------------------*/
28	#include "stdint.h"
29
30	/* Exported macros -----------------------------------------------------------*/
31	/* SFU Redirect of RTC Tamper Event Callback*/
32	#define  CALLBACK_Antitamper(void) HAL_RTCEx_Tamper2Eve­ntCallback(RTC_HandleTypeDef *hrtc)
33
34	/* Exported functions ------------------------------------------------------- */
35	void     TEST_PROTECTIONS_Run­Menu(void);
36
37	#ifdef __cplusplus
38	}
39	#endif
40
41	#endif /* TEST_PROTECTIONS_H */
42
L476_USER_APP\UserApp\Application\Core\Inc\ymodem.h
1	/**
2	  ******************************************************************************
3	  * @file    ymodem.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for Ymodem functionalities.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef YMODEM_H_
21	#define YMODEM_H_
22
23	/** @addtogroup USER_APP User App Example
24	  * @{
25	  */
26
27	/** @addtogroup  FW_UPDATE Firmware Update Example
28	  * @{
29	  */
30	/* Compiler switches ---------------------------------------------------------*/
31	#ifndef MINICOM_YMODEM /* Avoid redefinition from app_sfu.h */
32	/* Uncomment the switch below if you are using Minicom (Linux) */
33	/* YMODEM protocol handled by Minicom instead of Teraterm: 128B packets instead of 1kB packets */
34	/* #define MINICOM_YMODEM */
35	#endif /* MINICOM_YMODEM */
36	/* Includes ------------------------------------------------------------------*/
37	/* Exported types ------------------------------------------------------------*/
38
39	typedef enum
40	{
41	  COM_OK       = 0x00U,  /*!< OK */
42	  COM_ERROR    = 0x01U,  /*!< Error */
43	  COM_ABORT    = 0x02U,  /*!< Abort */
44	  COM_TIMEOUT  = 0x03U,  /*!< Timeout */
45	  COM_DATA     = 0x04U,  /*!< Data */
46	  COM_LIMIT    = 0x05U   /*!< Limit*/
47	} COM_StatusTypeDef;     /*!< Comm status structures definition */
48
49	typedef struct
50	{
51	  HAL_StatusTypeDef(* Ymodem_HeaderPktRxCp­ltCallback)(uint32_t uFileSize);
52	  HAL_StatusTypeDef(* Ymodem_DataPktRxCplt­Callback)(uint8_t *pData, uint32_t uFlashDestination, uint32_t uSize);
53	} YMODEM_CallbacksType­Def;
54
55	/* Exported constants --------------------------------------------------------*/
56	/* Packet structure defines */
57	#ifndef MINICOM_YMODEM
58	/* Teraterm YMODEM */
59	#define PACKET_HEADER_SIZE      ((uint32_t)3U)    /*!<Header Size*/
60	#define PACKET_DATA_INDEX       ((uint32_t)4U)    /*!<Data Index*/
61	#define PACKET_START_INDEX      ((uint32_t)1U)    /*!<Start Index*/
62	#define PACKET_NUMBER_INDEX     ((uint32_t)2U)    /*!<Packet Number Index*/
63	#define PACKET_CNUMBER_INDEX­    ((uint32_t)3U)    /*!<Cnumber Index*/
64	#else
65	/* Minicom YMODEM */
66	#define PACKET_HEADER_SIZE      ((uint32_t)6U)    /*!<Header Size*/
67	#define PACKET_DATA_INDEX       ((uint32_t)7U)    /*!<Data Index*/
68	#define PACKET_START_INDEX      ((uint32_t)4U)    /*!<Start Index*/
69	#define PACKET_NUMBER_INDEX     ((uint32_t)5U)    /*!<Packet Number Index*/
70	#define PACKET_CNUMBER_INDEX­    ((uint32_t)6U)    /*!<Cnumber Index*/
71	#endif /* MINICOM_YMODEM */
72	#define PACKET_TRAILER_SIZE     ((uint32_t)2U)    /*!<Trailer Size*/
73	#define PACKET_OVERHEAD_SIZE­    (PACKET_HEADER_SIZE + PACKET_TRAILER_SIZE - 1U) /*!<Overhead Size*/
74	#define PACKET_SIZE             ((uint32_t)128U)  /*!<Packet Size*/
75	#define PACKET_1K_SIZE          ((uint32_t)1024U) /*!<Packet 1K Size*/
76
77	/* /-------- Packet in IAP memory ------------------------------------------\
78	 * | 0      |  1    |  2     |  3   |  4      | ... | n+4     | n+5  | n+6  |
79	 * |------------------------------------------------------------------------|
80	 * | unused | start | number | !num | data[0] | ... | data[n] | crc0 | crc1 |
81	 * \------------------------------------------------------------------------/
82	 * the first byte is left unused for memory alignment reasons                 */
83
84	#define FILE_NAME_LENGTH        ((uint32_t)64U)  /*!< File name length*/
85	#define FILE_SIZE_LENGTH        ((uint32_t)16U)  /*!< File size length*/
86
87	#define SOH                     ((uint8_t)0x01U)  /*!< start of 128-byte data packet */
88	#define STX                     ((uint8_t)0x02U)  /*!< start of 1024-byte data packet */
89	#define EOT                     ((uint8_t)0x04U)  /*!< end of transmission */
90	#define ACK                     ((uint8_t)0x06U)  /*!< acknowledge */
91	#define NAK                     ((uint8_t)0x15U)  /*!< negative acknowledge */
92	#define CA                      ((uint8_t)0x18U)  /*!< two of these in succession aborts transfer */
93	#define CRC16                   ((uint8_t)0x43U)  /*!< 'C' == 0x43, request 16-bit CRC */
94	#define RB                      ((uint8_t)0x72U)  /*!< Startup sequence */
95	#define NEGATIVE_BYTE           ((uint8_t)0xFFU)  /*!< Negative Byte*/
96
97	#define ABORT1                  ((uint8_t)0x41U)  /* 'A' == 0x41, abort by user */
98	#define ABORT2                  ((uint8_t)0x61U)  /* 'a' == 0x61, abort by user */
99
100	#define NAK_TIMEOUT             ((uint32_t)0x100000U)  /*!< NAK Timeout*/
101	#define DOWNLOAD_TIMEOUT        ((uint32_t)1000U) /* One second retry delay */
102	#define MAX_ERRORS              ((uint32_t)5U)    /*!< Maximum number of retry*/
103
104	/* Exported functions ------------------------------------------------------- */
105	void Ymodem_Init(void);
106	COM_StatusTypeDef Ymodem_Receive(uint32_t *puSize, uint32_t uFlashDestination, YMODEM_CallbacksType­Def *appCb);
107
108	/**
109	  * @}
110	  */
111
112	/**
113	  * @}
114	  */
115
116	#endif  /* YMODEM_H_ */
117
L476_USER_APP\UserApp\Application\Core\Src\com.c
1	/**
2	  ******************************************************************************
3	  * @file    com.c
4	  * @author  MCD Application Team
5	  * @brief   COM module.
6	  *          This file provides set of firmware functions to manage Com
7	  *          functionalities.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Includes ------------------------------------------------------------------*/
22	#include "com.h"
23	#include "stm32l4xx_hal.h"
24	#if defined(__ICCARM__)
25	#include <LowLevelIOInterface.h>
26	#endif /* __ICCARM__ */
27
28
29
30	/** @addtogroup USER_APP User App Example
31	  * @{
32	  */
33
34	/** @addtogroup USER_APP_COMMON Common
35	  * @{
36	  */
37
38	/** @defgroup  COM_Private_Defines Private Defines
39	  * @{
40	  */
41
42	#if defined(__ICCARM__)
43	/* New definition from EWARM V9, compatible with EWARM8 */
44	int iar_fputc(int ch);
45	#define PUTCHAR_PROTOTYPE int iar_fputc(int ch)
46	#elif defined(__CC_ARM) || defined(__ARMCC_VERSION)
47	#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
48	#elif defined(__GNUC__)
49	#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
50	#endif /* __ICCARM__ */
51	/**
52	  * @}
53	  */
54
55	/** @defgroup  COM_Private_Variable­s Exported Variables
56	  * @{
57	  */
58
59	static UART_HandleTypeDef   UartHandle; /*!< Uart Handler*/
60
61	/**
62	  * @}
63	  */
64
65	/** @defgroup  COM_Exported_Functio­ns Exported Functions
66	  * @{
67	  */
68
69	/** @defgroup  COM_Initialization_F­unctions Initialization Functions
70	  * @{
71	  */
72
73	/**
74	  * @brief  Initialize COM module.
75	  * @param  None.
76	  * @retval HAL Status.
77	  */
78	HAL_StatusTypeDef  COM_Init(void)
79	{
80	#if defined(__GNUC__)
81	  setvbuf(stdout, NULL, _IONBF, 0);
82	#endif /* __GNUC__ */
83
84	  /* USART resources configuration (Clock, GPIO pins and USART registers) ----*/
85	  /* USART configured as follow:
86	  - BaudRate = 115200 baud
87	  - Word Length = 8 Bits
88	  - One Stop Bit
89	  - No parity
90	  - Hardware flow control disabled (RTS and CTS signals)
91	  - Receive and transmit enabled
92	  */
93	  UartHandle.Instance = COM_UART;
94	  UartHandle.Init.BaudRate = 115200U;
95	  UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
96	  UartHandle.Init.StopBits = UART_STOPBITS_1;
97	  UartHandle.Init.Parity = UART_PARITY_NONE;
98	  UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;
99	  UartHandle.Init.Mode = UART_MODE_RX | UART_MODE_TX;
100	  UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_RXOV­ERRUNDISABLE_INIT;
101	  UartHandle.AdvancedInit.OverrunDisable = UART_ADVFEATURE_OVER­RUN_DISABLE;
102
103	  return HAL_UART_Init(&UartHandle);
104	}
105
106	/**
107	  * @brief  DeInitialize COM module.
108	  * @retval None.
109	  * @retval HAL Status.
110	  */
111	HAL_StatusTypeDef  COM_DeInit(void)
112	{
113	  /*
114	  * ADD SRC CODE HERE
115	  * ...
116	  */
117	  return HAL_OK;
118	}
119
120	/**
121	  * @brief  UART MSP Init.
122	  * @param  huart: UART handler pointer.
123	  * @retval None.
124	  */
125	void HAL_UART_MspInit(UART_HandleTypeDef *huart)
126	{
127
128	  GPIO_InitTypeDef GPIO_InitStruct;
129	  if (huart->Instance == COM_UART)
130	  {
131	    /* Peripheral Clock Enable */
132	    COM_UART_CLK_ENABLE();
133
134	    /* GPIO Ports Clock Enable */
135	    COM_UART_TX_GPIO_CLK­_ENABLE();
136	    COM_UART_RX_GPIO_CLK­_ENABLE();
137
138	    /*Configure GPIO pins : COM_UART_TX_Pin  */
139	    GPIO_InitStruct.Pin = COM_UART_TX_PIN;
140	    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
141	    GPIO_InitStruct.Pull = GPIO_NOPULL;
142	    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY­_HIGH;
143	    GPIO_InitStruct.Alternate = COM_UART_TX_AF;
144	    HAL_GPIO_Init(COM_UART_TX_GPIO_POR­T, &GPIO_InitStruct);
145
146	    /*Configure GPIO pins : COM_UART_RX_Pin  */
147	    GPIO_InitStruct.Pin = COM_UART_RX_PIN;
148	    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
149	    GPIO_InitStruct.Pull = GPIO_NOPULL;
150	    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY­_HIGH;
151	    GPIO_InitStruct.Alternate = COM_UART_RX_AF;
152	    HAL_GPIO_Init(COM_UART_RX_GPIO_POR­T, &GPIO_InitStruct);
153
154	  }
155
156	}
157
158	/**
159	  * @brief  UART MSP DeInit.
160	  * @param  huart: UART handler pointer.
161	  * @retval None.
162	  */
163	void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
164	{
165	  if (huart->Instance == COM_UART)
166	  {
167	    /* Peripheral clock disable */
168	    COM_UART_CLK_DISABLE­();
169
170	    HAL_GPIO_DeInit(COM_UART_TX_GPIO_POR­T, COM_UART_TX_PIN);
171	    HAL_GPIO_DeInit(COM_UART_RX_GPIO_POR­T, COM_UART_RX_PIN);
172	  }
173	}
174
175
176	/**
177	  * @}
178	  */
179
180	/** @defgroup  COM_Control_Function­s Control Functions
181	  * @{
182	  */
183
184	/**
185	  * @brief Transmit Data.
186	  * @param uDataLength: Data pointer to the Data to transmit.
187	  * @param uTimeout: Timeout duration.
188	  * @retval Status of the Transmit operation.
189	  */
190	HAL_StatusTypeDef COM_Transmit(uint8_t *Data, uint16_t uDataLength, uint32_t uTimeout)
191	{
192	  return HAL_UART_Transmit(&UartHandle, (uint8_t *)Data, uDataLength, uTimeout);
193	}
194
195	/**
196	  * @brief Receive Data.
197	  * @param uDataLength: Data pointer to the Data to receive.
198	  * @param uTimeout: Timeout duration.
199	  * @retval Status of the Receive operation.
200	  */
201	HAL_StatusTypeDef COM_Receive(uint8_t *Data, uint16_t uDataLength, uint32_t uTimeout)
202	{
203	  return HAL_UART_Receive(&UartHandle, (uint8_t *)Data, uDataLength, uTimeout);
204	}
205
206	/**
207	  * @brief  Flush COM Input.
208	  * @param None.
209	  * @retval HAL_Status.
210	  */
211	HAL_StatusTypeDef COM_Flush(void)
212	{
213	  /* Clean the input path */
214	  __HAL_UART_FLUSH_DRR­EGISTER(&UartHandle);
215	  return HAL_OK;
216	}
217
218	/**
219	  * @}
220	  */
221
222	/** @addtogroup  COM_Private_Function­s
223	  * @{
224	  */
225
226	/**
227	  * @}
228	  */
229
230	/** @defgroup COM_Callback_Functio­ns Callback Functions
231	  * @{
232	  */
233
234	/**
235	  * @brief  Retargets the C library __write function to the IAR function iar_fputc.
236	  * @param  file: file descriptor.
237	  * @param  ptr: pointer to the buffer where the data is stored.
238	  * @param  len: length of the data to write in bytes.
239	  * @retval length of the written data in bytes.
240	  */
241	#if defined(__ICCARM__)
242	size_t __write(int file, unsigned char const *ptr, size_t len)
243	{
244	  size_t idx;
245	  unsigned char const *pdata = ptr;
246
247	  for (idx = 0; idx < len; idx++)
248	  {
249	    iar_fputc((int)*pdata);
250	    pdata++;
251	  }
252	  return len;
253	}
254	#endif /* __ICCARM__ */
255
256	/**
257	  * @brief  Retargets the C library printf function to the USART.
258	  * @param  None
259	  * @retval ch
260	  */
261	PUTCHAR_PROTOTYPE
262	{
263	  /* Place your implementation of fputc here */
264	  /* e.g. write a character to the USART1 and Loop until the end of transmission */
265	  HAL_UART_Transmit(&UartHandle, (uint8_t *)&ch, 1U, 0xFFFFU);
266
267	  return ch;
268	}
269
270	/**
271	  * @brief  Ymodem Header Packet Transfer completed callback.
272	  * @param  FileSize Dimension of the file that will be received.
273	  * @retval None
274	  */
275	__weak HAL_StatusTypeDef Ymodem_HeaderPktRxCp­ltCallback(uint32_t uFileSize)
276	{
277
278	  /* NOTE : This function should not be modified, when the callback is needed,
279	            the Ymodem_HeaderPktRxCp­ltCallback could be implemented in the user file
280	   */
281	  return HAL_OK;
282	}
283
284	/**
285	  * @brief  Ymodem Data Packet Transfer completed callback.
286	  * @param  pData Pointer to the buffer.
287	  * @param  Size Packet dimension.
288	  * @retval None
289	  */
290	__weak HAL_StatusTypeDef Ymodem_DataPktRxCplt­Callback(uint8_t *pData, uint32_t uFlashDestination, uint32_t uSize)
291	{
292
293	  /* NOTE : This function should not be modified, when the callback is needed,
294	            the Ymodem_DataPktRxCplt­Callback could be implemented in the user file
295	   */
296	  return HAL_OK;
297	}
298
299	/**
300	  * @}
301	  */
302
303	/**
304	  * @}
305	  */
306
307	/**
308	  * @}
309	  */
310
L476_USER_APP\UserApp\Application\Core\Src\common.c
1	/**
2	  ******************************************************************************
3	  * @file    common.c
4	  * @author  MCD Application Team
5	  * @brief   COMMON module.
6	  *          This file provides set of firmware functions to manage Common
7	  *          functionalities.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/** @addtogroup USER_APP User App Example
22	  * @{
23	  */
24	/** @addtogroup USER_APP_COMMON Common
25	  * @{
26	  */
27	/* Includes ------------------------------------------------------------------*/
28	#include "common.h"
29	#include "main.h"
30
31	/* Private typedef -----------------------------------------------------------*/
32	/* Private define ------------------------------------------------------------*/
33	/* Private macro -------------------------------------------------------------*/
34	/* Private variables ---------------------------------------------------------*/
35	/* Private function prototypes -----------------------------------------------*/
36	/* Private functions ---------------------------------------------------------*/
37	/**
38	  * @brief  Convert a string to an integer
39	  * @param  pInputStr: The string to be converted
40	  * @param  pIntNum: The integer value
41	  * @retval 1: Correct
42	  *         0: Error
43	  */
44	uint32_t Str2Int(uint8_t *pInputStr, uint32_t *pIntNum)
45	{
46	  uint32_t i = 0U;
47	  uint32_t res = 0U;
48	  uint32_t val = 0U;
49
50	  if ((pInputStr[0U] == '0') && ((pInputStr[1U] == 'x') || (pInputStr[1U] == 'X')))
51	  {
52	    i = 2U;
53	    while ((i < 11U) && (pInputStr[i] != '\0'))
54	    {
55	      if (ISVALIDHEX(pInputStr[i]))
56	      {
57	        val = (val << 4U) + CONVERTHEX(pInputStr[i]);
58	      }
59	      else
60	      {
61	        /* Res = 0, Invalid input */
62	        break;
63	      }
64	      i++;
65	    }
66
67	    /* valid result */
68	    if (pInputStr[i] == '\0')
69	    {
70	      *pIntNum = val;
71	      res = 1U;
72	    }
73	  }
74	  else /* max 10-digit decimal input */
75	  {
76	    while ((i < 11U) && (res != 1U))
77	    {
78	      if (pInputStr[i] == '\0')
79	      {
80	        *pIntNum = val;
81	        /* return 1 */
82	        res = 1U;
83	      }
84	      else if (((pInputStr[i] == 'k') || (pInputStr[i] == 'K')) && (i > 0U))
85	      {
86	        val = val << 10U;
87	        *pIntNum = val;
88	        res = 1U;
89	      }
90	      else if (((pInputStr[i] == 'm') || (pInputStr[i] == 'M')) && (i > 0U))
91	      {
92	        val = val << 20U;
93	        *pIntNum = val;
94	        res = 1U;
95	      }
96	      else if (ISVALIDDEC(pInputStr[i]))
97	      {
98	        val = val * 10U + CONVERTDEC(pInputStr[i]);
99	      }
100	      else
101	      {
102	        /* return 0, Invalid input */
103	        res = 0U;
104	        break;
105	      }
106	      i++;
107	    }
108	  }
109
110	  return res;
111	}
112
113
114	/**
115	  * @brief  Transmit a byte to the HyperTerminal
116	  * @param  param The byte to be sent
117	  * @retval HAL_StatusTypeDef HAL_OK if OK
118	  */
119	HAL_StatusTypeDef Serial_PutByte(uint8_t uParam)
120	{
121	  return COM_Transmit(&uParam, 1U, TX_TIMEOUT);
122	}
123	/**
124	  * @}
125	  */
126
127	/**
128	  * @}
129	  */
130
L476_USER_APP\UserApp\Application\Core\Src\flash_if.c
1	/**
2	  ******************************************************************************
3	  * @file    flash_if.c
4	  * @author  MCD Application Team
5	  * @brief   FLASH Interface module.
6	  *          This file provides set of firmware functions to manage Flash
7	  *          Interface functionalities.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/** @addtogroup USER_APP User App Example
22	  * @{
23	  */
24
25	/** @addtogroup USER_APP_COMMON Common
26	  * @{
27	  */
28	/* Includes ------------------------------------------------------------------*/
29	#include "flash_if.h"
30	#include "string.h"
31	#include <stdio.h>
32
33	/* Uncomment the line below if you want some debug logs */
34	#define FLASH_IF_DBG
35	#ifdef FLASH_IF_DBG
36	#define FLASH_IF_TRACE printf
37	#else
38	#define FLASH_IF_TRACE(...)
39	#endif /* FLASH_IF_DBG */
40
41
42	/* Private typedef -----------------------------------------------------------*/
43	/* Private define ------------------------------------------------------------*/
44	#define NB_PAGE_SECTOR_PER_E­RASE  2U    /*!< Nb page erased per erase */
45	#define EXTERNAL_FLASH_ADDRE­SS    0x90000000U
46
47
48	/* Private macro -------------------------------------------------------------*/
49	/* Private variables ---------------------------------------------------------*/
50
51
52	/* Private function prototypes -----------------------------------------------*/
53	static uint32_t GetPage(uint32_t uAddr);
54	static uint32_t GetBank(uint32_t uAddr);
55	static uint32_t GetBankAddr(uint32_t bank);
56	static HAL_StatusTypeDef FLASH_INT_If_Clear_E­rror(void);
57
58	/* Public functions : wrapper ---------------------------------------------------------*/
59
60	/**
61	  * @brief  Initialize internal and external flash interface (OSPI/QSPI)
62	  * @param  none
63	  * @retval HAL status.
64	  */
65	HAL_StatusTypeDef FLASH_If_Init(void)
66	{
67	  HAL_StatusTypeDef e_ret_status = HAL_OK;
68
69	  e_ret_status = FLASH_INT_Init();
70	  if (e_ret_status == HAL_OK)
71	  {
72	    e_ret_status = FLASH_EXT_Init();
73	  }
74	  return e_ret_status;
75	}
76	/**
77	  * @brief  Depending on start address, this function will call internal or external (OSPI/QSPI) flash driver
78	  * @param  pStart: flash address to be erased
79	  * @param  uLength: number of bytes
80	  * @retval HAL status.
81	  */
82	HAL_StatusTypeDef FLASH_If_Erase_Size(void *pStart, uint32_t uLength)
83	{
84	  /* Check Flash start address */
85	  if ((uint32_t) pStart < EXTERNAL_FLASH_ADDRE­SS)
86	  {
87	    return FLASH_INT_If_Erase_S­ize(pStart, uLength);
88	  }
89	  else
90	  {
91	    return FLASH_EXT_If_Erase_S­ize(pStart, uLength);
92	  }
93	}
94
95	/**
96	  * @brief  Depending on destination address, this function will call internal or external (OSPI/QSPI) flash driver
97	  * @param  pDestination: flash address to write
98	  * @param  pSource: pointer on buffer with data to write
99	  * @param  uLength: number of bytes
100	  * @retval HAL Status.
101	  */
102	HAL_StatusTypeDef FLASH_If_Write(void *pDestination, const void *pSource, uint32_t uLength)
103	{
104	  /* Check Flash destination address */
105	  if ((uint32_t) pDestination < EXTERNAL_FLASH_ADDRE­SS)
106	  {
107	    return FLASH_INT_If_Write(pDestination, pSource, uLength);
108	  }
109	  else
110	  {
111	    return FLASH_EXT_If_Write(pDestination, pSource, uLength);
112	  }
113	}
114
115	/**
116	  * @brief  Depending on destination address, this function will call internal or external (OSPI/QSPI) flash driver
117	  * @brief  Depending on source address, this function will call internal or external (OSPI/QSPI) flash driver
118	  * @param  pDestination: pointer on buffer to store data
119	  * @param  pSource: flash address to read
120	  * @param  uLength: number of bytes
121	  * @retval HAL Status.
122	  */
123	HAL_StatusTypeDef FLASH_If_Read(void *pDestination, const void *pSource, uint32_t uLength)
124	{
125	  /* Check Flash source address */
126	  if ((uint32_t) pSource < EXTERNAL_FLASH_ADDRE­SS)
127	  {
128	    return FLASH_INT_If_Read(pDestination, pSource, uLength);
129	  }
130	  else
131	  {
132	    return FLASH_EXT_If_Read(pDestination, pSource, uLength);
133	  }
134	}
135
136	/* Public functions : internal flash --------------------------------------------------------- */
137	/**
138	  * @brief  This function initialize the internal flash interface if required
139	  * @param  none
140	  * @retval HAL status.
141	  */
142	HAL_StatusTypeDef FLASH_INT_Init(void)
143	{
144	  return HAL_OK;
145	}
146
147	/**
148	  * @brief  This function does an erase of n (depends on Length) pages in user flash area
149	  * @param  pStart: Start of user flash area
150	  * @param  uLength: number of bytes.
151	  * @retval HAL status.
152	  */
153	HAL_StatusTypeDef FLASH_INT_If_Erase_S­ize(void *pStart, uint32_t uLength)
154	{
155	  uint32_t page_error = 0U;
156	  uint32_t uStart = (uint32_t)pStart;
157	  FLASH_EraseInitTypeD­ef x_erase_init;
158	  HAL_StatusTypeDef e_ret_status = HAL_ERROR;
159	  uint32_t first_page = 0U;
160	  uint32_t nb_pages = 0U;
161	  uint32_t chunk_nb_pages;
162	  uint32_t erase_command = 0U;
163	  uint32_t bank_number = 0U;
164
165	  /* Clear error flags raised during previous operation */
166	  e_ret_status = FLASH_INT_If_Clear_E­rror();
167
168	  if (e_ret_status == HAL_OK)
169	  {
170	    /* Unlock the Flash to enable the flash control register access *************/
171	    if (HAL_FLASH_Unlock() == HAL_OK)
172	    {
173	      do
174	      {
175	        /* Get the 1st page to erase */
176	        first_page = GetPage(uStart);
177	        bank_number = GetBank(uStart);
178	        if (GetBank(uStart + uLength - 1U) == bank_number)
179	        {
180	          /* Get the number of pages to erase from 1st page */
181	          nb_pages = GetPage(uStart + uLength - 1U) - first_page + 1U;
182
183	          /* Fill EraseInit structure*/
184	          x_erase_init.TypeErase = FLASH_TYPEERASE_PAGE­S;
185	          x_erase_init.Banks = bank_number;
186
187	          /* Erase flash per NB_PAGE_SECTOR_PER_E­RASE to avoid watch-dog */
188	          do
189	          {
190	            chunk_nb_pages = (nb_pages >= NB_PAGE_SECTOR_PER_E­RASE) ? NB_PAGE_SECTOR_PER_E­RASE : nb_pages;
191	            x_erase_init.Page = first_page;
192	            x_erase_init.NbPages = chunk_nb_pages;
193	            first_page += chunk_nb_pages;
194	            nb_pages -= chunk_nb_pages;
195	            if (HAL_FLASHEx_Erase(&x_erase_init, &page_error) != HAL_OK)
196	            {
197	              HAL_FLASH_GetError();
198	              e_ret_status = HAL_ERROR;
199	            }
200	            /* Refresh Watchdog */
201	            WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
202	          } while (nb_pages > 0);
203	          erase_command = 1U;
204	        }
205	        else
206	        {
207	          uint32_t startbank2 = GetBankAddr(FLASH_BANK_2);
208	          nb_pages = GetPage(startbank2 - 1U) - first_page + 1U;
209	          x_erase_init.TypeErase   = FLASH_TYPEERASE_PAGE­S;
210	          x_erase_init.Banks       = bank_number;
211	          uLength = uLength  - (startbank2 - uStart);
212	          uStart = startbank2;
213
214	          /* Erase flash per NB_PAGE_SECTOR_PER_E­RASE to avoid watch-dog */
215	          do
216	          {
217	            chunk_nb_pages = (nb_pages >= NB_PAGE_SECTOR_PER_E­RASE) ? NB_PAGE_SECTOR_PER_E­RASE : nb_pages;
218	            x_erase_init.Page = first_page;
219	            x_erase_init.NbPages = chunk_nb_pages;
220	            first_page += chunk_nb_pages;
221	            nb_pages -= chunk_nb_pages;
222	            if (HAL_FLASHEx_Erase(&x_erase_init, &page_error) != HAL_OK)
223	            {
224	              HAL_FLASH_GetError();
225	              e_ret_status = HAL_ERROR;
226	            }
227	            /* Refresh Watchdog */
228	            WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
229	          } while (nb_pages > 0);
230	        }
231	      } while (erase_command == 0);
232	      /* Lock the Flash to disable the flash control register access (recommended
233	      to protect the FLASH memory against possible unwanted operation) *********/
234	      HAL_FLASH_Lock();
235
236	    }
237	    else
238	    {
239	      e_ret_status = HAL_ERROR;
240	    }
241	  }
242
243	  return e_ret_status;
244	}
245
246	/**
247	  * @brief  This function writes a data buffer in flash (data are 32-bit aligned).
248	  * @note   After writing data buffer, the flash content is checked.
249	  * @param  pDestination: Start address for target location. It has to be 8 bytes aligned.
250	  * @param  pSource: pointer on buffer with data to write
251	  * @param  uLength: Length of data buffer in bytes. It has to be 8 bytes aligned.
252	  * @retval HAL Status.
253	  */
254	HAL_StatusTypeDef FLASH_INT_If_Write(void *pDestination, const void *pSource, uint32_t uLength)
255	{
256	  HAL_StatusTypeDef e_ret_status = HAL_ERROR;
257	  uint32_t pdata = (uint32_t)pSource;
258
259	  /* Clear error flags raised during previous operation */
260	  e_ret_status = FLASH_INT_If_Clear_E­rror();
261
262	  if (e_ret_status == HAL_OK)
263	  {
264	    /* Unlock the Flash to enable the flash control register access *************/
265	    if (HAL_FLASH_Unlock() != HAL_OK)
266	    {
267	      return HAL_ERROR;
268
269	    }
270	    else
271	    {
272	      /* DataLength must be a multiple of 64 bit */
273	      for (uint32_t i = 0U; i < uLength; i += 8U)
274	      {
275	        /* Device voltage range supposed to be [2.7V to 3.6V], the operation will
276	        be done by word */
277	        if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DO­UBLEWORD, (uint32_t)pDestination,  *((uint64_t *)(pdata + i)))
278	            == HAL_OK)
279	        {
280	          /* Check the written value */
281	          if (*(uint64_t *)pDestination != *(uint64_t *)(pdata + i))
282	          {
283	            /* Flash content doesn't match SRAM content */
284	            e_ret_status = HAL_ERROR;
285	            break;
286	          }
287	          /* Increment FLASH Destination address */
288	          pDestination = (void *)((uint32_t)pDestination + 8U);
289	        }
290	        else
291	        {
292	          /* Error occurred while writing data in Flash memory */
293	          e_ret_status = HAL_ERROR;
294	          break;
295	        }
296	      }
297	      /* Lock the Flash to disable the flash control register access (recommended
298	      to protect the FLASH memory against possible unwanted operation) *********/
299	      HAL_FLASH_Lock();
300	    }
301	  }
302	  return e_ret_status;
303	}
304
305	/**
306	  * @brief  This function reads flash
307	  * @param  pDestination: Start address for target location
308	  * @param  pSource: flash address to read
309	  * @param  uLength: number of bytes
310	  * @retval HAL Status.
311	  */
312	HAL_StatusTypeDef FLASH_INT_If_Read(void *pDestination, const void *pSource, uint32_t uLength)
313	{
314	  memcpy(pDestination, pSource, uLength);
315	  return HAL_OK;
316	}
317
318	/* Public functions : external flash ---------------------------------------------------------*/
319
320	HAL_StatusTypeDef FLASH_EXT_Init(void)
321	{
322	  return HAL_OK;
323	}
324
325	/* No external flash available on this product
326	   ==> return SFU_ERROR */
327
328	HAL_StatusTypeDef FLASH_EXT_If_Erase_S­ize(void *pStart, uint32_t uLength)
329	{
330	  return HAL_ERROR;
331	}
332
333	HAL_StatusTypeDef FLASH_EXT_If_Write(void  *pDestination, const void *pSource, uint32_t uLength)
334	{
335	  return HAL_ERROR;
336	}
337
338	HAL_StatusTypeDef FLASH_EXT_If_Read(void *pDestination, const void *pSource, uint32_t uLength)
339	{
340	  return HAL_ERROR;
341	}
342
343	/* Private functions ---------------------------------------------------------*/
344	/**
345	  * @brief  Clear error flags raised during previous operation
346	  * @param  None
347	  * @retval HAL Status.
348	  */
349	HAL_StatusTypeDef FLASH_INT_If_Clear_E­rror(void)
350	{
351	  HAL_StatusTypeDef ret = HAL_ERROR;
352
353	  /* Unlock the Program memory */
354	  if (HAL_FLASH_Unlock() == HAL_OK)
355	  {
356
357	    /* Clear all FLASH flags */
358	    __HAL_FLASH_CLEAR_FL­AG(FLASH_FLAG_ALL_ERROR­S);
359	    /* Unlock the Program memory */
360	    if (HAL_FLASH_Lock() == HAL_OK)
361	    {
362	      ret = HAL_OK;
363	    }
364	#ifdef FLASH_IF_DBG
365	    else
366	    {
367	      FLASH_IF_TRACE("[FLASH_IF] Lock failure\r\n");
368	    }
369	#endif /* FLASH_IF_DBG */
370	  }
371	#ifdef FLASH_IF_DBG
372	  else
373	  {
374	    FLASH_IF_TRACE("[FLASH_IF] Unlock failure\r\n");
375	  }
376	#endif /* FLASH_IF_DBG */
377	  return ret;
378	}
379
380	/**
381	  * @brief  Gets the page of a given address
382	  * @param  uAddr: Address of the FLASH Memory
383	  * @retval The page of a given address
384	  */
385	static uint32_t GetPage(uint32_t uAddr)
386	{
387	  uint32_t page = 0U;
388
389	  if (uAddr < (FLASH_BASE + (FLASH_BANK_SIZE)))
390	  {
391	    /* Bank 1 */
392	    page = (uAddr - FLASH_BASE) / FLASH_PAGE_SIZE;
393	  }
394	  else
395	  {
396	    /* Bank 2 */
397	    page = (uAddr - (FLASH_BASE + (FLASH_BANK_SIZE))) / FLASH_PAGE_SIZE;
398	  }
399
400	  return page;
401	}
402	/**
403	  * @brief  Gets the bank of a given address
404	  * @param  uAddr: Address of the FLASH Memory
405	  * @retval The bank of a given address
406	  */
407	static uint32_t GetBank(uint32_t uAddr)
408	{
409	  uint32_t bank = 0U;
410
411	  if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MOD­E) == 0U)
412	  {
413	    /* No Bank swap */
414	    if (uAddr < (FLASH_BASE + (FLASH_BANK_SIZE)))
415	    {
416	      bank = FLASH_BANK_1;
417	    }
418	    else
419	    {
420	      bank = FLASH_BANK_2;
421	    }
422	  }
423	  else
424	  {
425	    /* Bank swap */
426	    if (uAddr < (FLASH_BASE + (FLASH_BANK_SIZE)))
427	    {
428	      bank = FLASH_BANK_2;
429	    }
430	    else
431	    {
432	      bank = FLASH_BANK_1;
433	    }
434	  }
435
436	  return bank;
437	}
438
439
440	/**
441	  * @brief  Gets the address of a bank
442	  * @param  Bank: Bank ID
443	  * @retval Address of the bank
444	  */
445	static uint32_t GetBankAddr(uint32_t Bank)
446	{
447	  if (Bank == FLASH_BANK_2)
448	  {
449	    return  FLASH_BASE + (FLASH_BANK_SIZE);
450	  }
451	  else
452	  {
453	    return FLASH_BASE;
454	  }
455	}
456
457	/**
458	  * @}
459	  */
460
461	/**
462	  * @}
463	  */
464
L476_USER_APP\UserApp\Application\Core\Src\fw_update_app.c
1	/**
2	  ******************************************************************************
3	  * @file    fw_update_app.c
4	  * @author  MCD Application Team
5	  * @brief   Firmware Update module.
6	  *          This file provides set of firmware functions to manage Firmware
7	  *          Update functionalities.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Includes ------------------------------------------------------------------*/
22
23	#include "se_def.h"
24	#include "com.h"
25	#include "common.h"
26	#include "flash_if.h"
27	#include "stm32l4xx_hal.h"
28	#include "stm32l4xx_nucleo.h"
29	#include "fw_update_app.h"
30	#include "se_interface_applica­tion.h"
31	#include "sfu_fwimg_regions.h"
32	#include "sfu_app_new_image.h"
33	#include "string.h"
34	#if defined(__CC_ARM) || defined(__ARMCC_VERSION)
35	#include "mapping_fwimg.h"
36	#include "mapping_sbsfu.h"
37	#elif defined (__ICCARM__) || defined(__GNUC__)
38	#include "mapping_export.h"
39	#endif /* __CC_ARM || __ARMCC_VERSION */
40	#include "ymodem.h"
41
42	/* Private defines -----------------------------------------------------------*/
43
44	#define ALL_SLOTS 255U                   /*!< Validate all new firmware installed in a single request */
45	/* Global variables ----------------------------------------------------------*/
46
47	#if !defined(EXTERNAL_LOADER)
48	static uint32_t m_uFileSizeYmodem = 0U;  /*!< Ymodem File size*/
49	static uint32_t m_uNbrBlocksYmodem = 0U; /*!< Ymodem Number of blocks*/
50	static uint32_t m_uPacketsReceived = 0U; /*!< Ymodem packets received*/
51
52	#ifdef MINICOM_YMODEM
53	/*
54	 * With Minicom Ymodem, the data offset is not aligned because PACKET_DATA_INDEX is 7
55	 * So we cannot write in FLASH with pData as source, we need a copy in an aligned buffer
56	 */
57	/* With Minicom YMODEM each packet carries 128 bytes of data */
58	static uint8_t alignedBuffer[PACKET_SIZE] __attribute__((aligned(8)));
59	#endif /* MINICOM_YMODEM */
60	#endif /* !EXTERNAL_LOADER */
61
62	/* Private function prototypes -----------------------------------------------*/
63
64	#if !defined(EXTERNAL_LOADER)
65	static HAL_StatusTypeDef FW_UPDATE_DownloadNe­wFirmware(SFU_FwImageFlashType­Def *pFwImageDwlArea);
66	#endif /* !EXTERNAL_LOADER */
67
68	/* Functions Definition ------------------------------------------------------*/
69
70	/**
71	  * @brief  Run FW Update process.
72	  * @param  None
73	  * @retval HAL Status.
74	  */
75	#if defined(EXTERNAL_LOADER)
76	void FW_UPDATE_Run(void)
77	{
78	  /* Print Firmware Update welcome message */
79	  printf("\r\n================ New Fw Download =========================\r\n\n");
80
81	  /* Standalone loader communication : execution requested */
82	  STANDALONE_LOADER_ST­ATE = STANDALONE_LOADER_DW­L_REQ;
83
84	  NVIC_SystemReset();
85	}
86
87	#else
88	void FW_UPDATE_Run(void)
89	{
90	  HAL_StatusTypeDef ret = HAL_ERROR;
91	  uint8_t  fw_header_dwl_slot[SE_FW_HEADER_TOT_LEN­];
92	  SFU_FwImageFlashType­Def fw_image_dwl_area;
93
94	  /* Print Firmware Update welcome message */
95	  printf("\r\n================ New Fw Download =========================\r\n\n");
96
97	  /* Get Info about the download area */
98	  SFU_APP_GetDownloadA­reaInfo(SLOT_DWL_1, &fw_image_dwl_area);
99
100	  /* Download new firmware image*/
101	  ret = FW_UPDATE_DownloadNe­wFirmware(&fw_image_dwl_area);
102
103	  if (HAL_OK == ret)
104	  {
105	    /* Read header in dwl slot */
106	    (void)FLASH_If_Read(fw_header_dwl_slot, (void *) fw_image_dwl_area.DownloadAddr, SE_FW_HEADER_TOT_LEN­);
107
108	    /* Ask for installation at next reset */
109	    (void)SFU_APP_InstallAtNex­tReset((uint8_t *) fw_header_dwl_slot);
110
111	    /* System Reboot*/
112	    printf("  -- Image correctly downloaded - reboot\r\n\n");
113	    HAL_Delay(1000U);
114	    NVIC_SystemReset();
115	  }
116
117	  if (ret != HAL_OK)
118	  {
119	    printf("  -- !!Operation failed!! \r\n\n");
120	  }
121	}
122	#endif /* EXTERNAL_LOADER */
123
124
125	#if defined(EXTERNAL_LOADER)
126	/**
127	  * @brief  Run Multiple FW Update process.
128	  * @param  None
129	  * @retval None.
130	  */
131	void FW_UPDATE_MULTIPLE_R­unMenu(void)
132	{
133	  printf("  Feature not supported ! \r\n");
134	}
135
136	#else
137	/**
138	  * @brief  Print Multiple FW Update menu.
139	  * @param  None
140	  * @retval HAL Status.
141	  */
142	static void FW_UPDATE_MULTIPLE_P­rintMenu(void)
143	{
144	  /* Print Multiple Download menu */
145	  printf("\r\n============= Multiple Download Menu ================\r\n\n");
146	  printf("  Download firmware in DWL_SLOT #1 ---------------------- 1\r\n\n");
147	  printf("  Download firmware in DWL_SLOT #2 ---------------------- 2\r\n\n");
148	  printf("  Download firmware in DWL_SLOT #3 ---------------------- 3\r\n\n");
149	  printf("  Start installation ------------------------------------ 4\r\n\n");
150	  printf("  Previous Menu ----------------------------------------- x\r\n\n");
151	  printf("  Selection :\r\n\n");
152	}
153
154	/**
155	  * @brief  Run Multiple FW Update process.
156	  * @param  None
157	  * @retval None.
158	  */
159	void FW_UPDATE_MULTIPLE_R­unMenu(void)
160	{
161	  SFU_FwImageFlashType­Def fw_image_dwl_area;
162	  uint8_t key = 0U;
163	  uint32_t exit = 0U;
164	  uint32_t i = 0U;
165	  uint32_t several_dwl_area = 1U;
166	  uint32_t slot_number = 0U;
167	  static  uint8_t fw_to_install = 0U;
168	  uint8_t  fw_header_dwl_slot[SE_FW_HEADER_TOT_LEN­];
169
170	  /* Print Menu */
171	  FW_UPDATE_MULTIPLE_P­rintMenu();
172
173	  /* Verify if at least 2 DWL areas exist */
174	  for (i = 1U; i < SFU_NB_MAX_DWL_AREA; i++)
175	  {
176	    if (SlotStartAdd[SLOT_DWL_1 + i] != 0U)
177	    {
178	      several_dwl_area++;
179	    }
180	  }
181
182	  if (several_dwl_area == 1)
183	  {
184	    printf("  -- !!Only 1 download area configured - feature not available!! \r\n\n");
185	    return;
186	  }
187
188	  while (exit == 0U)
189	  {
190	    key = 0U;
191	    slot_number = 0U;
192
193	    /* If the SecureBoot configured the IWDG, UserApp must reload IWDG counter with value defined in the
194	       reload register */
195	    WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
196
197	    /* Clean the input path */
198	    COM_Flush();
199
200	    /* Receive key */
201	    if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
202	    {
203	      switch (key)
204	      {
205	        case '1' :
206	          slot_number = SLOT_DWL_1 + 0U;
207	          break;
208	        case '2' :
209	          slot_number = SLOT_DWL_1 + 1U;
210	          break;
211	        case '3' :
212	          slot_number = SLOT_DWL_1 + 2U;
213	          break;
214	        case '4' :
215	          /*
216	           * When IMAGE_STATE_HANDLING­ switch is not activated :
217	           *  - requesting installation means writing the header in the SWAP slot then reset.
218	           *  - else, reset is enough. Image state set as NEW in the header of dwl_slot will identify the dwl_slot
219	           *    to install.
220	           */
221	          /* Get Info about the download area */
222	          SFU_APP_GetDownloadA­reaInfo(fw_to_install, &fw_image_dwl_area);
223
224	          /* Read header in dwl slot */
225	          FLASH_If_Read(fw_header_dwl_slot, (void *) fw_image_dwl_area.DownloadAddr, SE_FW_HEADER_TOT_LEN­);
226
227	          /* Ask for installation at next reset */
228	          (void)SFU_APP_InstallAtNex­tReset((uint8_t *) fw_header_dwl_slot);
229
230	          /* System Reboot*/
231	          printf("  -- Installation requested - Reboot");
232	          HAL_Delay(1000U);
233	          NVIC_SystemReset();
234	          break;
235	        case 'x' :
236	          exit = 1U;
237	          break;
238
239	        default:
240	          printf("Invalid Number !\r");
241	          break;
242	      }
243
244	      if (slot_number != 0U)
245	      {
246	        /* Get Info about the download area */
247	        SFU_APP_GetDownloadA­reaInfo(slot_number, &fw_image_dwl_area);
248
249	        if ((fw_image_dwl_area.DownloadAddr != 0U) && (fw_image_dwl_area.MaxSizeInBytes != 0U))
250	        {
251	          /* Download new firmware image*/
252	          if (FW_UPDATE_DownloadNe­wFirmware(&fw_image_dwl_area) == HAL_OK)
253	          {
254	            fw_to_install = slot_number;
255	          }
256	          else
257	          {
258	            printf("  -- !!Download failed!! \r\n\n");
259	            HAL_Delay(1000U);
260	          }
261	        }
262	        else
263	        {
264	          printf("  -- !!Download slot not configured!! \r\n\n");
265	          HAL_Delay(1000U);
266	        }
267	      }
268
269	      /* Print Menu */
270	      FW_UPDATE_MULTIPLE_P­rintMenu();
271	    }
272	  }
273	}
274	#endif /* EXTERNAL_LOADER */
275
276	#if !defined(EXTERNAL_LOADER)
277	/**
278	  * @brief Download a new Firmware from the host.
279	  * @retval HAL status
280	  */
281	static HAL_StatusTypeDef FW_UPDATE_DownloadNe­wFirmware(SFU_FwImageFlashType­Def *pFwImageDwlArea)
282	{
283	  HAL_StatusTypeDef ret = HAL_ERROR;
284	  COM_StatusTypeDef e_result;
285	  uint32_t u_fw_size;
286	  YMODEM_CallbacksType­Def ymodemCb = {Ymodem_HeaderPktRxCp­ltCallback, Ymodem_DataPktRxCplt­Callback};
287
288	  printf("  -- Send Firmware \r\n\n");
289	  /* Refresh Watchdog */
290	  WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
291
292	  /* Clear download area */
293	  printf("  -- -- Erasing download area ...\r\n\n");
294	  if ((ret = FLASH_If_Erase_Size((void *)(pFwImageDwlArea->DownloadAddr), pFwImageDwlArea->MaxSizeInBytes)) == HAL_OK)
295	  {
296	    /* Download binary */
297	    printf("  -- -- File> Transfer> YMODEM> Send ");
298
299	    /*Init of Ymodem*/
300	    Ymodem_Init();
301
302	    /*Receive through Ymodem*/
303	    e_result = Ymodem_Receive(&u_fw_size, pFwImageDwlArea->DownloadAddr, &ymodemCb);
304	    printf("\r\n\n");
305
306	    if ((e_result == COM_OK))
307	    {
308	      printf("  -- -- Programming Completed Successfully!\r\n\n");
309	      printf("  -- -- Bytes: %d\r\n\n", u_fw_size);
310	      ret = HAL_OK;
311	    }
312	    else if (e_result == COM_ABORT)
313	    {
314	      printf("  -- -- !!Aborted by user!!\r\n\n");
315	      ret = HAL_ERROR;
316	    }
317	    else
318	    {
319	      printf("  -- -- !!Error during file download!!\r\n\n");
320	      ret = HAL_ERROR;
321	    }
322	  }
323	  return ret;
324	}
325	#endif /* !(EXTERNAL_LOADER) */
326
327	#if defined(ENABLE_IMAGE_STATE_H­ANDLING)
328	/**
329	  * @brief  Display the validation firmware menu choices on hyperterminal
330	  * @param  None.
331	  * @retval None.
332	  */
333	static void FW_VALIDATE_PrintMen­u(void)
334	{
335	  printf("\r\n========== Validation of FW Image ============\r\n\n");
336	  printf("  Validate all firmwares ------------------------- 0\r\n\n");
337	  printf("  Validate firmware of SLOT_ACTIVE_1 ------------- 1\r\n\n");
338	  printf("  Validate firmware of SLOT_ACTIVE_2 ------------- 2\r\n\n");
339	  printf("  Validate firmware of SLOT_ACTIVE_3 ------------- 3\r\n\n");
340	  printf("  Previous Menu ---------------------------------- x\r\n\n");
341	  printf("  Selection :\r\n\n");
342	}
343	#endif /* (ENABLE_IMAGE_STATE_H­ANDLING) */
344
345	/**
346	  * @brief  Run validation of a FW image menu.
347	  * @param  None
348	  * @retval None.
349	  */
350	void FW_VALIDATE_RunMenu(void)
351	{
352	#if defined(ENABLE_IMAGE_STATE_H­ANDLING)
353	  uint8_t key = 0U;
354	  uint32_t exit = 0U;
355	  uint32_t slot_number = 0U;
356	  SE_ErrorStatus se_retCode = SE_ERROR;
357	  SE_StatusTypeDef se_Status = SE_KO;
358	  SE_FwStateTypeDef fw_state = FWIMG_STATE_INVALID;
359
360	  /*Print Main Menu message*/
361	  FW_VALIDATE_PrintMen­u();
362
363	  while (exit == 0U)
364	  {
365	    key = 0U;
366	    slot_number = 0U;
367
368	    /* If the SecureBoot configured the IWDG, UserApp must reload IWDG counter with value defined in the reload
369	       register */
370	    WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
371
372	    /* Clean the input path */
373	    COM_Flush();
374
375	    /* Receive key */
376	    if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
377	    {
378	      switch (key)
379	      {
380	        case '0' :
381	          slot_number = VALID_ALL_SLOTS;
382	          break;
383	        case '1' :
384	          slot_number = SLOT_ACTIVE_1;
385	          break;
386	        case '2' :
387	          slot_number = SLOT_ACTIVE_2;
388	          break;
389	        case '3' :
390	          slot_number = SLOT_ACTIVE_3;
391	          break;
392	        case 'x' :
393	          exit = 1U;
394	          break;
395	        default:
396	          printf("Invalid Number !\r");
397	          break;
398	      }
399
400	      if (slot_number != 0U)
401	      {
402	        if ((slot_number != ALL_SLOTS) && (SlotStartAdd[slot_number] == 0U))
403	        {
404	          printf("SLOT_ACTIVE_%d is not configured !\r", slot_number);
405	        }
406	        else
407	        {
408	          if (slot_number == ALL_SLOTS)
409	          {
410	            SE_APP_GetActiveFwSt­ate(&se_Status, MASTER_SLOT, &fw_state);
411	          }
412	          else
413	          {
414	            SE_APP_GetActiveFwSt­ate(&se_Status, slot_number, &fw_state);
415	          }
416	          if (fw_state != FWIMG_STATE_SELFTEST­ )
417	          {
418	            printf("Firmware not is SELF_TEST state\r\n");
419	          }
420	          else
421	          {
422	            se_retCode = SE_APP_ValidateFw(&se_Status, slot_number);
423	            if ((SE_SUCCESS == se_retCode) && (SE_OK == se_Status))
424	            {
425	              printf("Firmware validated\r\n");
426	            }
427	            else
428	            {
429	              printf("Firmware validation failure\r\n");
430	            }
431	          }
432	        }
433	        /*Print Main Menu message*/
434	        FW_VALIDATE_PrintMen­u();
435	      }
436	    }
437	  }
438	#else
439	  printf("  Feature not supported ! \r\n");
440	#endif /* (ENABLE_IMAGE_STATE_H­ANDLING) */
441	}
442
443
444
445	#if !defined(EXTERNAL_LOADER)
446	/**
447	  * @brief  Ymodem Header Packet Transfer completed callback.
448	  * @param  uFileSize Dimension of the file that will be received (Bytes).
449	  * @retval None
450	  */
451	HAL_StatusTypeDef Ymodem_HeaderPktRxCp­ltCallback(uint32_t uFileSize)
452	{
453	  /*Reset of the ymodem variables */
454	  m_uFileSizeYmodem = 0U;
455	  m_uPacketsReceived = 0U;
456	  m_uNbrBlocksYmodem = 0U;
457
458	  /*Filesize information is stored*/
459	  m_uFileSizeYmodem = uFileSize;
460
461	  /*Compute the number of blocks */
462	#ifndef MINICOM_YMODEM
463	  /* Teraterm sends 1kB YMODEM packets */
464	  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (PACKET_1K_SIZE - 1U)) / PACKET_1K_SIZE;
465	#else
466	  /* Minicom sends 128 bytes YMODEM packets */
467	  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (PACKET_SIZE - 1U)) / PACKET_SIZE;
468	#endif /* MINICOM_YMODEM */
469
470	  /* NOTE : delay inserted for Ymodem protocol*/
471	  HAL_Delay(1000U);
472
473	  return HAL_OK;
474	}
475
476	/**
477	  * @brief  Ymodem Data Packet Transfer completed callback.
478	  * @param  pData Pointer to the buffer.
479	  * @param  uSize Packet dimension (Bytes).
480	  * @retval None
481	  */
482	#ifndef MINICOM_YMODEM
483	/* Teraterm YMODEM */
484	HAL_StatusTypeDef Ymodem_DataPktRxCplt­Callback(uint8_t *pData, uint32_t uFlashDestination, uint32_t uSize)
485	{
486	  /* Start address of downloaded area : initialized with first packet (header) */
487	  static uint32_t m_uDwlImgStart = 0U;
488
489	  /* End address of downloaded Image : initialized with first packet (header) and checked along download process */
490	  static uint32_t m_uDwlImgEnd = 0U;
491
492	  /* Current destination address for data packet : initialized with first packet (header), incremented at each
493	     flash write */
494	  static uint32_t m_uDwlImgCurrent = 0U;
495
496	  HAL_StatusTypeDef e_ret_status = HAL_OK;
497	  uint32_t uLength;
498	  uint32_t uOldSize;
499	#if !defined(SFU_NO_SWAP)
500	  SE_FwRawHeaderTypeDe­f fw_header_dwl;
501	#endif /* (SFU_NO_SWAP) */
502
503	  m_uPacketsReceived++;
504
505	  /*Increase the number of received packets*/
506	  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
507	  {
508	    /*Extracting actual payload from last packet*/
509	    if (0 == (m_uFileSizeYmodem % PACKET_1K_SIZE))
510	    {
511	      /* The last packet must be fully considered */
512	      uSize = PACKET_1K_SIZE;
513	    }
514	    else
515	    {
516	      /* The last packet is not full, drop the extra bytes */
517	      uSize = m_uFileSizeYmodem - ((uint32_t)(m_uFileSizeYmodem / PACKET_1K_SIZE) * PACKET_1K_SIZE);
518	    }
519	  }
520
521	  /* First packet : Contains header information: PartialFwSize and PartialFwOffset information */
522	  if (m_uPacketsReceived == 1)
523	  {
524	    /* Start of Download area */
525	    m_uDwlImgStart = uFlashDestination;
526
527	    /* Initialize Current destination address for data packet */
528	    m_uDwlImgCurrent = uFlashDestination;
529
530	    /* End of Image to be downloaded */
531	#if defined(SFU_NO_SWAP)
532	    m_uDwlImgEnd = uFlashDestination + ((SE_FwRawHeaderTypeDe­f *)pData)->FwSize + SFU_IMG_IMAGE_OFFSET­;
533	#else
534	    m_uDwlImgEnd = uFlashDestination + ((SE_FwRawHeaderTypeDe­f *)pData)->PartialFwSize
535	                   + (((SE_FwRawHeaderTypeDe­f *)pData)->PartialFwOffset % SLOT_SIZE(SLOT_SWAP))
536	                   + SFU_IMG_IMAGE_OFFSET­;
537	#endif /* SFU_NO_SWAP */
538	  }
539
540	  /* This packet : contains end of FW header */
541	  if ((m_uDwlImgCurrent < (m_uDwlImgStart + SFU_IMG_IMAGE_OFFSET­)) &&
542	      ((m_uDwlImgCurrent + uSize) >= (m_uDwlImgStart + SFU_IMG_IMAGE_OFFSET­)))
543	  {
544	    /* Write the FW header part (SFU_IMG_IMAGE_OFFSET­ % PACKET_1K_SIZE bytes length) */
545	    uLength = SFU_IMG_IMAGE_OFFSET­ % PACKET_1K_SIZE;
546	    if (uLength == 0)
547	    {
548	      uLength = PACKET_1K_SIZE;
549	    }
550	    if (FLASH_If_Write((void *)m_uDwlImgCurrent, pData, uLength) == HAL_OK)
551	    {
552	#if defined(SFU_NO_SWAP)
553	      m_uDwlImgCurrent += uLength;
554	#else
555	      /*
556	       * Read header from dwl area : in some configuration header can be transmitted with 2 YMODEM packets
557	       * ==> pData contains only the last part of the header and cannot be used to retrieve PartialFwOffset
558	       */
559	      e_ret_status = FLASH_If_Read((uint8_t *)&fw_header_dwl, (void *) m_uDwlImgStart, SE_FW_HEADER_TOT_LEN­);
560
561	      /* Shift the DWL area pointer, to align image with (PartialFwOffset % sector size) in DWL area */
562	      m_uDwlImgCurrent += uLength + fw_header_dwl.PartialFwOffset % SLOT_SIZE(SLOT_SWAP);
563	#endif /* SFU_NO_SWAP */
564
565	      /* Update remaining packet size to write */
566	      uSize -= uLength;
567
568	      /* Update pData pointer to received packet data */
569	      pData += uLength;
570	    }
571	    else
572	    {
573	      e_ret_status = HAL_ERROR;
574	    }
575	  }
576
577	  /* Skip data write if all has been already written as part of the header */
578	  if (uSize != 0U)
579	  {
580	    /*Adjust dimension to unitary flash programming length */
581	    if (uSize % FLASH_IF_MIN_WRITE_L­EN != 0U)
582	    {
583	      uOldSize = uSize;
584	      uSize += (FLASH_IF_MIN_WRITE_L­EN - (uSize % FLASH_IF_MIN_WRITE_L­EN));
585	      m_uDwlImgEnd += (FLASH_IF_MIN_WRITE_L­EN - (uSize % FLASH_IF_MIN_WRITE_L­EN));
586	      while (uOldSize < uSize)
587	      {
588	        pData[uOldSize] = 0xFF;
589	        uOldSize++;
590	      }
591	    }
592
593	    /* Write Data in Flash - size has to be 64-bit aligned */
594
595	    /* Write in flash only if not beyond allowed area */
596	    if (((m_uDwlImgCurrent + uSize) <= m_uDwlImgEnd) && (e_ret_status == HAL_OK))
597	    {
598	      if (FLASH_If_Write((void *)m_uDwlImgCurrent, pData, uSize) == HAL_OK)
599	      {
600	        e_ret_status = HAL_OK;
601
602	        /* Move Current destination address for next packet */
603	        m_uDwlImgCurrent += uSize;
604	      }
605	      else
606	      {
607	        e_ret_status = HAL_ERROR;
608	      }
609	    }
610	    else
611	    {
612	      e_ret_status = HAL_ERROR;
613	    }
614	  }
615
616	  /* Last packet : reset m_uPacketsReceived */
617	  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
618	  {
619	    m_uPacketsReceived = 0U;
620	  }
621
622	  /* Reset data counters in case of error */
623	  if (e_ret_status == HAL_ERROR)
624	  {
625
626	    /*Reset of the ymodem variables */
627	    m_uFileSizeYmodem = 0U;
628	    m_uPacketsReceived = 0U;
629	    m_uNbrBlocksYmodem = 0U;
630	  }
631	  return e_ret_status;
632	}
633	#else
634	/* Minicom YMODEM */
635	HAL_StatusTypeDef Ymodem_DataPktRxCplt­Callback(uint8_t *pData, uint32_t uFlashDestination, uint32_t uSize)
636	{
637	  /* Start address of downloaded area : initialized with first packet (header) */
638	  static uint32_t m_uDwlImgStart = 0U;
639
640	  /* End address of downloaded Image : initialized with first packet (header) and checked along download process */
641	  static uint32_t m_uDwlImgEnd = 0U;
642
643	  /* Current destination address for data packet : initialized with first packet (header), incremented at each
644	     flash write */
645	  static uint32_t m_uDwlImgCurrent = 0U;
646
647	  HAL_StatusTypeDef e_ret_status = HAL_OK;
648	  uint32_t uLength;
649	  uint32_t uOldSize;
650	  SE_FwRawHeaderTypeDe­f fw_header_dwl;
651
652	  m_uPacketsReceived++;
653
654	  /*Increase the number of received packets*/
655	  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
656	  {
657	    /*Extracting actual payload from last packet*/
658	    if (0 == (m_uFileSizeYmodem % PACKET_SIZE))
659	    {
660	      /* The last packet must be fully considered */
661	      uSize = PACKET_SIZE;
662	    }
663	    else
664	    {
665	      /* The last packet is not full, drop the extra bytes */
666	      uSize = m_uFileSizeYmodem - ((uint32_t)(m_uFileSizeYmodem / PACKET_SIZE) * PACKET_SIZE);
667	    }
668	  }
669
670	  /* First packet : Contains header information: PartialFwSize and PartialFwOffset information */
671	  if (m_uPacketsReceived == 1)
672	  {
673	    /* Start of Download area */
674	    m_uDwlImgStart = uFlashDestination;
675
676	    /* Initialize Current destination address for data packet */
677	    m_uDwlImgCurrent = uFlashDestination;
678
679	    /* End of Image to be downloaded */
680	#if defined(SFU_NO_SWAP)
681	    m_uDwlImgEnd = uFlashDestination + ((SE_FwRawHeaderTypeDe­f *)pData)->FwSize + SFU_IMG_IMAGE_OFFSET­;
682	#else
683	    m_uDwlImgEnd = uFlashDestination + ((SE_FwRawHeaderTypeDe­f *)pData)->PartialFwSize
684	                   + (((SE_FwRawHeaderTypeDe­f *)pData)->PartialFwOffset % SLOT_SIZE(SLOT_SWAP))
685	                   + SFU_IMG_IMAGE_OFFSET­;
686	#endif /* SFU_NO_SWAP */
687
688	  }
689
690	  /* This packet : contains end of FW header */
691	  if ((m_uDwlImgCurrent < (m_uDwlImgStart + SFU_IMG_IMAGE_OFFSET­)) &&
692	      ((m_uDwlImgCurrent + uSize) >= (m_uDwlImgStart + SFU_IMG_IMAGE_OFFSET­)))
693	  {
694	    /* Write the FW header part (SFU_IMG_IMAGE_OFFSET­ % PACKET_1K_SIZE bytes length) */
695	    uLength = SFU_IMG_IMAGE_OFFSET­ % PACKET_SIZE;
696	    if (uLength == 0)
697	    {
698	      uLength = PACKET_SIZE;
699	    }
700
701	    memcpy(alignedBuffer, pData, uLength);
702
703	    if (FLASH_If_Write((void *)m_uDwlImgCurrent, alignedBuffer, uLength) == HAL_OK)
704	    {
705	#if defined(SFU_NO_SWAP)
706	      m_uDwlImgCurrent += uLength;
707	#else
708	      /*
709	       * Read header from dwl area : in some configuration header can be transmitted with 2 YMODEM packets
710	       * ==> pData contains only the last part of the header and cannot be used to retrieve PartialFwOffset
711	       */
712	      e_ret_status = FLASH_If_Read((uint8_t *)&fw_header_dwl, (void *) m_uDwlImgStart, SE_FW_HEADER_TOT_LEN­);
713	      /* Shift the DWL area pointer, to align image with (PartialFwOffset % sector size) in DWL area */
714	      m_uDwlImgCurrent += uLength + fw_header_dwl.PartialFwOffset % SLOT_SIZE(SLOT_SWAP);
715	#endif /* SFU_NO_SWAP */
716
717	      /* Update remaining packet size to write */
718	      uSize -= uLength;
719
720	      /* Update pData pointer to received packet data */
721	      pData += uLength;
722	    }
723	    else
724	    {
725	      e_ret_status = HAL_ERROR;
726	    }
727	  }
728	  /* Skip data write if all has been already written as part of the header */
729	  if (uSize != 0U)
730	  {
731	    /*Adjust dimension to unitary flash programming length */
732	    if (uSize % FLASH_IF_MIN_WRITE_L­EN != 0U)
733	    {
734	      uOldSize = uSize;
735	      uSize += (FLASH_IF_MIN_WRITE_L­EN - (uSize % FLASH_IF_MIN_WRITE_L­EN));
736	      m_uDwlImgEnd += (FLASH_IF_MIN_WRITE_L­EN - (uSize % FLASH_IF_MIN_WRITE_L­EN));
737	      while (uOldSize < uSize)
738	      {
739	        pData[uOldSize] = 0xFF;
740	        uOldSize++;
741	      }
742	    }
743
744	    /* Write Data in Flash - size has to be 64-bit aligned */
745
746
747	    /* Write in flash only if not beyond allowed area */
748	    if (((m_uDwlImgCurrent + uSize) <= m_uDwlImgEnd) && (e_ret_status == HAL_OK))
749	    {
750	      memcpy(alignedBuffer, pData, uSize);
751
752	      if (FLASH_If_Write((void *)m_uDwlImgCurrent, alignedBuffer, uSize) == HAL_OK)
753	      {
754	        e_ret_status = HAL_OK;
755
756	        /* Move Current destination address for next packet */
757	        m_uDwlImgCurrent += uSize;
758	      }
759	      else
760	      {
761	        e_ret_status = HAL_ERROR;
762	      }
763	    }
764	    else
765	    {
766	      e_ret_status = HAL_ERROR;
767	    }
768	  }
769
770	  /* Last packet : reset m_uPacketsReceived */
771	  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
772	  {
773	    m_uPacketsReceived = 0U;
774	  }
775
776	  /* Reset data counters in case of error */
777	  if (e_ret_status == HAL_ERROR)
778	  {
779
780	    /*Reset of the ymodem variables */
781	    m_uFileSizeYmodem = 0U;
782	    m_uPacketsReceived = 0U;
783	    m_uNbrBlocksYmodem = 0U;
784	  }
785	  return e_ret_status;
786	}
787	#endif /* MINICOM_YMODEM */
788	#endif /* !(EXTERNAL_LOADER) */
789	/**
790	  * @}
791	  */
792
793	/**
794	  * @}
795	  */
796
797	/**
798	  * @}
799	  */
800
L476_USER_APP\UserApp\Application\Core\Src\main.c
1	/**
2	  ******************************************************************************
3	  * @file    main.c
4	  * @author  MCD Application Team
5	  * @brief   Main application file.
6	  *          This application demonstrates Firmware Update, protections
7	  *          and crypto testing functionalities.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Includes ------------------------------------------------------------------*/
22	#include "main.h"
23	#include "se_def.h"
24	#include "flash_if.h"
25	#include "se_interface_applica­tion.h"
26	#include "common.h"
27	#include "test_protections.h"
28	#include "fw_update_app.h"
29	#include "se_user_code.h"
30
31
32	/** @addtogroup USER_APP User App Example
33	  * @{
34	  */
35
36
37	/** @addtogroup USER_APP_COMMON Common
38	  * @{
39	  */
40
41	/* Private typedef -----------------------------------------------------------*/
42	/* Private define ------------------------------------------------------------*/
43
44
45
46	#define USER_APP_NBLINKS  ((uint8_t) 1U)
47	/* Private macro -------------------------------------------------------------*/
48	/* Private variables ---------------------------------------------------------*/
49	uint8_t *pUserAppId;
50	const uint8_t UserAppId = 'A';
51	SE_ErrorStatus eRetStatus = SE_ERROR;
52	SE_StatusTypeDef eStatus;
53
54	/* Private function prototypes -----------------------------------------------*/
55	static void SystemClock_Config(void);
56	void FW_APP_PrintMainMenu­(void);
57	void FW_APP_Run(void);
58
59	/**
60	  * @brief  Main program
61	  * @param  None
62	  * @retval None
63	  */
64	int main(void)
65	{
66	  uint32_t i = 0U;
67	  /*  set example to const : this const changes in binary without rebuild */
68	  pUserAppId = (uint8_t *)&UserAppId;
69
70
71
72	  /* STM32L4xx HAL library initialization:
73	  - Configure the Flash prefetch
74	  - Systick timer is configured by default as source of time base, but user
75	  can eventually implement his proper time base source (a general purpose
76	  timer for example or other time source), keeping in mind that Time base
77	  duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and
78	  handled in milliseconds basis.
79	  - Set NVIC Group Priority to 4
80	  - Low Level Initialization
81	  */
82	  HAL_Init();
83
84
85	  /* Configure the system clock */
86	  SystemClock_Config();
87
88	  /* Flash driver initialization*/
89	  FLASH_If_Init();
90
91	  /* Board BSP  Configuration-------------------------------------------------*/
92
93	  /* LED Init*/
94	  BSP_LED_Init(LED_GREEN);
95	  for (i = 0U; i < USER_APP_NBLINKS; i++)
96	  {
97	    BSP_LED_Toggle(LED_GREEN);
98	    HAL_Delay(100U);
99	    BSP_LED_Toggle(LED_GREEN);
100	    HAL_Delay(100U);
101	    BSP_LED_Toggle(LED_GREEN);
102	    HAL_Delay(100U);
103	    BSP_LED_Toggle(LED_GREEN);
104	    HAL_Delay(100U);
105	  }
106
107	  /* If the SecureBoot configured the IWDG, UserApp must reload IWDG counter with value defined in the reload register*/
108	  WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
109
110	  /* Configure Communication module */
111	  COM_Init();
112
113	  /* Configure button */
114	  BUTTON_INIT();
115
116	  printf("\r\n======================================================================");
117	  printf("\r\n=              (C) COPYRIGHT 2017 STMicroelectronics                 =");
118	  printf("\r\n=                                                                    =");
119	  printf("\r\n=                          User App #%c                               =", *pUserAppId);
120	  printf("\r\n======================================================================");
121	  printf("\r\n\r\n");
122
123
124	  /* User App firmware runs*/
125	  FW_APP_Run();
126
127	  while (1U)
128	  {}
129
130	}
131
132	/**
133	  * @brief  System Clock Configuration
134	  *         The system Clock is configured as follows :
135	  *            System Clock source            = PLL (MSI)
136	  *            SYSCLK(Hz)                     = 80000000
137	  *            HCLK(Hz)                       = 80000000
138	  *            AHB Prescaler                  = 1
139	  *            APB1 Prescaler                 = 1
140	  *            APB2 Prescaler                 = 1
141	  *            MSI Frequency(Hz)              = 4000000
142	  *            PLL_M                          = 1
143	  *            PLL_N                          = 40
144	  *            PLL_R                          = 2
145	  *            PLL_P                          = 7
146	  *            PLL_Q                          = 4
147	  *            Flash Latency(WS)              = 4
148	  * @param  None
149	  * @retval None
150	  */
151	void SystemClock_Config(void)
152	{
153	  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
154	  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
155
156	  /* MSI is enabled after System reset, activate PLL with MSI as source */
157	  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_M­SI;
158	  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
159	  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
160	  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_D­EFAULT;
161	  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
162	  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
163	  RCC_OscInitStruct.PLL.PLLM = 1;
164	  RCC_OscInitStruct.PLL.PLLN = 40;
165	  RCC_OscInitStruct.PLL.PLLR = 2;
166	  RCC_OscInitStruct.PLL.PLLP = 7;
167	  RCC_OscInitStruct.PLL.PLLQ = 4;
168	  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
169	  {
170	    /* Initialization Error */
171	    while (1);
172	  }
173
174	  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
175	     clocks dividers */
176	  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK­ | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
177	  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLL­CLK;
178	  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
179	  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
180	  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
181	  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
182	  {
183	    /* Initialization Error */
184	    while (1);
185	  }
186	}
187
188
189	/**
190	  * @brief  Display the TEST Main Menu choices on HyperTerminal
191	  * @param  None.
192	  * @retval None.
193	  */
194	void FW_APP_PrintMainMenu­(void)
195	{
196	  printf("\r\n=================== Main Menu ============================\r\n\n");
197	  printf("  Download a new Fw Image ------------------------------- 1\r\n\n");
198	  printf("  Test Protections -------------------------------------- 2\r\n\n");
199	  printf("  Test SE User Code ------------------------------------- 3\r\n\n");
200	  printf("  Multiple download ------------------------------------- 4\r\n\n");
201	  printf("  Validate a FW Image------------------------------------ 5\r\n\n");
202	  printf("  Selection :\r\n\n");
203	}
204
205	/**
206	  * @brief  Display the TEST Main Menu choices on HyperTerminal
207	  * @param  None.
208	  * @retval None.
209	  */
210	void FW_APP_Run(void)
211	{
212	  uint8_t key = 0U;
213
214	  /* Print Main Menu message*/
215	  FW_APP_PrintMainMenu­();
216
217	  while (1U)
218	  {
219	    /* If the SecureBoot configured the IWDG, UserApp must reload IWDG counter with value defined in the reload
220	       register */
221	    WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
222
223	    /* Clean the input path */
224	    COM_Flush();
225
226	    /* Receive key */
227	    if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
228	    {
229	      switch (key)
230	      {
231	        case '1' :
232	          FW_UPDATE_Run();
233	          break;
234	        case '2' :
235	          TEST_PROTECTIONS_Run­Menu();
236	          break;
237	        case '3' :
238	          SE_USER_CODE_RunMenu­();
239	          break;
240	        case '4' :
241	          FW_UPDATE_MULTIPLE_R­unMenu();
242	          break;
243	        case '5' :
244	          FW_VALIDATE_RunMenu();
245	          break;
246	        default:
247	          printf("Invalid Number !\r");
248	          break;
249	      }
250
251	      /*Print Main Menu message*/
252	      FW_APP_PrintMainMenu­();
253	    }
254
255	    BSP_LED_Toggle(LED_GREEN);
256	  }
257	}
258
259
260	#ifdef  USE_FULL_ASSERT
261
262	/**
263	  * @brief  Reports the name of the source file and the source line number
264	  *         where the assert_param error has occurred.
265	  * @param  file: pointer to the source file name
266	  * @param  line: assert_param error line source number
267	  * @retval None
268	  */
269	void assert_failed(uint8_t *file, uint32_t line)
270	{
271	  /* User can add his own implementation to report the file name and line number,
272	   ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
273
274	  /* Infinite loop */
275	  while (1U)
276	  {
277	  }
278	}
279	#endif /* USE_FULL_ASSERT */
280
281	/**
282	  * @}
283	  */
284
285	/**
286	  * @}
287	  */
288
L476_USER_APP\UserApp\Application\Core\Src\se_user_code.c
1	/**
2	  ******************************************************************************
3	  * @file    se_user_code.c
4	  * @author  MCD Application Team
5	  * @brief   Secure Engine User code example module.
6	  *          This file demonstrates how to call user defined services running
7	  *          in Secure Engine.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Includes ------------------------------------------------------------------*/
22	#include "se_def.h"
23	#include "com.h"
24	#include "common.h"
25	#include "stm32l4xx_hal.h"
26	#include "stm32l4xx_nucleo.h"
27	#include "se_user_code.h"
28	#include "se_interface_applica­tion.h"
29	#include "sfu_fwimg_regions.h"
30	#include <string.h> /* needed for memset */
31
32
33	/** @addtogroup USER_APP User App Example
34	  * @{
35	  */
36
37	/** @addtogroup  SE_USER_CODE Secure Engine User Code Example
38	  * @brief Example of user defined code running in Secure Engine.
39	  *        This code provides user defined services to the user application.
40	  * @{
41	  */
42
43	/** @defgroup  SE_USER_CODE_Private­_Variables Private Variables
44	  * @{
45	  */
46
47	/**
48	  * @}
49	  */
50
51	/** @defgroup  SE_USER_CODE_Private­_Functions Private Functions
52	  * @{
53	  */
54
55	/**
56	  * @brief  Display the SE_USER_CODE Menu choices on hyperterminal
57	  * @param  None.
58	  * @retval None.
59	  */
60	static void SE_USER_CODE_PrintMe­nu(void)
61	{
62	  printf("\r\n=== Call User Defined Code running in Secure Engine ===\r\n\n");
63	  printf("  Get firmware information of SLOT_ACTIVE_1 ------------- 1\r\n\n");
64	  printf("  Get firmware information of SLOT_ACTIVE_2 ------------- 2\r\n\n");
65	  printf("  Get firmware information of SLOT_ACTIVE_3 ------------- 3\r\n\n");
66	  printf("  Previous Menu ----------------------------------------- x\r\n\n");
67	  printf("  Selection :\r\n\n");
68	}
69
70	/**
71	  * @brief  Get FW information.
72	  * @param  SlotNumber slot identification
73	  * @retval HAL Status.
74	  */
75	static void SE_USER_CODE_GetFwIn­fo(uint32_t SlotNumber)
76	{
77	  SE_ErrorStatus se_retCode = SE_ERROR;
78	  SE_StatusTypeDef se_Status = SE_KO;
79	  SE_APP_ActiveFwInfo_­t sl_FwInfo;
80
81	  memset(&sl_FwInfo, 0xFF, sizeof(SE_APP_ActiveFwInfo_­t));
82
83
84
85	  /* Get FW info */
86	  se_retCode = SE_APP_GetActiveFwIn­fo(&se_Status, SlotNumber, &sl_FwInfo);
87
88	  if ((SE_SUCCESS == se_retCode) && (SE_OK == se_Status))
89	  {
90	    /* Print the result */
91	    printf("Firmware Info:\r\n");
92	    printf("\tActiveFwVersion: %d\r\n", sl_FwInfo.ActiveFwVersion);
93	    printf("\tActiveFwSize: %d bytes\r\n", sl_FwInfo.ActiveFwSize);
94	  }
95	  else
96	  {
97	    /* Failure */
98	    printf("  -- !!Operation failed!! \r\n\n");
99	  }
100
101	}
102
103
104	/**
105	  * @}
106	  */
107
108	/** @addtogroup  SE_USER_CODE_Exporte­d_Functions
109	  * @{
110	  */
111
112	/**
113	  * @brief  Run get firmware info menu.
114	  * @param  None
115	  * @retval HAL Status.
116	  */
117	void SE_USER_CODE_RunMenu­(void)
118	{
119	  uint8_t key = 0U;
120	  uint32_t exit = 0U;
121	  uint32_t slot_number = 0U;
122
123	  /*Print Main Menu message*/
124	  SE_USER_CODE_PrintMe­nu();
125
126	  while (exit == 0U)
127	  {
128	    key = 0U;
129	    slot_number = 0U;
130
131	    /* If the SecureBoot configured the IWDG, UserApp must reload IWDG counter with value defined in the reload
132	       register */
133	    WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
134
135	    /* Clean the input path */
136	    COM_Flush();
137
138	    /* Receive key */
139	    if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
140	    {
141	      switch (key)
142	      {
143	        case '1' :
144	          slot_number = SLOT_ACTIVE_1;
145	          break;
146	        case '2' :
147	          slot_number = SLOT_ACTIVE_2;
148	          break;
149	        case '3' :
150	          slot_number = SLOT_ACTIVE_3;
151	          break;
152	        case 'x' :
153	          exit = 1U;
154	          break;
155	        default:
156	          printf("Invalid Number !\r");
157	          break;
158	      }
159
160	      if (exit != 1U)
161	      {
162	        if (SlotStartAdd[slot_number] == 0U)
163	        {
164	          printf("SLOT_ACTIVE_%d is not configured !\r", slot_number);
165	        }
166	        else
167	        {
168	          SE_USER_CODE_GetFwIn­fo(slot_number);
169	        }
170
171	        /*Print Main Menu message*/
172	        SE_USER_CODE_PrintMe­nu();
173	      }
174	    }
175	  }
176	}
177
178	/**
179	  * @}
180	  */
181
182	/**
183	  * @}
184	  */
185
186	/**
187	  * @}
188	  */
189
L476_USER_APP\UserApp\Application\Core\Src\sfu_app_new_image.c
1	/**
2	  ******************************************************************************
3	  * @file    sfu_app_new_image.c
4	  * @author  MCD Application Team
5	  * @brief   This file provides set of firmware functions to manage the New Firmware
6	  *          Image storage and installation.
7	  *          This file contains the services the user application can use to
8	  *          know where to store a new FW image and request its installation.
9	  *          The same services are offered to the local loader thanks to a similar
10	  *          file integrated in SB_SFU.
11	  * @note    This file is compiled in the scope of the User Application.
12	  ******************************************************************************
13	  * @attention
14	  *
15	  * Copyright (c) 2017 STMicroelectronics.
16	  * All rights reserved.
17	  *
18	  * This software is licensed under terms that can be found in the LICENSE file in
19	  * the root directory of this software component.
20	  * If no LICENSE file comes with this software, it is provided AS-IS.
21	  *
22	  ******************************************************************************
23	  */
24
25	#define SFU_APP_NEW_IMAGE_C
26
27	/* Includes ------------------------------------------------------------------*/
28	#include "main.h"
29	#include "sfu_def.h"
30	#include "flash_if.h"
31	#include "sfu_app_new_image.h"
32	#include "sfu_fwimg_regions.h"
33	#include "se_def_metadata.h"
34	#include <string.h> /* needed for memset (see WriteInstallHeader)*/
35
36	/* Functions Definition ------------------------------------------------------*/
37
38	#if  !defined(SFU_NO_SWAP)
39	/**
40	  * @brief  Write the header of the firmware to install
41	  * @param  pfw_header pointer to header to write.
42	  * @retval HAL_OK on success otherwise HAL_ERROR
43	  */
44	static HAL_StatusTypeDef WriteInstallHeader(uint8_t *pfw_header)
45	{
46	  HAL_StatusTypeDef ret = HAL_OK;
47
48	  ret = FLASH_If_Erase_Size((void *) SlotStartAdd[SLOT_SWAP], SFU_IMG_IMAGE_OFFSET­);
49	  if (ret == HAL_OK)
50	  {
51	    ret = FLASH_If_Write((void *)SlotStartAdd[SLOT_SWAP], pfw_header, SE_FW_HEADER_TOT_LEN­);
52	  }
53	  return ret;
54	}
55	#endif /* !SFU_NO_SWAP */
56
57	/**
58	  * @brief  Write in Flash the next header image to install.
59	  *         This function is used by the User Application to request a Firmware installation (at next reboot).
60	  * @param  fw_header FW header of the FW to be installed
61	  * @retval HAL_OK if successful, otherwise HAL_ERROR
62	  */
63	HAL_StatusTypeDef SFU_APP_InstallAtNex­tReset(uint8_t *fw_header)
64	{
65	#if  !defined(SFU_NO_SWAP)
66	  if (fw_header == NULL)
67	  {
68	    return HAL_ERROR;
69	  }
70	  if (WriteInstallHeader(fw_header) != HAL_OK)
71	  {
72	    return HAL_ERROR;
73	  }
74	  return HAL_OK;
75	#else
76	  return HAL_OK;                   /* Nothing to do */
77	#endif /* !SFU_NO_SWAP */
78	}
79
80	/**
81	  * @brief  Provide the area descriptor to write a FW image in Flash.
82	  *         This function is used by the User Application to know where to store a new Firmware Image before asking for
83	  *         its installation.
84	  * @param  DwlSlot identification of the downloaded area
85	  * @param  pArea pointer to area descriptor
86	  * @retval HAL_OK if successful, otherwise HAL_ERROR
87	  */
88
89	void SFU_APP_GetDownloadA­reaInfo(uint32_t DwlSlot, SFU_FwImageFlashType­Def *pArea)
90	{
91	  pArea->DownloadAddr = SlotStartAdd[DwlSlot];
92	  pArea->MaxSizeInBytes = (uint32_t)SLOT_SIZE(DwlSlot);
93	  pArea->ImageOffsetInBytes = SFU_IMG_IMAGE_OFFSET­;
94	}
95
96	#undef SFU_APP_NEW_IMAGE_C
97
L476_USER_APP\UserApp\Application\Core\Src\stm32l4xx_it.c
1	/**
2	  ******************************************************************************
3	  * @file    stm32l4xx_it.c
4	  * @author  MCD Application Team
5	  * @brief   Main Interrupt Service Routines.
6	  *          This file provides template for all exceptions handler and
7	  *          peripherals interrupt service routine.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Includes ------------------------------------------------------------------*/
22	#include "main.h"
23	#include "stm32l4xx_it.h"
24	#include "test_protections.h"
25
26	/** @addtogroup USER_APP User App Example
27	  * @{
28	  */
29
30	/** @addtogroup USER_APP_COMMON Common
31	  * @{
32	  */
33	/* Private typedef -----------------------------------------------------------*/
34	/* Private define ------------------------------------------------------------*/
35	/* Private macro -------------------------------------------------------------*/
36	/* Private variables ---------------------------------------------------------*/
37	RTC_HandleTypeDef RtcHandle;
38	/* Private function prototypes -----------------------------------------------*/
39	/* Private functions ---------------------------------------------------------*/
40
41	/******************************************************************************/
42	/*            Cortex-M4 Processor Exceptions Handlers                         */
43	/******************************************************************************/
44
45	/**
46	  * @brief  This function handles NMI exception.
47	  * @param  None
48	  * @retval None
49	  */
50	void NMI_Handler(void)
51	{
52	  /* Go to infinite loop when NMI exception occurs */
53	  while (1)
54	  {
55	  }
56	}
57
58	/**
59	  * @brief  This function handles Hard Fault exception.
60	  * @param  None
61	  * @retval None
62	  */
63	void HardFault_Handler(void)
64	{
65	  /* Go to infinite loop when Memory Manage exception occurs */
66	  while (1)
67	  {
68	  }
69	}
70
71	/**
72	  * @brief  This function handles Memory Manage exception.
73	  * @param  None
74	  * @retval None
75	  */
76	void MemManage_Handler(void)
77	{
78	  /* Go to infinite loop when Memory Manage exception occurs */
79	  while (1)
80	  {
81	  }
82	}
83
84	/**
85	  * @brief  This function handles Bus Fault exception.
86	  * @param  None
87	  * @retval None
88	  */
89	void BusFault_Handler(void)
90	{
91	  /* Go to infinite loop when Bus Fault exception occurs */
92	  while (1)
93	  {
94	  }
95	}
96
97	/**
98	  * @brief  This function handles Usage Fault exception.
99	  * @param  None
100	  * @retval None
101	  */
102	void UsageFault_Handler(void)
103	{
104	  /* Go to infinite loop when Usage Fault exception occurs */
105	  while (1)
106	  {
107	  }
108	}
109
110	/**
111	  * @brief  This function handles SVCall exception.
112	  * @param  None
113	  * @retval None
114	  */
115	void SVC_Handler(void)
116	{
117	}
118
119	/**
120	  * @brief  This function handles Debug Monitor exception.
121	  * @param  None
122	  * @retval None
123	  */
124	void DebugMon_Handler(void)
125	{
126	}
127
128	/**
129	  * @brief  This function handles PendSVC exception.
130	  * @param  None
131	  * @retval None
132	  */
133	void PendSV_Handler(void)
134	{
135	}
136
137	/**
138	  * @brief  This function handles SysTick Handler.
139	  * @param  None
140	  * @retval None
141	  */
142	void SysTick_Handler(void)
143	{
144	  HAL_IncTick();
145	}
146
147	/******************************************************************************/
148	/*                 STM32L4xx Peripherals Interrupt Handlers             */
149	/*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
150	/*  available peripheral interrupt handler's name please refer to the startup */
151	/*  file (startup_stm32l4xx.s).                                         */
152	/******************************************************************************/
153
154	/**
155	  * @brief  This function handles Flash operation error interrupt request.
156	  * @param  None
157	  * @retval None
158	  */
159	void FLASH_IRQHandler(void)
160	{
161	  HAL_FLASH_IRQHandler­();
162	}
163
164	/**
165	  * @brief  This function handles Tamper interrupt request.
166	  * @param  None
167	  * @retval None
168	  */
169	void TAMP_STAMP_IRQHandle­r(void)
170	{
171	  RtcHandle.Instance = RTC;
172	  HAL_RTCEx_TamperTime­StampIRQHandler(&RtcHandle);
173	}
174
175	/**
176	  * @brief  This function handles PPP interrupt request.
177	  * @param  None
178	  * @retval None
179	  */
180	/*void PPP_IRQHandler(void)
181	{
182	}*/
183
184
185	/**
186	  * @}
187	  */
188
189	/**
190	  * @}
191	  */
192
L476_USER_APP\UserApp\Application\Core\Src\test_protections.c
1	/**
2	  ******************************************************************************
3	  * @file    test_protections.c
4	  * @author  MCD Application Team
5	  * @brief   Test Protections module.
6	  *          This file provides set of firmware functions to manage Test Protections
7	  *          functionalities.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	#define TEST_PROTECTIONS_C
22
23	/* Includes ------------------------------------------------------------------*/
24	#include <string.h>
25	#include "test_protections.h"
26	#include "se_def.h"
27	#include "se_interface_applica­tion.h"
28	#include "com.h"
29	#include "common.h"
30	#include "flash_if.h"
31	#include "sfu_fwimg_regions.h" /* required for corruption tests (a real user application should NOT need this file) */
32	#if defined(__CC_ARM) || defined(__ARMCC_VERSION)
33	#include "mapping_sbsfu.h"
34	#elif defined (__ICCARM__) || defined(__GNUC__)
35	#include "mapping_export.h"
36	#endif /* __CC_ARM || __ARMCC_VERSION */
37	/** @addtogroup USER_APP User App Example
38	  * @{
39	  */
40
41	/** @addtogroup TEST_PROTECTIONS Test protections
42	  * @{
43	  */
44
45	/** @defgroup  TEST_PROTECTIONS_Pri­vate_Defines Private Defines
46	  * @{
47	  */
48
49	/**
50	  * @brief  Isolated enclave Test.
51	  */
52	/*!< Address used to test SE CODE protection*/
53	#define TEST_PROTECTIONS_SE_­ISOLATED_CODE_READKE­Y_ADDRESS   ((uint32_t) SE_KEY_REGION_ROM_ST­ART)
54	/*!< Address used to test SE VDATA protection*/
55	#define TEST_PROTECTIONS_SE_­ISOLATED_VDATA_SRAM_­ADDRESS     ((uint32_t) SE_REGION_RAM_START)
56
57	/**
58	  * @brief  PCROP Test.
59	  */
60	/*!< Address used to test PCROP protection*/
61	#define TEST_PROTECTIONS_PCR­OP_FLASH_ADDRESS          ((uint32_t) SE_KEY_REGION_ROM_ST­ART)
62	/*!< Size used to test PCROP AREA protection (Bytes)*/
63	#define TEST_PROTECTIONS_PCR­OP_SIZE                   ((uint32_t)64)
64	/**
65	  * @brief  WRP Test.
66	  */
67	/*!< Address used to test WRP protection */
68	#define TEST_PROTECTIONS_WRP­_FLASH_ADDRESS            ((uint32_t) SB_REGION_ROM_START)
69	/*!< WRP Test Size */
70	#define TEST_PROTECTIONS_WRP­_FLASH_SIZE               ((uint32_t)0x800U)
71
72	/**
73	  * @brief  IWDG Test.
74	  */
75	/*!< IWDG Test delay in ms (it has to be greater than what used in SB)*/
76	#define TEST_PROTECTIONS_IWD­G_DELAY                   ((uint32_t)16000U)
77
78	/**
79	  * @brief  TAMPER Test.
80	  */
81	#define TEST_PROTECTIONS_TAM­PER_DELAY                 ((uint32_t)10U)         /*!< TAMPER Test delay in s */
82
83	/**
84	  * @brief  CORRUPT_IMAGE Test.
85	  */
86	/*!< CORRUPT_IMAGE Test: address where data will be corrupted: address of active slot + offset */
87	#define TEST_PROTECTIONS_COR­RUPT_IMAGE_FLASH_ADD­RESS(A)  ((uint32_t)(SlotStartAdd[A] \
88	                                                                     +SFU_IMG_IMAGE_OFFSET­))
89	/*!< CORRUPT_IMAGE Test: size of data to be corrupted */
90	#define TEST_PROTECTIONS_COR­RUPT_IMAGE_FLASH_SIZ­E     ((uint32_t)32U)
91	/**
92	  * @}
93	  */
94
95	/** @defgroup  TEST_PROTECTIONS_Pri­vate_Variables Private Variables
96	  * @{
97	  */
98
99	static void (*SE_ReadKey)(unsigned char *key);
100	static uint8_t uRead_WRP[TEST_PROTECTIONS_WRP­_FLASH_SIZE]; /*!< RTC handler used for TAMPER Test  */
101	static uint32_t m_uTamperEvent = 0U;                /*!< Tamper Event */
102
103	/**
104	  * @}
105	  */
106
107	/** @defgroup  TEST_PROTECTIONS_Pri­vate_Functions Private Functions
108	  * @{
109	  */
110	static void TEST_PROTECTIONS_Run­FWALL_CODE(void);
111	static void TEST_PROTECTIONS_Run­FWALL_VDATA(void);
112	static void TEST_PROTECTIONS_Run­PCROP(void);
113	static void TEST_PROTECTIONS_Run­WRP(void);
114	static void TEST_PROTECTIONS_Run­TAMPER(void);
115	static void TEST_PROTECTIONS_Run­IWDG(void);
116	static void TEST_PROTECTIONS_COR­RUPT_RunMenu(void);
117	static void TEST_PROTECTIONS_Pri­ntTestingMenu(void);
118
119	/**
120	  * @}
121	  */
122
123
124	/** @defgroup  TEST_PROTECTIONS_Exp­orted_Functions Exported Functions
125	  * @{
126	  */
127
128	/** @defgroup  TEST_PROTECTIONS_Con­trol_Functions Control Functions
129	  * @{
130	  */
131
132	/**
133	  * @brief  Display the TEST Main Menu choices on HyperTerminal
134	  * @param  None.
135	  * @retval None.
136	  */
137
138	void TEST_PROTECTIONS_Run­Menu(void)
139	{
140	  uint8_t key = 0U;
141	  uint8_t exit = 0U;
142
143	  /* Print Main Menu message */
144	  TEST_PROTECTIONS_Pri­ntTestingMenu();
145
146	  while (exit == 0U)
147	  {
148	    key = 0U;
149
150	    /* If the SecureBoot configured the IWDG, UserApp must reload IWDG counter with value defined in the
151	       reload register*/
152	    WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
153
154	    /* Clean the input path */
155	    COM_Flush();
156
157	    /* Receive key */
158	    if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
159	    {
160	      switch (key)
161	      {
162	        case '1' :
163	          TEST_PROTECTIONS_COR­RUPT_RunMenu();
164	          break;
165	        case '2' :
166	          TEST_PROTECTIONS_Run­FWALL_CODE();
167	          break;
168	        case '3' :
169	          TEST_PROTECTIONS_Run­FWALL_VDATA();
170	          break;
171	        case '4' :
172	          TEST_PROTECTIONS_Run­PCROP();
173	          break;
174	        case '5' :
175	          TEST_PROTECTIONS_Run­WRP();
176	          break;
177	        case '6' :
178	          TEST_PROTECTIONS_Run­IWDG();
179	          break;
180	        case '7' :
181	          TEST_PROTECTIONS_Run­TAMPER();
182	          break;
183	        case 'x' :
184	          exit = 1U;
185	          break;
186
187	        default:
188	          printf("Invalid Number !\r");
189	          break;
190	      }
191	      /*Print Main Menu message*/
192	      TEST_PROTECTIONS_Pri­ntTestingMenu();
193
194	    }
195	  }
196	}
197
198
199	/**
200	  * @}
201	  */
202
203	/**
204	  * @}
205	  */
206
207	/** @addtogroup  TEST_PROTECTIONS_Pri­vate_Functions
208	  * @{
209	  */
210
211	/**
212	  * @brief  Display the TEST Main Menu choices on HyperTerminal
213	  * @param  None.
214	  * @retval None.
215	  */
216	static void TEST_PROTECTIONS_Pri­ntTestingMenu(void)
217	{
218	  printf("\r\n=================== Test Menu ============================\r\n\n");
219	  printf("  Test : CORRUPT ACTIVE IMAGE --------------------------- 1\r\n\n");
220	  printf("  Test Protection: Firewall - CODE ---------------------- 2\r\n\n");
221	  printf("  Test Protection: Firewall - VDATA --------------------- 3\r\n\n");
222	  printf("  Test Protection: PCROP -------------------------------- 4\r\n\n");
223	  printf("  Test Protection: WRP ---------------------------------- 5\r\n\n");
224	  printf("  Test Protection: IWDG --------------------------------- 6\r\n\n");
225	  printf("  Test Protection: TAMPER ------------------------------- 7\r\n\n");
226	  printf("  Previous Menu ----------------------------------------- x\r\n\n");
227	  printf("  Selection :\r\n\n");
228	}
229
230	/**
231	  * @brief  TEST Run FWALL_CODE
232	  * @param  None.
233	  * @retval None.
234	  */
235	static void TEST_PROTECTIONS_Run­FWALL_CODE(void)
236	{
237
238	  /* 128 bit key + 1 char for NULL-terminated string */
239	  unsigned char key[17U];
240	  printf("\r\n====== Test Protection: Firewall - CODE =================\r\n\n");
241	  printf("  -- Reading Key\r\n\n");
242
243	  SE_ReadKey = (void (*)(unsigned char *))((unsigned char *)(TEST_PROTECTIONS_SE_­ISOLATED_CODE_READKE­Y_ADDRESS) + 1U);
244
245	  /* Executing Read Key Code into isolated enclave */
246	  SE_ReadKey(&(key[0U]));
247	  /* Add the string termination to have a proper display */
248	  key[16U] = '\0';
249
250	  /* Should not get here if isolated enclave is enabled  */
251	  printf("  -- Key: %s \r\n\n", key);
252	  printf("  -- !! Firewall CODE protection is NOT ENABLED !!\r\n\n");
253	}
254	/**
255	  * @brief  TEST Run FWALL_VDATA
256	  * @param  None.
257	  * @retval None.
258	  */
259	static void TEST_PROTECTIONS_Run­FWALL_VDATA(void)
260	{
261	  uint32_t u_read_fw_vdata = 0;
262	  printf("\r\n====== Test Protection: Firewall - VDATA ================\r\n\n");
263	  printf("  -- Reading address: 0x%x\r\n\n", TEST_PROTECTIONS_SE_­ISOLATED_VDATA_SRAM_­ADDRESS);
264
265	  /* Try to read a 32-bit data from the SRAM1 protected by the Firewall */
266	  u_read_fw_vdata = *((uint32_t *)TEST_PROTECTIONS_SE_­ISOLATED_VDATA_SRAM_­ADDRESS);
267
268	  /* Should not get here if firewall is available and enabled  */
269	  printf("  -- Address: 0x%x = %d\r\n\n", TEST_PROTECTIONS_SE_­ISOLATED_VDATA_SRAM_­ADDRESS, u_read_fw_vdata);
270	  printf("  -- !! Firewall VDATA protection is NOT ENABLED !!\r\n\n");
271	}
272
273	/**
274	  * @brief  TEST Run PCROP
275	  * @param  None.
276	  * @retval None.
277	  */
278	static void TEST_PROTECTIONS_Run­PCROP(void)
279	{
280	  uint8_t u_read_pcrop;
281	  uint8_t i = 0U;
282
283	  printf("\r\n====== Test Protection: PCROP ===========================\r\n\n");
284
285	  /* Enable IT on FLASH PCROP area read access*/
286	  /* This IT will  raise if PCROP code is accessed in read/write */
287
288	  printf("  -- Reading address: 0x%x\r\n\n     ", TEST_PROTECTIONS_PCR­OP_FLASH_ADDRESS);
289
290	  /* Try to read PCROP area*/
291	  while (i < TEST_PROTECTIONS_PCR­OP_SIZE)
292	  {
293	    u_read_pcrop = *((uint8_t *)(TEST_PROTECTIONS_PCR­OP_FLASH_ADDRESS + i));
294
295	    /* Error returned during programmation. */
296	    /* Check that RDERR flag is set */
297	    HAL_Delay(1);                                                 /* ensure Flag is set */
298	    if (__HAL_FLASH_GET_FLAG­(FLASH_FLAG_RDERR) != 0U)
299	    {
300	      printf("-- !! HAL_FLASH_ERROR_RD: FLASH Read Protection error flag (PCROP) !!\r\n\n");
301	      break;
302	    }
303	    else
304	    {
305	      /*Print of data read*/
306	      printf("0x%x ", u_read_pcrop);
307
308	      /* '/n' if needed*/
309	      if ((i + 1U) % 10U == 0U)
310	      {
311	        printf("\r\n     ");
312	      }
313	      i++;
314	    }
315	  }
316	  printf("\r\n\n");
317
318	  if (i == TEST_PROTECTIONS_PCR­OP_SIZE)
319	  {
320	    /*No Errors detected means PCROP was not enabled*/
321	    printf("  -- !! PCROP protection is NOT ENABLED !!\r\n\n");
322	  }
323
324	}
325
326
327	/**
328	  * @brief  TEST Run WRP
329	  * @param  None.
330	  * @retval None.
331	  */
332	static void TEST_PROTECTIONS_Run­WRP(void)
333	{
334	  uint32_t address = 0U;
335
336	  printf("\r\n====== Test Protection: WRP ===========================\r\n\n");
337
338	  address = TEST_PROTECTIONS_WRP­_FLASH_ADDRESS;
339
340	  /* 1 - Read Page to be used for restoring*/
341	  printf("  -- Reading 0x%x bytes at address: 0x%x (for backup)\r\n\n", TEST_PROTECTIONS_WRP­_FLASH_SIZE,
342	  TEST_PROTECTIONS_WRP­_FLASH_ADDRESS);
343
344	  for (uint32_t i = 0U; i < TEST_PROTECTIONS_WRP­_FLASH_SIZE; i++)
345	  {
346	  uRead_WRP[i] = *((uint8_t *)(address + i));
347	  }
348
349	  /* 2 - Erasing page */
350	  printf("  -- Erasing 0x%x bytes at address: 0x%x\r\n\n", TEST_PROTECTIONS_WRP­_FLASH_SIZE,
351	  TEST_PROTECTIONS_WRP­_FLASH_ADDRESS);
352
353	  /* Check that it is not allowed to erase this page */
354	  if (FLASH_If_Erase_Size((void *)address, TEST_PROTECTIONS_WRP­_FLASH_SIZE) != HAL_OK)
355	  {
356	    /* Error returned during programmation. */
357	    /* Check that WRPERR flag is set */
358	    if ((HAL_FLASH_GetError() & HAL_FLASH_ERROR_WRP) != 0U)
359	    {
360	      printf("-- !! HAL_FLASH_ERROR_WRP: FLASH Write protected error flag !!\r\n\n");
361	    }
362	  }
363	  else
364	  {
365	    /* 3 - Writing Data previously read*/
366	    if (FLASH_If_Write((void *)address, uRead_WRP, TEST_PROTECTIONS_WRP­_FLASH_SIZE) != HAL_OK)
367	    {
368	      /* Error returned during programmation. */
369	      printf("-- !! HAL_FLASH_ERROR: FLASH Write error\r\n\n");
370
371	      /* Check that WRPERR flag is set */
372	      if ((HAL_FLASH_GetError() & HAL_FLASH_ERROR_WRP) != 0U)
373	      {
374	        printf("-- !! HAL_FLASH_ERROR_WRP: FLASH Write protected error flag !!\r\n\n");
375	      }
376	    }
377	    else
378	    {
379	      printf("  -- Written successfully at address: 0x%x\r\n\n", TEST_PROTECTIONS_WRP­_FLASH_ADDRESS);
380
381	      /*No Errors detected means WRP was not enabled*/
382	      printf("  -- !! WRP protection is NOT ENABLED !!\r\n\n");
383	    }
384	  }
385	}
386
387	/**
388	  * @brief  TEST Run CORRUPT_IMAGE
389	  * @param  None.
390	  * @retval None.
391	  */
392	static void TEST_PROTECTIONS_Run­CORRUPT(uint32_t slot_number)
393	{
394	  HAL_StatusTypeDef ret = HAL_ERROR;
395	  uint8_t pattern[TEST_PROTECTIONS_COR­RUPT_IMAGE_FLASH_SIZ­E] = {0};
396
397	  /* On this series, MPU should be disable to allow flash corruption. */
398	  printf("  -- Disable MPU protection to be able to erase\r\n");
399	  HAL_MPU_Disable();
400
401	  /* Erase first sector of active slot */
402	  printf("  -- Erasing 0x%x bytes at address: 0x%x\r\n", TEST_PROTECTIONS_COR­RUPT_IMAGE_FLASH_SIZ­E,
403	         TEST_PROTECTIONS_COR­RUPT_IMAGE_FLASH_ADD­RESS(slot_number));
404	  printf("  -- At next boot Signature Verification will fail. Download a new FW to restore FW image !!\r\n\n");
405
406	  /* On this series, the memory corruption is performed by writing again the flash (but not header).
407	     The header is preserved for anti-rollback check. */
408	  ret = FLASH_If_Write((void *)(TEST_PROTECTIONS_COR­RUPT_IMAGE_FLASH_ADD­RESS(slot_number)), (void *) &pattern,
409	                       TEST_PROTECTIONS_COR­RUPT_IMAGE_FLASH_SIZ­E);
410
411	  /* This code may not be reached, due to the memory corruption performed.
412	     In this case, the execution will probably trig hard fault exception (while (1)),
413	     then watchdog reset. */
414	  if (ret == HAL_OK)
415	  {
416	    NVIC_SystemReset();
417	  }
418	  else
419	  {
420	    printf("-- !! HAL_FLASH_ERROR_CORR­UPT_IMAGE: erasing failure ...\r\n\n");
421	  }
422	}
423
424	/**
425	  * @brief  Display the corruption menu
426	  * @param  None.
427	  * @retval None.
428	  */
429	static void TEST_PROTECTIONS_COR­RUPT_PrintMenu(void)
430	{
431	  printf("\r\n============  Test: CORRUPT ACTIVE IMAGE ============\r\n\n");
432	  printf("  Corrupt image from SLOT_ACTIVE_1 ---------------------- 1\r\n\n");
433	  printf("  Corrupt image from SLOT_ACTIVE_2 ---------------------- 2\r\n\n");
434	  printf("  Corrupt image from SLOT_ACTIVE_3 ---------------------- 3\r\n\n");
435	  printf("  Previous Menu ----------------------------------------- x\r\n\n");
436	  printf("  Selection :\r\n\n");
437	}
438
439	/**
440	  * @brief  Run get firmware info menu.
441	  * @param  None
442	  * @retval HAL Status.
443	  */
444	static void TEST_PROTECTIONS_COR­RUPT_RunMenu(void)
445	{
446	  uint8_t key = 0U;
447	  uint32_t exit = 0U;
448	  uint32_t slot_number = 0U;
449
450	  /*Print Main Menu message*/
451	  TEST_PROTECTIONS_COR­RUPT_PrintMenu();
452
453	  while (exit == 0U)
454	  {
455	    key = 0U;
456	    slot_number = 0U;
457
458	    /* If the SecureBoot configured the IWDG, UserApp must reload IWDG counter with value defined in the reload
459	       register */
460	    WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
461
462	    /* Clean the input path */
463	    COM_Flush();
464
465	    /* Receive key */
466	    if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
467	    {
468	      switch (key)
469	      {
470	        case '1' :
471	          slot_number = SLOT_ACTIVE_1;
472	          break;
473	        case '2' :
474	          slot_number = SLOT_ACTIVE_2;
475	          break;
476	        case '3' :
477	          slot_number = SLOT_ACTIVE_3;
478	          break;
479	        case 'x' :
480	          exit = 1U;
481	          break;
482	        default:
483	          printf("Invalid Number !\r");
484	          break;
485	      }
486
487	      if (exit != 1U)
488	      {
489	        if (SlotStartAdd[slot_number] == 0U)
490	        {
491	          printf("SLOT_ACTIVE_%d is not configured !\r", slot_number);
492	        }
493	        else
494	        {
495	          TEST_PROTECTIONS_Run­CORRUPT(slot_number);
496	        }
497
498	        /*Print Main Menu message*/
499	        TEST_PROTECTIONS_COR­RUPT_PrintMenu();
500	      }
501	    }
502	  }
503	}
504
505
506	/**
507	  * @brief  TEST Run TAMPER
508	  * @param  None.
509	  * @retval None.
510	  */
511	static void TEST_PROTECTIONS_Run­TAMPER(void)
512	{
513	  uint32_t i = 0U;
514	  m_uTamperEvent = 0U;
515
516	  printf("\r\n====== Test Protection: TAMPER ========================\r\n\n");
517	  /* Print instructions*/
518	  printf("  -- Pull PA0 (CN7.28) to GND \r\n\n");
519	  printf("  -- -- Note: sometimes it may be enough to put your finger close to PA0 (CN7.28)\r\n\n");
520	  printf("  -- Should reset if TAMPER is enabled. \r\n\n");
521	  printf("  Waiting for 10 seconds...\r\n\n")  ;
522
523	  /*#2 - Wait 10 seconds*/
524	  while ((i < TEST_PROTECTIONS_TAM­PER_DELAY) && (m_uTamperEvent == 0U))
525	  {
526	    /* If the SecureBoot configured the IWDG, UserApp must reload IWDG counter with value defined in the reload register
527	     */
528	    WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
529	    HAL_Delay(1000U);
530	    i++;
531	  }
532	  if (m_uTamperEvent == 0U)
533	  {
534	    printf("\r\n\n  -- Waited 10 seconds, if you have connected TAMPER pin to GND it means TAMPER protection ");
535	    printf("is NOT ENABLED !! \r\n\n");
536	  }
537	  else
538	  {
539	    printf("\r\n\n  -- TAMPER Event detected!!\r\n\n  -- System reset requested!!!\r\n\n");
540	    NVIC_SystemReset();
541	  }
542	}
543
544	/**
545	  * @brief  TEST Run IWDG
546	  * @param  None.
547	  * @retval None.
548	  */
549	static void TEST_PROTECTIONS_Run­IWDG(void)
550	{
551	  printf("\r\n====== Test Protection: IWDG ===========================\r\n\n");
552
553	  /* Wait for TEST_PROTECTIONS_IWD­G_DELAY*/
554	  printf("  -- Waiting %d (ms). Should reset if IWDG is enabled. \r\n\n", TEST_PROTECTIONS_IWD­G_DELAY);
555
556	  HAL_Delay(TEST_PROTECTIONS_IWD­G_DELAY);
557
558	  /* No Reset means IWDG was not enabled*/
559	  printf("  -- !! IWDG protection is NOT ENABLED !!\r\n\n");
560	}
561
562	  /**
563	    * @}
564	  */
565
566	/** @defgroup TEST_PROTECTIONS_Cal­lback_Functions Callback Functions
567	  * @{
568	  */
569
570	/**
571	  * @brief  Implement the Cube_Hal Callback generated on the Tamper IRQ.
572	  * @param  None
573	  * @retval None
574	  */
575	void CALLBACK_Antitamper(void)
576	{
577	  /*Set tamper event variable*/
578	  m_uTamperEvent = 1U;
579	}
580
581	/**
582	  * @}
583	  */
584
585	/**
586	  * @}
587	  */
588
589	/**
590	  * @}
591	  */
592
593
L476_USER_APP\UserApp\Application\Core\Src\ymodem.c
1	/**
2	  ******************************************************************************
3	  * @file    ymodem.c
4	  * @author  MCD Application Team
5	  * @brief   Ymodem module.
6	  *          This file provides set of firmware functions to manage Ymodem
7	  *          functionalities.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/** @addtogroup USER_APP User App Example
22	  * @{
23	  */
24
25	/** @addtogroup  FW_UPDATE Firmware Update Example
26	  * @{
27	  */
28
29	/* Includes ------------------------------------------------------------------*/
30	#include "common.h"
31	#include "ymodem.h"
32	#include "string.h"
33	#include "main.h"
34
35	/* Private typedef -----------------------------------------------------------*/
36	/* Private define ------------------------------------------------------------*/
37	/* Private macro -------------------------------------------------------------*/
38	/* Private variables ---------------------------------------------------------*/
39	/* @note ATTENTION - please keep this variable 32bit aligned */
40	static uint8_t m_aPacketData[PACKET_1K_SIZE + PACKET_DATA_INDEX +
41	                             PACKET_TRAILER_SIZE] __attribute__((aligned(4))); /*!<Array used to store Packet Data*/
42	uint8_t m_aFileName[FILE_NAME_LENGTH + 1U]; /*!< Array used to store File Name data */
43	static CRC_HandleTypeDef CrcHandle; /*!<CRC handle*/
44
45	/* Private function prototypes -----------------------------------------------*/
46	static HAL_StatusTypeDef ReceivePacket(uint8_t *pData, uint32_t *puLength, uint32_t uTimeout);
47
48	/* Private functions ---------------------------------------------------------*/
49
50	/**
51	  * @brief  Receive a packet from sender
52	  * @param  pData
53	  * @param  puLength
54	  *     0: end of transmission
55	  *     2: abort by sender
56	  *    >0: packet length
57	  * @param  uTimeout
58	  * @retval HAL_OK: normally return
59	  *         HAL_BUSY: abort by user
60	  */
61	static HAL_StatusTypeDef ReceivePacket(uint8_t *pData, uint32_t *puLength, uint32_t uTimeout)
62	{
63	  uint32_t crc;
64	  uint32_t packet_size = 0U;
65	  HAL_StatusTypeDef status;
66	  uint8_t char1;
67	#ifdef MINICOM_YMODEM
68	  uint32_t myIdx = 0;
69	#endif /* MINICOM_YMODEM */
70
71	  *puLength = 0U;
72
73	  /* If the SecureBoot configured the IWDG, UserApp must reload IWDG counter with value defined in the
74	     reload register */
75	  WRITE_REG(IWDG->KR, IWDG_KEY_RELOAD);
76
77	  status = (HAL_StatusTypeDef)COM_Receive(&char1, 1, uTimeout);
78
79	  if (status == HAL_OK)
80	  {
81	    switch (char1)
82	    {
83	      /* start of 128-byte data packet */
84	      case SOH:
85	        packet_size = PACKET_SIZE;
86	        break;
87	      /* start of 1024-byte data packet */
88	      case STX:
89	        packet_size = PACKET_1K_SIZE;
90	        break;
91	      /* end of transmission */
92	      case EOT:
93	        break;
94	      /* CA + CA : transmission aborted by sender */
95	      case CA:
96	        if ((COM_Receive(&char1, 1U, uTimeout) == HAL_OK) && (char1 == CA))
97	        {
98	          packet_size = 2U;                               /* specific packet_size to indicate transmission aborted */
99	        }
100	        else
101	        {
102	          status = HAL_ERROR;
103	        }
104	        break;
105	      /* abort requested */
106	      case ABORT1:
107	      case ABORT2:
108	        status = HAL_BUSY;
109	        break;
110	      /* Begin of startup sequence */
111	      case RB:
112	        COM_Receive(&char1, 1U, uTimeout);                /* Ymodem startup sequence : rb ==> 0x72 + 0x62 + 0x0D */
113	        COM_Receive(&char1, 1U, uTimeout);
114	        packet_size = 3U;                                 /* specific packet_size to indicate transmission started */
115	        break;
116	      default:
117	        status = HAL_ERROR;
118	        break;
119	    }
120	    *pData = char1;
121
122	    if (packet_size >= PACKET_SIZE)
123	    {
124	#ifndef MINICOM_YMODEM
125	      /* Receiving the packet */
126	      status = COM_Receive(&pData[PACKET_NUMBER_INDEX], packet_size + PACKET_OVERHEAD_SIZE­, uTimeout);
127	#else
128	      status = HAL_OK;
129	      while ((HAL_OK == status) &&
130	             ((myIdx + PACKET_NUMBER_INDEX) < (PACKET_1K_SIZE + PACKET_DATA_INDEX + PACKET_TRAILER_SIZE))
131	            )
132	      {
133	        status = COM_Receive(&pData[PACKET_NUMBER_INDEX + myIdx], 1, uTimeout);
134	        myIdx++;
135	      }
136
137	      if (myIdx > 1)
138	      {
139	        status = HAL_OK;
140	      }
141	#endif /* MINICOM_YMODEM */
142
143	      /* Simple packet sanity check */
144	      if (status == HAL_OK)
145	      {
146	        if (pData[PACKET_NUMBER_INDEX] != ((pData[PACKET_CNUMBER_INDEX­]) ^ NEGATIVE_BYTE))
147	        {
148	          /* Packet size set to 0 in case of sanity check error */
149	          packet_size = 0U;
150	          status = HAL_ERROR;
151	        }
152	        else
153	        {
154	          /* Check packet CRC */
155	          crc = pData[ packet_size + PACKET_DATA_INDEX ] << 8U;
156	          crc += pData[ packet_size + PACKET_DATA_INDEX + 1U ];
157	          if (HAL_CRC_Calculate(&CrcHandle, (uint32_t *)&pData[PACKET_DATA_INDEX], packet_size) != crc)
158	          {
159	            /* Packet size set to 0 in case of CRC error */
160	            packet_size = 0U;
161	            status = HAL_ERROR;
162	          }
163	        }
164	      }
165	      else
166	      {
167	        /* Packet size set to 0 in case of reception error */
168	        packet_size = 0U;
169	      }
170	    }
171	  }
172
173	  /* Update the length parameter */
174	  *puLength = packet_size;
175	  return status;
176	}
177
178
179	/**
180	  * @brief  Init of Ymodem module.
181	  * @param None.
182	  * @retval None.
183	  */
184	void Ymodem_Init(void)
185	{
186	  __HAL_RCC_CRC_CLK_EN­ABLE();
187
188	  /* Configure the CRC peripheral */
189	  CrcHandle.Instance = CRC;
190
191	  /* The CRC-16-CCIT polynomial is used */
192	  CrcHandle.Init.DefaultPolynomialUse­    = DEFAULT_POLYNOMIAL_D­ISABLE;
193	  CrcHandle.Init.GeneratingPolynomial­    = 0x1021U;
194	  CrcHandle.Init.CRCLength               = CRC_POLYLENGTH_16B;
195
196	  /* The zero init value is used */
197	  CrcHandle.Init.DefaultInitValueUse     = DEFAULT_INIT_VALUE_D­ISABLE;
198	  CrcHandle.Init.InitValue               = 0U;
199
200	  /* The input data are not inverted */
201	  CrcHandle.Init.InputDataInversionMo­de  = CRC_INPUTDATA_INVERS­ION_NONE;
202
203	  /* The output data are not inverted */
204	  CrcHandle.Init.OutputDataInversionM­ode = CRC_OUTPUTDATA_INVER­SION_DISABLE;
205
206	  /* The input data are 32-bit long words */
207	  CrcHandle.InputDataFormat              = CRC_INPUTDATA_FORMAT­_BYTES;
208
209	  if (HAL_CRC_Init(&CrcHandle) != HAL_OK)
210	  {
211	    /* Initialization Error */
212	    while (1U)
213	    {}
214	  }
215	}
216
217
218	/* Public functions ---------------------------------------------------------*/
219	/**
220	  * @brief  Receive a file using the ymodem protocol with CRC16.
221	  * @param  puSize The uSize of the file.
222	  * @param  uFlashDestination where the file has to be downloaded.
223	  * @retval COM_StatusTypeDef result of reception/programming
224	  */
225	COM_StatusTypeDef Ymodem_Receive(uint32_t *puSize, uint32_t uFlashDestination, YMODEM_CallbacksType­Def *appCb)
226	{
227	  uint32_t i;
228	  uint32_t packet_length;
229	  uint32_t session_done = 0U;
230	  uint32_t file_done;
231	  uint32_t errors = 0U;
232	  uint32_t session_begin = 0U;
233	  uint32_t ramsource;
234	  uint32_t filesize = 0U;
235	  uint8_t *file_ptr;
236	  uint8_t file_size[FILE_SIZE_LENGTH + 1U];
237	  uint8_t tmp;
238	  uint32_t packets_received;
239	  COM_StatusTypeDef e_result = COM_OK;
240
241	  while ((session_done == 0U) && (e_result == COM_OK))
242	  {
243	    packets_received = 0U;
244	    file_done = 0U;
245	    while ((file_done == 0U) && (e_result == COM_OK))
246	    {
247	      switch (ReceivePacket(m_aPacketData, &packet_length, DOWNLOAD_TIMEOUT))
248	      {
249	        case HAL_OK:
250	          errors = 0U;
251	          switch (packet_length)
252	          {
253	            case 3U:
254	              /* Startup sequence */
255	              break;
256	            case 2U:
257	              /* Abort by sender */
258	              Serial_PutByte(ACK);
259	              e_result = COM_ABORT;
260	              break;
261	            case 0U:
262	              /* End of transmission */
263	              Serial_PutByte(ACK);
264	              *puSize = filesize;
265	              file_done = 1U;           /* file reception ended */
266	              break;
267	            default:
268	              /* Normal packet */
269	              if (m_aPacketData[PACKET_NUMBER_INDEX] != (packets_received & 0xff))
270	              {
271	                /* Serial_PutByte(NAK); */
272	              }
273	              else
274	              {
275	                /* first packet : header (file name + file size) */
276	                if (packets_received == 0U)
277	                {
278	                  /* File name packet */
279	                  if (m_aPacketData[PACKET_DATA_INDEX] != 0U)
280	                  {
281	                    /* File name extraction */
282	                    i = 0U;
283	                    file_ptr = m_aPacketData + PACKET_DATA_INDEX;
284	                    while ((*file_ptr != 0U) && (i < FILE_NAME_LENGTH))
285	                    {
286	                      m_aFileName[i++] = *file_ptr++;
287	                    }
288
289	                    /* File size extraction */
290	                    m_aFileName[i++] = '\0';
291	                    i = 0U;
292	                    file_ptr ++;
293	                    while ((*file_ptr != ' ') && (i < FILE_SIZE_LENGTH))
294	                    {
295	                      file_size[i++] = *file_ptr++;
296	                    }
297	                    file_size[i++] = '\0';
298	                    Str2Int(file_size, &filesize);
299
300	                    /* Header packet received callback call */
301	                    if (appCb->Ymodem_HeaderPktRxCp­ltCallback((uint32_t) filesize) == HAL_OK)
302	                    {
303	                      /* Send acknowledge and next packet requested */
304	                      Serial_PutByte(ACK);
305	                      COM_Flush();
306	                      Serial_PutByte(CRC16);
307	                    }
308	                    else
309	                    {
310	                      /* In case of error : transmission aborted
311	                         Send CA + CA */
312	                      tmp = CA;
313	                      COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
314	                      COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
315	                      e_result = COM_ABORT;
316	                      break;
317	                    }
318
319	                  }
320	                  /* File header packet is empty, end session */
321	                  else
322	                  {
323	                    Serial_PutByte(ACK);
324	                    file_done = 1;           /* file reception ended */
325	                    session_done = 1;        /* session ended */
326	                    break;
327	                  }
328	                }
329	                else /* Data packet */
330	                {
331	                  ramsource = (uint32_t) & m_aPacketData[PACKET_DATA_INDEX];
332
333	                  /* Data packet received callback call*/
334	                  if (appCb->Ymodem_DataPktRxCplt­Callback((uint8_t *) ramsource, uFlashDestination,
335	                                                          (uint32_t) packet_length) == HAL_OK)
336	                  {
337	                    /* Packet acknowledged : newt one requested */
338	                    Serial_PutByte(ACK);
339	                  }
340	                  else /* An error occurred while writing to Flash memory */
341	                  {
342	                    /* Abort transmission : CA + CA */
343	                    tmp = CA;
344	                    COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
345	                    COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
346	                    e_result = COM_ERROR;
347	                  }
348	                }
349	                packets_received ++;
350	                session_begin = 1U;
351	              }
352	              break;
353	          }
354	          break;
355	        case HAL_BUSY: /* Abort actually */
356	          Serial_PutByte(CA);
357	          Serial_PutByte(CA);
358	          e_result = COM_ABORT;
359	          break;
360	        default:
361	          /* Com aborted after 5 consecutives error */
362	          if (session_begin > 0U)
363	          {
364	            errors ++;
365	          }
366	          if (errors > MAX_ERRORS)
367	          {
368	            /* Abort communication */
369	            Serial_PutByte(CA);
370	            Serial_PutByte(CA);
371	            e_result = COM_ABORT;
372	          }
373	          else
374	          {
375	            Serial_PutByte(CRC16); /* Ask for a packet */
376	#ifndef MINICOM_YMODEM
377	            printf("\b.");         /* Replace C char by . on display console */
378	#endif /* MINICOM_YMODEM */
379	          }
380	          break;
381	      }
382	    }
383	  }
384	  return e_result;
385	}
386
387	/**
388	  * @}
389	  */
390
391	/**
392	  * @}
393	  */
394
L476_USER_APP\UserApp\Application\User\syscalls.c
1	/**
2	*****************************************************************************
3	**
4	**  File        : syscalls.c
5	**
6	**  Abstract    : System Workbench Minimal System calls file
7	**
8	** 		          For more information about which c-functions
9	**                need which of these lowlevel functions
10	**                please consult the Newlib libc-manual
11	**
12	**  Environment : System Workbench for MCU
13	**
14	**  Distribution: The file is distributed �as is,� without any warranty
15	**                of any kind.
16	**
17	**  (c)Copyright System Workbench for MCU.
18	**  You may use this file as-is or modify it according to the needs of your
19	**  project. Distribution of this file (unmodified or modified) is not
20	**  permitted. System Workbench for MCU permit registered System Workbench(R) users the
21	**  rights to distribute the assembled, compiled & linked contents of this
22	**  file as part of an application binary file, provided that it is built
23	**  using the System Workbench for MCU toolchain.
24	**
25	*****************************************************************************
26	*/
27
28	/* Includes */
29	#include <sys/stat.h>
30	#include <stdlib.h>
31	#include <errno.h>
32	#include <stdio.h>
33	#include <signal.h>
34	#include <time.h>
35	#include <sys/time.h>
36	#include <sys/times.h>
37
38
39	/* Variables */
40	//#undef errno
41	extern int errno;
42	//#define FreeRTOS
43	//#define MAX_STACK_SIZE 0x2000
44
45	extern int __io_putchar(int ch) __attribute__((weak));
46	extern int __io_getchar(void) __attribute__((weak));
47
48	#ifndef FreeRTOS
49	  register char * stack_ptr asm("sp");
50	#endif
51
52
53	register char * stack_ptr asm("sp");
54
55	char *__env[1] = { 0 };
56	char **environ = __env;
57
58
59	/* Functions */
60	void initialise_monitor_h­andles()
61	{
62	}
63
64	int _getpid(void)
65	{
66		return 1;
67	}
68
69	int _kill(int pid, int sig)
70	{
71		errno = EINVAL;
72		return -1;
73	}
74
75	void _exit (int status)
76	{
77		_kill(status, -1);
78		while (1) {}		/* Make sure we hang here */
79	}
80
81	int _read (int file, char *ptr, int len)
82	{
83		int DataIdx;
84
85		for (DataIdx = 0; DataIdx < len; DataIdx++)
86		{
87			*ptr++ = __io_getchar();
88		}
89
90	return len;
91	}
92
93	int _write(int file, char *ptr, int len)
94	{
95		int DataIdx;
96
97		for (DataIdx = 0; DataIdx < len; DataIdx++)
98		{
99			__io_putchar(*ptr++);
100		}
101		return len;
102	}
103
104	caddr_t _sbrk(int incr)
105	{
106		extern char end asm("end");
107		static char *heap_end;
108		char *prev_heap_end;
109
110		if (heap_end == 0)
111			heap_end = &end;
112
113		prev_heap_end = heap_end;
114		if (heap_end + incr > stack_ptr)
115		{
116	//		write(1, "Heap and stack collision\n", 25);
117	//		abort();
118			errno = ENOMEM;
119			return (caddr_t) -1;
120		}
121
122		heap_end += incr;
123
124		return (caddr_t) prev_heap_end;
125	}
126
127	int _close(int file)
128	{
129		return -1;
130	}
131
132
133	int _fstat(int file, struct stat *st)
134	{
135		st->st_mode = S_IFCHR;
136		return 0;
137	}
138
139	int _isatty(int file)
140	{
141		return 1;
142	}
143
144	int _lseek(int file, int ptr, int dir)
145	{
146		return 0;
147	}
148
149	int _open(char *path, int flags, ...)
150	{
151		/* Pretend like we always fail */
152		return -1;
153	}
154
155	int _wait(int *status)
156	{
157		errno = ECHILD;
158		return -1;
159	}
160
161	int _unlink(char *name)
162	{
163		errno = ENOENT;
164		return -1;
165	}
166
167	int _times(struct tms *buf)
168	{
169		return -1;
170	}
171
172	int _stat(char *file, struct stat *st)
173	{
174		st->st_mode = S_IFCHR;
175		return 0;
176	}
177
178	int _link(char *old, char *new)
179	{
180		errno = EMLINK;
181		return -1;
182	}
183
184	int _fork(void)
185	{
186		errno = EAGAIN;
187		return -1;
188	}
189
190	int _execve(char *name, char **argv, char **env)
191	{
192		errno = ENOMEM;
193		return -1;
194	}
195
L476_USER_APP\UserApp\Doc\readme.txt

/**
  @page Secure Firmware Update - User Application Demo

  @verbatim
  ******************** (C) COPYRIGHT 2017 STMicroelectronics *******************
  * @file    readme.txt
  * @brief   This application shows a User Application
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @endverbatim

@par Application Description

This application demonstrates firmware download capabilities and provides a set of functions to test the active
protections offered by Secure Boot and Secure Engine.
A terminal connected with the board via VCOM is needed to communicate with the board and to select which feature
to demonstrate.

For more details, refer to UM2262 "Getting started with SBSFU - software expansion for STM32Cube" available from
the STMicroelectronics microcontroller website www.st.com.

@par Directory contents

   - 2_Images_UserApp/Src/com.c                      Communication module file
   - 2_Images_UserApp/Src/common.c                   Common module file
   - 2_Images_UserApp/Src/flash_if.c                 Flash interface file
   - 2_Images_UserApp/Src/fw_update_app.c            Firmware update application
   - 2_Images_UserApp/Src/main.c                     Main program
   - 2_Images_UserApp/Src/se_user_code.c             Call user defined services running in Secure Engine
   - 2_Images_UserApp/Src/sfu_app_new_image.c        Manage the new firmware image storage and installation
   - 2_Images_UserApp/Src/stm32l4xx_it.c             Interrupt handlers
   - 2_Images_UserApp/Src/system_stm32l4xx.c         STM32 system file
   - 2_Images_UserApp/Src/test_protections.c         Protection test
   - 2_Images_UserApp/Src/ymodem.c                   Ymodem communication module
   - 2_Images_UserApp/Inc/com.h                      Header for com.c file
   - 2_Images_UserApp/Inc/common.h                   Header for common.c file
   - 2_Images_UserApp/Inc/flash_if.h                 Header for flash_if.c file
   - 2_Images_UserApp/Inc/fw_update_app.h            Header for fw_update_app.c file
   - 2_Images_UserApp/Inc/main.h                     Header for main.c file
   - 2_Images_UserApp/Inc/se_user_code.h             Header file for se_user_code.c
   - 2_Images_UserApp/Inc/sfu_app_new_image.h        Header file for sfu_app_new_image.c
   - 2_Images_UserApp/Inc/stm32l4xx_conf.h           HAL configuration file
   - 2_Images_UserApp/Inc/stm32l4xx_it.h             Header for stm32l4xx_it.c file
   - 2_Images_UserApp/Inc/test_protections.h         Header for test_protections.c file
   - 2_Images_UserApp/Inc/ymodem.h                   Header for ymodem.c file

@par Hardware and Software environment

   - This example runs on STM32L476xx devices.
   - This example has been tested with STM32L476RG-Nucleo Rev C board and can be easily tailored to any other supported device and
     development board.
   - An up-to-date version of ST-LINK firmware is required. Upgrading ST-LINK firmware is a feature provided by
     STM32Cube programmer available on www.st.com.
   - This example is based on se_interface_application.o module exported by SBSFU project.
   - This example needs a terminal emulator.
   - Microsoft Windows has a limitation whereby paths to files and directories cannot be longer than 256 characters.
     Paths to files exceeding that limits cause tools (e.g. compilers, shell scripts) to fail reading from or writing to
     such files.
     As a workaround, it is advised to use the subst.exe command from within a command prompt to set up a local drive
     out of an existing directory on the hard drive, such as:
     C:\> subst X: <PATH_TO_CUBEFW>\Firmware

@par IDE postbuild script

In order to ease the development process, a postbuild script ("postbuild.bat") is integrated in each IDE project.
This postbuild script:
   - is generated when compiling the Secure Engine Core project,
   - prepares the firmware image of the user application to be installed in the device.
   - prepares the new portion of firmware image: part of firmware image which changed vs a reference firmware image.
     The reference firmware image is provided to the postbuild script by manually copying the UserApp.bin of the running
     application into RefUserApp.bin (in folder 2_Images_UserApp/IDE).

     As an example, once original user application has been build, downloaded and installed, you may create the
     RefUserApp.bin, then change UserAppId constant from 'A' to 'B' in source file main.c, then build again the user
     application.
     At post processing stage, the portion of code containing the UserAppId will be identified as a difference vs the
     reference binary file and a PartialUserApp.sfb will be generated in 2_Images_UserApp/Binary folder.

A known limitation of this integration occurs when you update the firmware version (parameter of postbuild.bat script).
The IDE does not track this update so you need to force the rebuild of the project manually.

@par How to use it ?

Refer to SBSFU readme and follow steps by steps instructions.

Once executed, this user application gives access to a menu which allows:
   1 - to download a new firmware
   2 - to test protections (Firewall, PCROP, WRP, IWDG, TAMPER)
   3 - to demonstrate how to call user defined services running in Secure Engine
   4 - to provide access to multiple images feature
   5 - to validate a firmware image at first start-up

1. Pressing 1 allows to download a new firmware.
Send the user encrypted firmware file (.sfb) with Tera Term by using menu "File > Transfer > YMODEM > Send..."
After the download, the system reboots.
The downloaded encrypted firmware is detected, decrypted, installed and executed.

The downloaded image can be either a complete UserApp.sfb or a PartialUserApp.sfb.
To download a PartialUserApp.sfb, it is mandatory to have previously installed the UserApp.sfb identified as reference
into the device.

2. Pressing 2 allows to test protections.
   - CORRUPT IMAGE test (#1): causes a signature verification failure of the selected firmware image at next boot.
   - Firewall tests (#2, #3): cause a reset trying to access protected code or data (either in RAM or FLASH).
   - PCROP test (#4): causes an error trying to access the PCROP region protecting the keys. If activated, Firewall will
     trigger a reset prior to this error.
   - WRP test (#5): causes an error trying to erase write protected code.
   - IWDG test (#6): causes a reset simulating a deadlock by not refreshing the watchdog.
   - TAMPER test (#7): causes a reset if a tamper event is detected. In order to generate a tamper event, user has to
     connect PA0 (CN7.28) to GND (It may be enough to put your finger close to PA0 (CN7.28)).
     Several resets may be generated during this test.
     It may be better to have PA0 (CN7.28) connected to 3V3 before doing the transition to GND.

3. Pressing 3 allows to call user defined services running in Secure Engine.
As an example, after selecting the firmware image, SE_APP_GetActiveFwInfo service is called in order
to display the information located in the protected area such as version and size.

4. This menu is dedicated to multiple images feature.
Feature not available as there is only 1 download area configured.

5. This menu is dedicated to image validation.
Feature not supported in this example.


Note1 : There is only 1 active slot configured in this example.
Note2 : for Linux users Minicom can be used but to do so you need to compile the UserApp project with the MINICOM_YMODEM
        switch enabled (ymodem.h)

L476_USER_APP\UserApp\Drivers\CMSIS\system_stm32l4xx.c
1	/**
2	  ******************************************************************************
3	  * @file    system_stm32l4xx.c
4	  * @author  MCD Application Team
5	  * @brief   CMSIS Cortex-M4 Device Peripheral Access Layer System Source File
6	  *
7	  *   This file provides two functions and one global variable to be called from
8	  *   user application:
9	  *      - SystemInit(): This function is called at startup just after reset and
10	  *                      before branch to main program. This call is made inside
11	  *                      the "startup_stm32l4xx.s" file.
12	  *
13	  *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used
14	  *                                  by the user application to setup the SysTick
15	  *                                  timer or configure other parameters.
16	  *
17	  *      - SystemCoreClockUpdat­e(): Updates the variable SystemCoreClock and must
18	  *                                 be called whenever the core clock is changed
19	  *                                 during program execution.
20	  *
21	  *   After each device reset the MSI (4 MHz) is used as system clock source.
22	  *   Then SystemInit() function is called, in "startup_stm32l4xx.s" file, to
23	  *   configure the system clock before to branch to main program.
24	  *
25	  *   This file configures the system clock as follows:
26	  *=============================================================================
27	  *-----------------------------------------------------------------------------
28	  *        System Clock source                    | MSI
29	  *-----------------------------------------------------------------------------
30	  *        SYSCLK(Hz)                             | 4000000
31	  *-----------------------------------------------------------------------------
32	  *        HCLK(Hz)                               | 4000000
33	  *-----------------------------------------------------------------------------
34	  *        AHB Prescaler                          | 1
35	  *-----------------------------------------------------------------------------
36	  *        APB1 Prescaler                         | 1
37	  *-----------------------------------------------------------------------------
38	  *        APB2 Prescaler                         | 1
39	  *-----------------------------------------------------------------------------
40	  *        PLL_M                                  | 1
41	  *-----------------------------------------------------------------------------
42	  *        PLL_N                                  | 8
43	  *-----------------------------------------------------------------------------
44	  *        PLL_P                                  | 7
45	  *-----------------------------------------------------------------------------
46	  *        PLL_Q                                  | 2
47	  *-----------------------------------------------------------------------------
48	  *        PLL_R                                  | 2
49	  *-----------------------------------------------------------------------------
50	  *        PLLSAI1_P                              | NA
51	  *-----------------------------------------------------------------------------
52	  *        PLLSAI1_Q                              | NA
53	  *-----------------------------------------------------------------------------
54	  *        PLLSAI1_R                              | NA
55	  *-----------------------------------------------------------------------------
56	  *        PLLSAI2_P                              | NA
57	  *-----------------------------------------------------------------------------
58	  *        PLLSAI2_Q                              | NA
59	  *-----------------------------------------------------------------------------
60	  *        PLLSAI2_R                              | NA
61	  *-----------------------------------------------------------------------------
62	  *        Require 48MHz for USB OTG FS,          | Disabled
63	  *        SDIO and RNG clock                     |
64	  *-----------------------------------------------------------------------------
65	  *=============================================================================
66	  ******************************************************************************
67	  * @attention
68	  *
69	  * Copyright (c) 2017 STMicroelectronics.
70	  * All rights reserved.
71	  *
72	  * This software is licensed under terms that can be found in the LICENSE file in
73	  * the root directory of this software component.
74	  * If no LICENSE file comes with this software, it is provided AS-IS.
75	  *
76	  ******************************************************************************
77	  */
78
79	/** @addtogroup CMSIS
80	  * @{
81	  */
82
83	/** @addtogroup stm32l4xx_system
84	  * @{
85	  */
86
87	/** @addtogroup STM32L4xx_System_Pri­vate_Includes
88	  * @{
89	  */
90
91	#include "stm32l4xx.h"
92
93	#if !defined  (HSE_VALUE)
94	  #define HSE_VALUE    8000000U  /*!< Value of the External oscillator in Hz */
95	#endif /* HSE_VALUE */
96
97	#if !defined  (MSI_VALUE)
98	  #define MSI_VALUE    4000000U  /*!< Value of the Internal oscillator in Hz*/
99	#endif /* MSI_VALUE */
100
101	#if !defined  (HSI_VALUE)
102	  #define HSI_VALUE    16000000U /*!< Value of the Internal oscillator in Hz*/
103	#endif /* HSI_VALUE */
104
105	/**
106	  * @}
107	  */
108
109	/** @addtogroup STM32L4xx_System_Pri­vate_TypesDefinition­s
110	  * @{
111	  */
112
113	/**
114	  * @}
115	  */
116
117	/** @addtogroup STM32L4xx_System_Pri­vate_Defines
118	  * @{
119	  */
120
121	/************************* Miscellaneous Configuration ************************/
122	/*!< Uncomment the following line if you need to relocate your vector Table in
123	     Internal SRAM. */
124	/* #define VECT_TAB_SRAM */
125	#define VECT_TAB_OFFSET  0x00 /*!< Vector Table base offset field.
126	                                   This value must be a multiple of 0x200. */
127	/******************************************************************************/
128	/**
129	  * @}
130	  */
131
132	/** @addtogroup STM32L4xx_System_Pri­vate_Macros
133	  * @{
134	  */
135
136	/**
137	  * @}
138	  */
139
140	/** @addtogroup STM32L4xx_System_Pri­vate_Variables
141	  * @{
142	  */
143	  /* The SystemCoreClock variable is updated in three ways:
144	      1) by calling CMSIS function SystemCoreClockUpdat­e()
145	      2) by calling HAL API function HAL_RCC_GetHCLKFreq()
146	      3) each time HAL_RCC_ClockConfig() is called to configure the system clock frequency
147	         Note: If you use this function to configure the system clock; then there
148	               is no need to call the 2 first functions listed above, since SystemCoreClock
149	               variable is updated automatically.
150	  */
151	  uint32_t SystemCoreClock = 4000000U;
152
153	  const uint8_t  AHBPrescTable[16] = {0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 1U, 2U, 3U, 4U, 6U, 7U, 8U, 9U};
154	  const uint8_t  APBPrescTable[8] =  {0U, 0U, 0U, 0U, 1U, 2U, 3U, 4U};
155	  const uint32_t MSIRangeTable[12] = {100000U,   200000U,   400000U,   800000U,  1000000U,  2000000U, \
156	                                      4000000U, 8000000U, 16000000U, 24000000U, 32000000U, 48000000U};
157	/**
158	  * @}
159	  */
160
161	/** @addtogroup STM32L4xx_System_Pri­vate_FunctionPrototy­pes
162	  * @{
163	  */
164
165	/**
166	  * @}
167	  */
168
169	/** @addtogroup STM32L4xx_System_Pri­vate_Functions
170	  * @{
171	  */
172	#if defined(__ICCARM__)
173	extern uint32_t __vector_table;
174	#define INTVECT_START ((uint32_t)& __vector_table)
175	#elif defined(__CC_ARM) || defined(__ARMCC_VERSION)
176	extern void * __Vectors;
177	#define INTVECT_START ((uint32_t) & __Vectors)
178	#elif defined(__GNUC__)
179	extern void * g_pfnVectors;
180	#define INTVECT_START ((uint32_t)& g_pfnVectors)
181	#endif
182
183	/**
184	  * @brief  Setup the microcontroller system.
185	  * @param  None
186	  * @retval None
187	  */
188
189	void SystemInit(void)
190	{
191	  /* FPU settings ------------------------------------------------------------*/
192	  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
193	    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
194	  #endif
195
196	  /* Reset the RCC clock configuration to the default reset state ------------*/
197	  /* Set MSION bit */
198	  RCC->CR |= RCC_CR_MSION;
199
200	  /* Reset CFGR register */
201	  RCC->CFGR = 0x00000000U;
202
203	  /* Reset HSEON, CSSON , HSION, and PLLON bits */
204	  RCC->CR &= 0xEAF6FFFFU;
205
206	  /* Reset PLLCFGR register */
207	  RCC->PLLCFGR = 0x00001000U;
208
209	  /* Reset HSEBYP bit */
210	  RCC->CR &= 0xFFFBFFFFU;
211
212	  /* Disable all interrupts */
213	  RCC->CIER = 0x00000000U;
214
215	  /* Configure the Vector Table location  ------------------*/
216	  /* Reuse information from map file */
217	  SCB->VTOR = INTVECT_START;
218	}
219
220	/**
221	  * @brief  Update SystemCoreClock variable according to Clock Register Values.
222	  *         The SystemCoreClock variable contains the core clock (HCLK), it can
223	  *         be used by the user application to setup the SysTick timer or configure
224	  *         other parameters.
225	  *
226	  * @note   Each time the core clock (HCLK) changes, this function must be called
227	  *         to update SystemCoreClock variable value. Otherwise, any configuration
228	  *         based on this variable will be incorrect.
229	  *
230	  * @note   - The system frequency computed by this function is not the real
231	  *           frequency in the chip. It is calculated based on the predefined
232	  *           constant and the selected clock source:
233	  *
234	  *           - If SYSCLK source is MSI, SystemCoreClock will contain the MSI_VALUE(*)
235	  *
236	  *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(**)
237	  *
238	  *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(***)
239	  *
240	  *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(***)
241	  *             or HSI_VALUE(*) or MSI_VALUE(*) multiplied/divided by the PLL factors.
242	  *
243	  *         (*) MSI_VALUE is a constant defined in stm32l4xx_hal.h file (default value
244	  *             4 MHz) but the real value may vary depending on the variations
245	  *             in voltage and temperature.
246	  *
247	  *         (**) HSI_VALUE is a constant defined in stm32l4xx_hal.h file (default value
248	  *              16 MHz) but the real value may vary depending on the variations
249	  *              in voltage and temperature.
250	  *
251	  *         (***) HSE_VALUE is a constant defined in stm32l4xx_hal.h file (default value
252	  *              8 MHz), user has to ensure that HSE_VALUE is same as the real
253	  *              frequency of the crystal used. Otherwise, this function may
254	  *              have wrong result.
255	  *
256	  *         - The result of this function could be not correct when using fractional
257	  *           value for HSE crystal.
258	  *
259	  * @param  None
260	  * @retval None
261	  */
262	void SystemCoreClockUpdat­e(void)
263	{
264	  uint32_t tmp = 0U, msirange = 0U, pllvco = 0U, pllr = 2U, pllsource = 0U, pllm = 2U;
265
266	  /* Get MSI Range frequency--------------------------------------------------*/
267	  if((RCC->CR & RCC_CR_MSIRGSEL) == RESET)
268	  { /* MSISRANGE from RCC_CSR applies */
269	    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
270	  }
271	  else
272	  { /* MSIRANGE from RCC_CR applies */
273	    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
274	  }
275	  /*MSI frequency range in HZ*/
276	  msirange = MSIRangeTable[msirange];
277
278	  /* Get SYSCLK source -------------------------------------------------------*/
279	  switch (RCC->CFGR & RCC_CFGR_SWS)
280	  {
281	    case 0x00:  /* MSI used as system clock source */
282	      SystemCoreClock = msirange;
283	      break;
284
285	    case 0x04:  /* HSI used as system clock source */
286	      SystemCoreClock = HSI_VALUE;
287	      break;
288
289	    case 0x08:  /* HSE used as system clock source */
290	      SystemCoreClock = HSE_VALUE;
291	      break;
292
293	    case 0x0C:  /* PLL used as system clock  source */
294	      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
295	         SYSCLK = PLL_VCO / PLLR
296	         */
297	      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
298	      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
299
300	      switch (pllsource)
301	      {
302	        case 0x02:  /* HSI used as PLL clock source */
303	          pllvco = (HSI_VALUE / pllm);
304	          break;
305
306	        case 0x03:  /* HSE used as PLL clock source */
307	          pllvco = (HSE_VALUE / pllm);
308	          break;
309
310	        default:    /* MSI used as PLL clock source */
311	          pllvco = (msirange / pllm);
312	          break;
313	      }
314	      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
315	      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
316	      SystemCoreClock = pllvco/pllr;
317	      break;
318
319	    default:
320	      SystemCoreClock = msirange;
321	      break;
322	  }
323	  /* Compute HCLK clock frequency --------------------------------------------*/
324	  /* Get HCLK prescaler */
325	  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4U)];
326	  /* HCLK clock frequency */
327	  SystemCoreClock >>= tmp;
328	}
329
330
331	/**
332	  * @}
333	  */
334
335	/**
336	  * @}
337	  */
338
339	/**
340	  * @}
341	  */
342
L476_USER_APP\UserApp\Output\crypto.txt

SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM

L476_USER_APP\UserApp\Output\output.txt

prebuild.sh : started
prepareimage with windows executable
 C:/Users/Menachem Fried/OneDrive - Binata/SBSFU_NUCLEO_L476/Project/L476_SBSFU/Common/KeysAndImages_Util/win/prepareimage/prepareimage.exe
SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM selected

L476_USER_APP\UserApp\Startup\startup_stm32l476xx.s

/**
  ******************************************************************************
  * @file      startup_stm32l476xx.s
  * @author    MCD Application Team
  * @brief     STM32L476xx devices vector table GCC toolchain.
  *            This module performs:
  *                - Set the initial SP
  *                - Set the initial PC == Reset_Handler,
  *                - Set the vector table entries with the exceptions ISR address,
  *                - Configure the clock system
  *                - Branches to main in the C library (which eventually
  *                  calls main()).
  *            After Reset the Cortex-M4 processor is in Thread mode,
  *            priority is Privileged, and the Stack is set to Main.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

  .syntax unified
	.cpu cortex-m4
	.fpu softvfp
	.thumb

.global	g_pfnVectors
.global	Default_Handler

/* start address for the initialization values of the .data section.
defined in linker script */
.word	_sidata
/* start address for the .data section. defined in linker script */
.word	_sdata
/* end address for the .data section. defined in linker script */
.word	_edata
/* start address for the .bss section. defined in linker script */
.word	_sbss
/* end address for the .bss section. defined in linker script */
.word	_ebss

.equ  BootRAM,        0xF1E0F85F
/**
 * @brief  This is the code that gets called when the processor first
 *          starts execution following a reset event. Only the absolutely
 *          necessary set is performed, after which the application
 *          supplied main() routine is called.
 * @param  None
 * @retval : None
*/

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
	b	LoopFillZerobss
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
	cmp	r2, r3
	bcc	FillZerobss

/* Call the clock system initialization function.*/
    bl  SystemInit
/* Call static constructors */
    bl __libc_init_array
/* Call the application entry point.*/
	bl	main

LoopForever:
    b LoopForever

.size	Reset_Handler, .-Reset_Handler

/**
 * @brief  This is the code that gets called when the processor receives an
 *         unexpected interrupt.  This simply enters an infinite loop, preserving
 *         the system state for examination by a debugger.
 *
 * @param  None
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
	.size	Default_Handler, .-Default_Handler
/******************************************************************************
*
* The minimal vector table for a Cortex-M4.  Note that the proper constructs
* must be placed on this to ensure that it ends up at physical address
* 0x0000.0000.
*
******************************************************************************/
 	.section	.isr_vector,"a",%progbits
	.type	g_pfnVectors, %object
	.size	g_pfnVectors, .-g_pfnVectors


g_pfnVectors:
	.word	_estack
	.word	Reset_Handler
	.word	NMI_Handler
	.word	HardFault_Handler
	.word	MemManage_Handler
	.word	BusFault_Handler
	.word	UsageFault_Handler
	.word	0
	.word	0
	.word	0
	.word	0
	.word	SVC_Handler
	.word	DebugMon_Handler
	.word	0
	.word	PendSV_Handler
	.word	SysTick_Handler
	.word	WWDG_IRQHandler
	.word	PVD_PVM_IRQHandler
	.word	TAMP_STAMP_IRQHandler
	.word	RTC_WKUP_IRQHandler
	.word	FLASH_IRQHandler
	.word	RCC_IRQHandler
	.word	EXTI0_IRQHandler
	.word	EXTI1_IRQHandler
	.word	EXTI2_IRQHandler
	.word	EXTI3_IRQHandler
	.word	EXTI4_IRQHandler
	.word	DMA1_Channel1_IRQHandler
	.word	DMA1_Channel2_IRQHandler
	.word	DMA1_Channel3_IRQHandler
	.word	DMA1_Channel4_IRQHandler
	.word	DMA1_Channel5_IRQHandler
	.word	DMA1_Channel6_IRQHandler
	.word	DMA1_Channel7_IRQHandler
	.word	ADC1_2_IRQHandler
	.word	CAN1_TX_IRQHandler
	.word	CAN1_RX0_IRQHandler
	.word	CAN1_RX1_IRQHandler
	.word	CAN1_SCE_IRQHandler
	.word	EXTI9_5_IRQHandler
	.word	TIM1_BRK_TIM15_IRQHandler
	.word	TIM1_UP_TIM16_IRQHandler
	.word	TIM1_TRG_COM_TIM17_IRQHandler
	.word	TIM1_CC_IRQHandler
	.word	TIM2_IRQHandler
	.word	TIM3_IRQHandler
	.word	TIM4_IRQHandler
	.word	I2C1_EV_IRQHandler
	.word	I2C1_ER_IRQHandler
	.word	I2C2_EV_IRQHandler
	.word	I2C2_ER_IRQHandler
	.word	SPI1_IRQHandler
	.word	SPI2_IRQHandler
	.word	USART1_IRQHandler
	.word	USART2_IRQHandler
	.word	USART3_IRQHandler
	.word	EXTI15_10_IRQHandler
	.word	RTC_Alarm_IRQHandler
	.word	DFSDM1_FLT3_IRQHandler
	.word	TIM8_BRK_IRQHandler
	.word	TIM8_UP_IRQHandler
	.word	TIM8_TRG_COM_IRQHandler
	.word	TIM8_CC_IRQHandler
	.word	ADC3_IRQHandler
	.word	FMC_IRQHandler
	.word	SDMMC1_IRQHandler
	.word	TIM5_IRQHandler
	.word	SPI3_IRQHandler
	.word	UART4_IRQHandler
	.word	UART5_IRQHandler
	.word	TIM6_DAC_IRQHandler
	.word	TIM7_IRQHandler
	.word	DMA2_Channel1_IRQHandler
	.word	DMA2_Channel2_IRQHandler
	.word	DMA2_Channel3_IRQHandler
	.word	DMA2_Channel4_IRQHandler
	.word	DMA2_Channel5_IRQHandler
	.word	DFSDM1_FLT0_IRQHandler
	.word	DFSDM1_FLT1_IRQHandler
	.word	DFSDM1_FLT2_IRQHandler
	.word	COMP_IRQHandler
	.word	LPTIM1_IRQHandler
	.word	LPTIM2_IRQHandler
	.word	OTG_FS_IRQHandler
	.word	DMA2_Channel6_IRQHandler
	.word	DMA2_Channel7_IRQHandler
	.word	LPUART1_IRQHandler
	.word	QUADSPI_IRQHandler
	.word	I2C3_EV_IRQHandler
	.word	I2C3_ER_IRQHandler
	.word	SAI1_IRQHandler
	.word	SAI2_IRQHandler
	.word	SWPMI1_IRQHandler
	.word	TSC_IRQHandler
	.word	LCD_IRQHandler
	.word 0
	.word	RNG_IRQHandler
	.word	FPU_IRQHandler


/*******************************************************************************
*
* Provide weak aliases for each Exception handler to the Default_Handler.
* As they are weak aliases, any function with the same name will override
* this definition.
*
*******************************************************************************/

  .weak	NMI_Handler
	.thumb_set NMI_Handler,Default_Handler

  .weak	HardFault_Handler
	.thumb_set HardFault_Handler,Default_Handler

  .weak	MemManage_Handler
	.thumb_set MemManage_Handler,Default_Handler

  .weak	BusFault_Handler
	.thumb_set BusFault_Handler,Default_Handler

	.weak	UsageFault_Handler
	.thumb_set UsageFault_Handler,Default_Handler

	.weak	SVC_Handler
	.thumb_set SVC_Handler,Default_Handler

	.weak	DebugMon_Handler
	.thumb_set DebugMon_Handler,Default_Handler

	.weak	PendSV_Handler
	.thumb_set PendSV_Handler,Default_Handler

	.weak	SysTick_Handler
	.thumb_set SysTick_Handler,Default_Handler

	.weak	WWDG_IRQHandler
	.thumb_set WWDG_IRQHandler,Default_Handler

	.weak	PVD_PVM_IRQHandler
	.thumb_set PVD_PVM_IRQHandler,Default_Handler

	.weak	TAMP_STAMP_IRQHandler
	.thumb_set TAMP_STAMP_IRQHandler,Default_Handler

	.weak	RTC_WKUP_IRQHandler
	.thumb_set RTC_WKUP_IRQHandler,Default_Handler

	.weak	FLASH_IRQHandler
	.thumb_set FLASH_IRQHandler,Default_Handler

	.weak	RCC_IRQHandler
	.thumb_set RCC_IRQHandler,Default_Handler

	.weak	EXTI0_IRQHandler
	.thumb_set EXTI0_IRQHandler,Default_Handler

	.weak	EXTI1_IRQHandler
	.thumb_set EXTI1_IRQHandler,Default_Handler

	.weak	EXTI2_IRQHandler
	.thumb_set EXTI2_IRQHandler,Default_Handler

	.weak	EXTI3_IRQHandler
	.thumb_set EXTI3_IRQHandler,Default_Handler

	.weak	EXTI4_IRQHandler
	.thumb_set EXTI4_IRQHandler,Default_Handler

	.weak	DMA1_Channel1_IRQHandler
	.thumb_set DMA1_Channel1_IRQHandler,Default_Handler

	.weak	DMA1_Channel2_IRQHandler
	.thumb_set DMA1_Channel2_IRQHandler,Default_Handler

	.weak	DMA1_Channel3_IRQHandler
	.thumb_set DMA1_Channel3_IRQHandler,Default_Handler

	.weak	DMA1_Channel4_IRQHandler
	.thumb_set DMA1_Channel4_IRQHandler,Default_Handler

	.weak	DMA1_Channel5_IRQHandler
	.thumb_set DMA1_Channel5_IRQHandler,Default_Handler

	.weak	DMA1_Channel6_IRQHandler
	.thumb_set DMA1_Channel6_IRQHandler,Default_Handler

	.weak	DMA1_Channel7_IRQHandler
	.thumb_set DMA1_Channel7_IRQHandler,Default_Handler

	.weak	ADC1_2_IRQHandler
	.thumb_set ADC1_2_IRQHandler,Default_Handler

	.weak	CAN1_TX_IRQHandler
	.thumb_set CAN1_TX_IRQHandler,Default_Handler

	.weak	CAN1_RX0_IRQHandler
	.thumb_set CAN1_RX0_IRQHandler,Default_Handler

	.weak	CAN1_RX1_IRQHandler
	.thumb_set CAN1_RX1_IRQHandler,Default_Handler

	.weak	CAN1_SCE_IRQHandler
	.thumb_set CAN1_SCE_IRQHandler,Default_Handler

	.weak	EXTI9_5_IRQHandler
	.thumb_set EXTI9_5_IRQHandler,Default_Handler

	.weak	TIM1_BRK_TIM15_IRQHandler
	.thumb_set TIM1_BRK_TIM15_IRQHandler,Default_Handler

	.weak	TIM1_UP_TIM16_IRQHandler
	.thumb_set TIM1_UP_TIM16_IRQHandler,Default_Handler

	.weak	TIM1_TRG_COM_TIM17_IRQHandler
	.thumb_set TIM1_TRG_COM_TIM17_IRQHandler,Default_Handler

	.weak	TIM1_CC_IRQHandler
	.thumb_set TIM1_CC_IRQHandler,Default_Handler

	.weak	TIM2_IRQHandler
	.thumb_set TIM2_IRQHandler,Default_Handler

	.weak	TIM3_IRQHandler
	.thumb_set TIM3_IRQHandler,Default_Handler

	.weak	TIM4_IRQHandler
	.thumb_set TIM4_IRQHandler,Default_Handler

	.weak	I2C1_EV_IRQHandler
	.thumb_set I2C1_EV_IRQHandler,Default_Handler

	.weak	I2C1_ER_IRQHandler
	.thumb_set I2C1_ER_IRQHandler,Default_Handler

	.weak	I2C2_EV_IRQHandler
	.thumb_set I2C2_EV_IRQHandler,Default_Handler

	.weak	I2C2_ER_IRQHandler
	.thumb_set I2C2_ER_IRQHandler,Default_Handler

	.weak	SPI1_IRQHandler
	.thumb_set SPI1_IRQHandler,Default_Handler

	.weak	SPI2_IRQHandler
	.thumb_set SPI2_IRQHandler,Default_Handler

	.weak	USART1_IRQHandler
	.thumb_set USART1_IRQHandler,Default_Handler

	.weak	USART2_IRQHandler
	.thumb_set USART2_IRQHandler,Default_Handler

	.weak	USART3_IRQHandler
	.thumb_set USART3_IRQHandler,Default_Handler

	.weak	EXTI15_10_IRQHandler
	.thumb_set EXTI15_10_IRQHandler,Default_Handler

	.weak	RTC_Alarm_IRQHandler
	.thumb_set RTC_Alarm_IRQHandler,Default_Handler

	.weak	DFSDM1_FLT3_IRQHandler
	.thumb_set DFSDM1_FLT3_IRQHandler,Default_Handler

	.weak	TIM8_BRK_IRQHandler
	.thumb_set TIM8_BRK_IRQHandler,Default_Handler

	.weak	TIM8_UP_IRQHandler
	.thumb_set TIM8_UP_IRQHandler,Default_Handler

	.weak	TIM8_TRG_COM_IRQHandler
	.thumb_set TIM8_TRG_COM_IRQHandler,Default_Handler

	.weak	TIM8_CC_IRQHandler
	.thumb_set TIM8_CC_IRQHandler,Default_Handler

	.weak	ADC3_IRQHandler
	.thumb_set ADC3_IRQHandler,Default_Handler

	.weak	FMC_IRQHandler
	.thumb_set FMC_IRQHandler,Default_Handler

	.weak	SDMMC1_IRQHandler
	.thumb_set SDMMC1_IRQHandler,Default_Handler

	.weak	TIM5_IRQHandler
	.thumb_set TIM5_IRQHandler,Default_Handler

	.weak	SPI3_IRQHandler
	.thumb_set SPI3_IRQHandler,Default_Handler

	.weak	UART4_IRQHandler
	.thumb_set UART4_IRQHandler,Default_Handler

	.weak	UART5_IRQHandler
	.thumb_set UART5_IRQHandler,Default_Handler

	.weak	TIM6_DAC_IRQHandler
	.thumb_set TIM6_DAC_IRQHandler,Default_Handler

	.weak	TIM7_IRQHandler
	.thumb_set TIM7_IRQHandler,Default_Handler

	.weak	DMA2_Channel1_IRQHandler
	.thumb_set DMA2_Channel1_IRQHandler,Default_Handler

	.weak	DMA2_Channel2_IRQHandler
	.thumb_set DMA2_Channel2_IRQHandler,Default_Handler

	.weak	DMA2_Channel3_IRQHandler
	.thumb_set DMA2_Channel3_IRQHandler,Default_Handler

	.weak	DMA2_Channel4_IRQHandler
	.thumb_set DMA2_Channel4_IRQHandler,Default_Handler

	.weak	DMA2_Channel5_IRQHandler
	.thumb_set DMA2_Channel5_IRQHandler,Default_Handler

	.weak	DFSDM1_FLT0_IRQHandler
	.thumb_set DFSDM1_FLT0_IRQHandler,Default_Handler

	.weak	DFSDM1_FLT1_IRQHandler
	.thumb_set DFSDM1_FLT1_IRQHandler,Default_Handler

	.weak	DFSDM1_FLT2_IRQHandler
	.thumb_set DFSDM1_FLT2_IRQHandler,Default_Handler

	.weak	COMP_IRQHandler
	.thumb_set COMP_IRQHandler,Default_Handler

	.weak	LPTIM1_IRQHandler
	.thumb_set LPTIM1_IRQHandler,Default_Handler

	.weak	LPTIM2_IRQHandler
	.thumb_set LPTIM2_IRQHandler,Default_Handler

	.weak	OTG_FS_IRQHandler
	.thumb_set OTG_FS_IRQHandler,Default_Handler

	.weak	DMA2_Channel6_IRQHandler
	.thumb_set DMA2_Channel6_IRQHandler,Default_Handler

	.weak	DMA2_Channel7_IRQHandler
	.thumb_set DMA2_Channel7_IRQHandler,Default_Handler

	.weak	LPUART1_IRQHandler
	.thumb_set LPUART1_IRQHandler,Default_Handler

	.weak	QUADSPI_IRQHandler
	.thumb_set QUADSPI_IRQHandler,Default_Handler

	.weak	I2C3_EV_IRQHandler
	.thumb_set I2C3_EV_IRQHandler,Default_Handler

	.weak	I2C3_ER_IRQHandler
	.thumb_set I2C3_ER_IRQHandler,Default_Handler

	.weak	SAI1_IRQHandler
	.thumb_set SAI1_IRQHandler,Default_Handler

	.weak	SAI2_IRQHandler
	.thumb_set SAI2_IRQHandler,Default_Handler

	.weak	SWPMI1_IRQHandler
	.thumb_set SWPMI1_IRQHandler,Default_Handler

	.weak	TSC_IRQHandler
	.thumb_set TSC_IRQHandler,Default_Handler

	.weak	LCD_IRQHandler
	.thumb_set LCD_IRQHandler,Default_Handler

	.weak	RNG_IRQHandler
	.thumb_set RNG_IRQHandler,Default_Handler

	.weak	FPU_IRQHandler
	.thumb_set FPU_IRQHandler,Default_Handler

L476_USER_APP\UserApp\.cproject
1	<?xml version="1.0" encoding="UTF-8" standalone="no"?>
2	<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptio­nStorage">
3		<storageModule moduleId="org.eclipse.cdt.core.settings">
4			<cconfiguration id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.433848364">
5				<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataPro­vider" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.433848364" moduleId="org.eclipse.cdt.core.settings" name="Debug">
6					<externalSettings/>
7					<extensions>
8						<extension id="org.eclipse.cdt.core.ELF" point="org.eclipse.cdt.core.BinaryParser"/>
9						<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
10						<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
11						<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
12						<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
13						<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
14					</extensions>
15				</storageModule>
16				<storageModule moduleId="cdtBuildSystem" version="4.0.0">
17					<configuration artifactExtension="elf" artifactName="UserApp" buildArtefactType="org.eclipse.cdt.build.core.buildArtefactType.exe" buildProperties="org.eclipse.cdt.build.core.buildArtefactType=org.eclipse.cdt.build.core.buildArtefactType.exe,org.eclipse.cdt.build.core.buildType=org.eclipse.cdt.build.core.buildType.debug" cleanCommand="rm -rf" description="" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.433848364" name="Debug" parent="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug" postbuildStep="arm-none-eabi-objcopy -O binary &quot;${BuildArtifactFileBas­eName}.elf&quot; &quot;../${BuildArtifactFileBas­eName}.bin&quot; &amp;&amp; arm-none-eabi-size &quot;${BuildArtifactFileNam­e}&quot; &amp;&amp; &quot;../../Common/Scripts/postbuild.sh&quot; &quot;../&quot; &quot;${BuildArtifactFileBas­eName}.elf&quot; &quot;../../Binary/${BuildArtifactFileBas­eName}.bin&quot; &quot;1&quot; &quot;1&quot;">
18						<folderInfo id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.433848364." name="/" resourcePath="">
19							<toolChain id="com.st.stm32cube.ide.mcu.gnu.managedbuild.toolchain.exe.debug.1535832437" name="MCU ARM GCC" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.toolchain.exe.debug">
20								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_mcu.1798117278" name="MCU" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_mcu" useByScannerDiscover­y="true" value="STM32L476RGTx" valueType="string"/>
21								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_board.1772652346" name="Board" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_board" useByScannerDiscover­y="false" value="NUCLEO-L476RG" valueType="string"/>
22								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.instructionset.1362980834" name="Instruction set" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.instructionset" useByScannerDiscover­y="true" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.instructionset.value.thumb2" valueType="enumerated"/>
23								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.floatabi.583896738" name="Floating-point ABI" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.floatabi" useByScannerDiscover­y="true" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.floatabi.value.hard" valueType="enumerated"/>
24								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.fpu.1090270378" name="Floating-point unit" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.fpu" useByScannerDiscover­y="true" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.fpu.value.fpv4-sp-d16" valueType="enumerated"/>
25								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_cpuid.1393893326" name="CPU" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_cpuid" useByScannerDiscover­y="false" value="0" valueType="string"/>
26								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_coreid.2036073277" name="Core" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_coreid" useByScannerDiscover­y="false" value="0" valueType="string"/>
27								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.runtimelibrary_c.1969686094" name="Runtime library" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.runtimelibrary_c" useByScannerDiscover­y="true" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.runtimelibrary_c.value.nano_c" valueType="enumerated"/>
28								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.convertbinary.699245540" name="Convert to binary file (-O binary)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.convertbinary" useByScannerDiscover­y="false" value="true" valueType="boolean"/>
29								<targetPlatform archList="all" binaryParser="org.eclipse.cdt.core.ELF" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.targetplatform.94911766" isAbstract="false" osList="all" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.targetplatform"/>
30								<builder buildPath="${workspace_loc:/L476_USER_APP_UserAp­p}/Debug" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.builder.2034626692" keepEnvironmentInBui­ldfile="false" name="Gnu Make Builder" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.builder"/>
31								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.1393432284" name="MCU GCC Assembler" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler">
32									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.debuglevel.302844863" name="Debug level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.debuglevel" useByScannerDiscover­y="false" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.debuglevel.value.g3" valueType="enumerated"/>
33									<inputType id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.input.330715720" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.input"/>
34								</tool>
35								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.609516792" name="MCU GCC Compiler" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler">
36									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.debuglevel.471637943" name="Debug level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.debuglevel" useByScannerDiscover­y="false" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.debuglevel.value.g3" valueType="enumerated"/>
37									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level.1298753489" name="Optimization level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level" useByScannerDiscover­y="false" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level.value.os" valueType="enumerated"/>
38									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.ffunction.832857705" name="Place functions in their own sections (-ffunction-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.ffunction" useByScannerDiscover­y="false" value="true" valueType="boolean"/>
39									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.fdata.1833678994" name="Place data in their own sections (-fdata-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.fdata" useByScannerDiscover­y="false" value="false" valueType="boolean"/>
40									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.includepaths.1435093378" name="Include paths (-I)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.includepaths" useByScannerDiscover­y="false" valueType="includePath">
41										<listOptionValue builtIn="false" value="../Application/Core/Inc"/>
42										<listOptionValue builtIn="false" value="../../Common/Linker"/>
43										<listOptionValue builtIn="false" value="../../../L476_SBSFU/BFU/Application/BFU/App"/>
44										<listOptionValue builtIn="false" value="../../../L476_SBSFU/SECoreBin/Application/Core/Inc"/>
45										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/BSP/STM32L4xx_Nucleo"/>
46										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/BSP/Components/Common"/>
47										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/CMSIS/Device/ST/STM32L4xx/Include"/>
48										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/CMSIS/Include"/>
49										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Inc"/>
50										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Core"/>
51									</option>
52									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.definedsymbols.937688093" name="Define symbols (-D)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.definedsymbols" useByScannerDiscover­y="false" valueType="definedSymbols">
53										<listOptionValue builtIn="false" value="STM32L476xx"/>
54										<listOptionValue builtIn="false" value="USE_HAL_DRIVER"/>
55										<listOptionValue builtIn="false" value="USE_STM32L4XX_NUCLEO­"/>
56									</option>
57									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.otherflags.1162777085" name="Other flags" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.otherflags" useByScannerDiscover­y="true" valueType="stringList">
58										<listOptionValue builtIn="false" value="-Wno-format -Wno-strict-aliasing"/>
59									</option>
60									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.languagestandard.576797876" name="Language standard" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.languagestandard" useByScannerDiscover­y="true" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.languagestandard.value.gnu11" valueType="enumerated"/>
61									<inputType id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.input.c.1082925559" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.input.c"/>
62								</tool>
63								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.1921636409" name="MCU G++ Compiler" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler">
64									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.debuglevel.845675200" name="Debug level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.debuglevel" useByScannerDiscover­y="false" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.debuglevel.value.g3" valueType="enumerated"/>
65									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.optimization.level.822743360" name="Optimization level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.optimization.level" useByScannerDiscover­y="false" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.optimization.level.value.os" valueType="enumerated"/>
66									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.ffunction.1735265354" name="Place functions in their own sections (-ffunction-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.ffunction" useByScannerDiscover­y="false" value="true" valueType="boolean"/>
67									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.fdata.1478430976" name="Place data in their own sections (-fdata-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.fdata" useByScannerDiscover­y="false" value="false" valueType="boolean"/>
68									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.noexceptions.54153004" name="Disable handling exceptions (-fno-exceptions)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.noexceptions" useByScannerDiscover­y="false" value="true" valueType="boolean"/>
69									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.nortti.1609114510" name="Disable generation of information about every class with virtual functions (-fno-rtti)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.nortti" useByScannerDiscover­y="false" value="true" valueType="boolean"/>
70									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.includepaths.1271929026" name="Include paths (-I)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.includepaths" useByScannerDiscover­y="false" valueType="includePath">
71										<listOptionValue builtIn="false" value="../Application/Core/Inc"/>
72										<listOptionValue builtIn="false" value="../../Common/Linker"/>
73										<listOptionValue builtIn="false" value="../../../L476_SBSFU/BFU/Application/BFU/App"/>
74										<listOptionValue builtIn="false" value="../../../L476_SBSFU/SECoreBin/Application/Core/Inc"/>
75										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/BSP/STM32L4xx_Nucleo"/>
76										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/BSP/Components/Common"/>
77										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/CMSIS/Device/ST/STM32L4xx/Include"/>
78										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/CMSIS/Include"/>
79										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Inc"/>
80										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Core"/>
81									</option>
82									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.definedsymbols.1237664519" name="Define symbols (-D)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.definedsymbols" useByScannerDiscover­y="false" valueType="definedSymbols">
83										<listOptionValue builtIn="false" value="STM32L476xx"/>
84										<listOptionValue builtIn="false" value="USE_HAL_DRIVER"/>
85										<listOptionValue builtIn="false" value="USE_STM32L4XX_NUCLEO­"/>
86									</option>
87									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="true" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.otherflags.1032388116" name="Other flags" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.otherflags" useByScannerDiscover­y="true" valueType="stringList"/>
88								</tool>
89								<tool command="gcc -z max-page-size=1" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.734294571" name="MCU GCC Linker" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker">
90									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.script.356613969" name="Linker Script (-T)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.script" value="../STM32L476RGTx.ld" valueType="string"/>
91									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.gcsections.500321048" name="Discard unused sections (-Wl,--gc-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.gcsections" value="true" valueType="boolean"/>
92									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="true" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.libraries.971491276" name="Libraries (-l)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.libraries" valueType="libs"/>
93									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.directories.1020829247" name="Library search path (-L)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.directories" valueType="libPaths">
94										<listOptionValue builtIn="false" value="../../Common/Debug/Middlewares/STM32_Secure_Engine"/>
95									</option>
96									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.systemcalls.1173093642" name="System calls" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.systemcalls" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.systemcalls.value.minimalimplementatio­n" valueType="enumerated"/>
97									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.otherflags.2020702307" name="Other flags" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.otherflags" valueType="stringList">
98										<listOptionValue builtIn="false" value=""/>
99										<listOptionValue builtIn="false" value="-Xlinker -L ../../Common/Linker"/>
100									</option>
101									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="true" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.additionalobjs.1069066395" name="Additional object files" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.additionalobjs" valueType="userObjs"/>
102									<inputType id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.input.1095070634" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.input">
103										<additionalInput kind="additionalinputdepen­dency" paths="$(USER_OBJS)"/>
104										<additionalInput kind="additionalinput" paths="$(LIBS)"/>
105									</inputType>
106								</tool>
107								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.345620262" name="MCU G++ Linker" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker">
108									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.script.843158197" name="Linker Script (-T)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.script" value="../STM32L476RGTx.ld" valueType="string"/>
109									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.gcsections.2133961262" name="Discard unused sections (-Wl,--gc-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.gcsections" value="true" valueType="boolean"/>
110									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.otherflags.1413085039" name="Other flags" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.otherflags"/>
111								</tool>
112								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.archiver.1591702379" name="MCU GCC Archiver" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.archiver"/>
113								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.size.1580008575" name="MCU Size" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.size"/>
114								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objdump.listfile.52625014" name="MCU Output Converter list file" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objdump.listfile"/>
115								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.hex.1554073987" name="MCU Output Converter Hex" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.hex"/>
116								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.binary.264265144" name="MCU Output Converter Binary" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.binary"/>
117								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.verilog.1518173615" name="MCU Output Converter Verilog" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.verilog"/>
118								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.srec.1525744368" name="MCU Output Converter Motorola S-rec" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.srec"/>
119								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.symbolsrec.1547734505" name="MCU Output Converter Motorola S-rec with symbols" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.symbolsrec"/>
120							</toolChain>
121						</folderInfo>
122						<sourceEntries>
123							<entry flags="VALUE_WORKSPACE_PATH­|RESOLVED" kind="sourcePath" name=""/>
124						</sourceEntries>
125					</configuration>
126				</storageModule>
127				<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
128			</cconfiguration>
129		</storageModule>
130		<storageModule moduleId="cdtBuildSystem" version="4.0.0">
131			<project id="L476_USER_APP_UserAp­p.fr.ac6.managedbuild.target.gnu.cross.exe.514157493" name="Executable"/>
132		</storageModule>
133		<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProv­iders"/>
134		<storageModule moduleId="refreshScope" versionNumber="2">
135			<configuration artifactName="${ProjName}" configurationName="Debug">
136				<resource resourceType="PROJECT" workspacePath="L476_USER_APP_UserAp­p"/>
137			</configuration>
138		</storageModule>
139		<storageModule moduleId="org.eclipse.cdt.make.core.buildtargets"/>
140		<storageModule moduleId="scannerConfiguration­">
141			<autodiscovery enabled="true" problemReportingEnab­led="true" selectedProfileId=""/>
142			<scannerConfigBuildIn­fo instanceId="fr.ac6.managedbuild.config.gnu.cross.exe.debug.430575103;fr.ac6.managedbuild.config.gnu.cross.exe.debug.430575103.;fr.ac6.managedbuild.tool.gnu.cross.c.compiler.2085766472;fr.ac6.managedbuild.tool.gnu.cross.c.compiler.input.c.1138970437">
143				<autodiscovery enabled="false" problemReportingEnab­led="true" selectedProfileId=""/>
144			</scannerConfigBuildIn­fo>
145			<scannerConfigBuildIn­fo instanceId="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.433848364;com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.433848364.;com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.609516792;com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.input.c.1082925559">
146				<autodiscovery enabled="true" problemReportingEnab­led="true" selectedProfileId=""/>
147			</scannerConfigBuildIn­fo>
148		</storageModule>
149	</cproject>
L476_USER_APP\UserApp\.project
1	<?xml version="1.0" encoding="UTF-8"?>
2	<projectDescription>
3		<name>L476_USER_APP_UserAp­p</name>
4		<comment></comment>
5		<projects>
6		</projects>
7		<buildSpec>
8			<buildCommand>
9				<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
10				<triggers>clean,full,incremental,</triggers>
11				<arguments>
12				</arguments>
13			</buildCommand>
14			<buildCommand>
15				<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder­</name>
16				<triggers>full,incremental,</triggers>
17				<arguments>
18				</arguments>
19			</buildCommand>
20		</buildSpec>
21		<natures>
22			<nature>com.st.stm32cube.ide.mcu.MCUProjectNature</nature>
23			<nature>org.eclipse.cdt.core.cnature</nature>
24			<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
25			<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
26		</natures>
27		<linkedResources>
28			<link>
29				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal.c</name>
30				<type>1</type>
31				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal.c</locationURI>
32			</link>
33			<link>
34				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_cortex­.c</name>
35				<type>1</type>
36				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_cortex­.c</locationURI>
37			</link>
38			<link>
39				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_crc.c</name>
40				<type>1</type>
41				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_crc.c</locationURI>
42			</link>
43			<link>
44				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_crc_ex­.c</name>
45				<type>1</type>
46				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_crc_ex­.c</locationURI>
47			</link>
48			<link>
49				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_flash.c</name>
50				<type>1</type>
51				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_flash.c</locationURI>
52			</link>
53			<link>
54				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_flash_­ex.c</name>
55				<type>1</type>
56				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_flash_­ex.c</locationURI>
57			</link>
58			<link>
59				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_gpio.c</name>
60				<type>1</type>
61				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_gpio.c</locationURI>
62			</link>
63			<link>
64				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_iwdg.c</name>
65				<type>1</type>
66				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_iwdg.c</locationURI>
67			</link>
68			<link>
69				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_pwr.c</name>
70				<type>1</type>
71				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_pwr.c</locationURI>
72			</link>
73			<link>
74				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_pwr_ex­.c</name>
75				<type>1</type>
76				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_pwr_ex­.c</locationURI>
77			</link>
78			<link>
79				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_rcc.c</name>
80				<type>1</type>
81				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_rcc.c</locationURI>
82			</link>
83			<link>
84				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_rcc_ex­.c</name>
85				<type>1</type>
86				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_rcc_ex­.c</locationURI>
87			</link>
88			<link>
89				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_rtc.c</name>
90				<type>1</type>
91				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_rtc.c</locationURI>
92			</link>
93			<link>
94				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_rtc_ex­.c</name>
95				<type>1</type>
96				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_rtc_ex­.c</locationURI>
97			</link>
98			<link>
99				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_uart.c</name>
100				<type>1</type>
101				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_uart.c</locationURI>
102			</link>
103			<link>
104				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_uart_e­x.c</name>
105				<type>1</type>
106				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_uart_e­x.c</locationURI>
107			</link>
108			<link>
109				<name>Middlewares/STM32_Secure_Engine/se_interface_applica­tion.o</name>
110				<type>1</type>
111				<location>K:/SBSFU_NUCLEO_L476/Project/L476_SBSFU/Common/Debug/Middlewares/STM32_Secure_Engine/se_interface_applica­tion.o</location>
112			</link>
113			<link>
114				<name>Drivers/BSP/STM32L4xx_Nucleo/stm32l4xx_nucleo.c</name>
115				<type>1</type>
116				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/BSP/STM32L4xx_Nucleo/stm32l4xx_nucleo.c</locationURI>
117			</link>
118		</linkedResources>
119	</projectDescription>
120
L476_USER_APP\UserApp\STM32L476RGTx.ld

/*
*****************************************************************************
**
**  File        : LinkerScript.ld
**
**  Abstract    : Linker script for STM32L476RGTx Device with
**                1024KByte FLASH, 96KByte RAM
**
**                Set heap size, stack size and stack location according
**                to application requirements.
**
**                Set memory bank area and size if external memory is used.
**
**  Target      : STMicroelectronics STM32
**
**
**  Distribution: The file is distributed as is, without any warranty
**                of any kind.
**
**  (c)Copyright Ac6.
**  You may use this file as-is or modify it according to the needs of your
**  project. Distribution of this file (unmodified or modified) is not
**  permitted. Ac6 permit registered System Workbench for MCU users the
**  rights to distribute the assembled, compiled & linked contents of this
**  file as part of an application binary file, provided that it is built
**  using the System Workbench for MCU toolchain.
**
*****************************************************************************
*/

/* Entry Point */
ENTRY(Reset_Handler)

/* Highest address of the user mode stack */
_estack = 0x20018000;

/* Generate a link error if heap and stack don't fit into RAM */
_Min_Heap_Size = 0x200;      /* required amount of heap  */
_Min_Stack_Size = 0x800; /* required amount of stack */

INCLUDE se_interface_app.ld
INCLUDE mapping_fwimg.ld
INCLUDE mapping_sbsfu.ld

/* Specific ROM/RAM UserApp definition */
__ICFEDIT_intvec_start__  = __ICFEDIT_SLOT_Active_1_start__    + 0x200;
APPLI_region_ROM_start    = __ICFEDIT_SLOT_Active_1_start__    + VECTOR_SIZE + 0x200;
APPLI_region_ROM_length   = __ICFEDIT_SLOT_Active_1_end__    - APPLI_region_ROM_start + 1;
APPLI_region_RAM_start    = __ICFEDIT_SE_region_RAM_end__ + 1;
APPLI_region_RAM_length    = 0x20018000 - APPLI_region_RAM_start;

/* Specify the memory areas */
MEMORY
{
 ISR_VECTOR (rx)   : ORIGIN = __ICFEDIT_intvec_start__, LENGTH = VECTOR_SIZE
 APPLI_region_ROM  : ORIGIN = APPLI_region_ROM_start, LENGTH = APPLI_region_ROM_length
 APPLI_region_RAM  : ORIGIN = APPLI_region_RAM_start, LENGTH = APPLI_region_RAM_length
}

/* Define output sections */
SECTIONS
{
  /* The startup code goes first into FLASH */
  .isr_vector :
  {
    . = ALIGN(8);
    KEEP(*(.isr_vector)) /* Startup code */
    FILL(0);
    . = ORIGIN(ISR_VECTOR) + LENGTH(ISR_VECTOR) - 1;
    BYTE(0)
    . = ALIGN(8);
  } >ISR_VECTOR

  .SE_IF_Code : {
  KEEP(*se_interface_app.o (.text .text*))
  } >SE_IF_region_ROM

  /* The program code and other data goes into FLASH */
  .text :
  {
    . = ALIGN(8);
    *(.text)           /* .text sections (code) */
    *(.text*)          /* .text* sections (code) */
    *(.glue_7)         /* glue arm to thumb code */
    *(.glue_7t)        /* glue thumb to arm code */
    *(.eh_frame)

    KEEP (*(.init))
    KEEP (*(.fini))

    . = ALIGN(8);
    _etext = .;        /* define a global symbols at end of code */
  } >APPLI_region_ROM

  /* Constant data goes into FLASH */
  .rodata :
  {
    . = ALIGN(8);
    *(.rodata)         /* .rodata sections (constants, strings, etc.) */
    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */
    . = ALIGN(8);
  } >APPLI_region_ROM

  .ARM.extab (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
  . = ALIGN(8);
  *(.ARM.extab* .gnu.linkonce.armextab.*)
  . = ALIGN(8);
  } >APPLI_region_ROM

  .ARM (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
	. = ALIGN(8);
    __exidx_start = .;
    *(.ARM.exidx*)
    __exidx_end = .;
	. = ALIGN(8);
  } >APPLI_region_ROM

  .preinit_array (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
	. = ALIGN(8);
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP (*(.preinit_array*))
    PROVIDE_HIDDEN (__preinit_array_end = .);
	. = ALIGN(8);
  } >APPLI_region_ROM

  .init_array (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
	. = ALIGN(8);
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP (*(SORT(.init_array.*)))
    KEEP (*(.init_array*))
    PROVIDE_HIDDEN (__init_array_end = .);
	. = ALIGN(8);
  } >APPLI_region_ROM

  .fini_array (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
	. = ALIGN(8);
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP (*(SORT(.fini_array.*)))
    KEEP (*(.fini_array*))
    PROVIDE_HIDDEN (__fini_array_end = .);
	. = ALIGN(8);
  } >APPLI_region_ROM

  /* used by the startup to initialize data */
  _sidata = LOADADDR(.data);

  /* Initialized data sections goes into RAM, load LMA copy after code */
  .data :
  {
    . = ALIGN(8);
    _sdata = .;        /* create a global symbol at data start */
    *(.data)           /* .data sections */
    *(.data*)          /* .data* sections */

    . = ALIGN(8);
    _edata = .;        /* define a global symbol at data end */
  } >APPLI_region_RAM AT>APPLI_region_ROM

  /* Extra ROM section (last one) to make sure the binary size is a multiple of the AES block size (16 bytes) and L4 flash writing unit (8 bytes)*/
  .align16 :
  {
    BYTE(0xAA);          /* end marker byte, the value is of no consequence */
    . = ALIGN(16);     /* align the result to 16B for AES   */
  } > APPLI_region_ROM

  /* Uninitialized data section */
  . = ALIGN(4);
  .bss :
  {
    /* This is used by the startup in order to initialize the .bss section */
    _sbss = .;         /* define a global symbol at bss start */
    __bss_start__ = _sbss;
    *(.bss)
    *(.bss*)
    *(COMMON)

    . = ALIGN(4);
    _ebss = .;         /* define a global symbol at bss end */
    __bss_end__ = _ebss;
  } >APPLI_region_RAM

  /* User_heap_stack section, used to check that there is enough RAM left */
  ._user_heap_stack :
  {
    . = ALIGN(8);
    PROVIDE ( end = . );
    PROVIDE ( _end = . );
    . = . + _Min_Heap_Size;
    . = . + _Min_Stack_Size;
    . = ALIGN(8);
  } >APPLI_region_RAM



  /* Remove information from the standard libraries */
  /DISCARD/ :
  {
    libc.a ( * )
    libm.a ( * )
    libgcc.a ( * )
  }

  .ARM.attributes 0 : { *(.ARM.attributes) }
}



L476_USER_APP\.project
1	<?xml version="1.0" encoding="UTF-8"?>
2	<projectDescription>
3		<name>L476_USER_APP</name>
4		<comment></comment>
5		<projects>
6		</projects>
7		<buildSpec>
8		</buildSpec>
9		<natures>
10			<nature>com.st.stm32cube.ide.mcu.MCUProjectNature</nature>
11			<nature>com.st.stm32cube.ide.mcu.MCUCubeProjectNature­</nature>
12			<nature>com.st.stm32cube.ide.mcu.MCURootProjectNature­</nature>
13			<nature>com.st.stm32cube.ide.mcu.MCUCubeIdeServicesRe­vAev2ProjectNature</nature>
14			<nature>com.st.stm32cube.ide.mcu.MCUMultiCpuProjectNa­ture</nature>
15		</natures>
16	</projectDescription>
17
