
Selected files
85 printable files

L476_SBSFU\BFU\Application\BFU\App\app_sfu.h
L476_SBSFU\BFU\Application\BFU\App\sfu_boot.c
L476_SBSFU\BFU\Application\BFU\App\sfu_boot.h
L476_SBSFU\BFU\Application\BFU\App\sfu_com_loader.c
L476_SBSFU\BFU\Application\BFU\App\sfu_com_loader.h
L476_SBSFU\BFU\Application\BFU\App\sfu_com_trace.c
L476_SBSFU\BFU\Application\BFU\App\sfu_com_trace.h
L476_SBSFU\BFU\Application\BFU\App\sfu_def.h
L476_SBSFU\BFU\Application\BFU\App\sfu_error.c
L476_SBSFU\BFU\Application\BFU\App\sfu_error.h
L476_SBSFU\BFU\Application\BFU\App\sfu_fsm_states.h
L476_SBSFU\BFU\Application\BFU\App\sfu_fwimg_common.c
L476_SBSFU\BFU\Application\BFU\App\sfu_fwimg_internal.h
L476_SBSFU\BFU\Application\BFU\App\sfu_fwimg_no_swap.c
L476_SBSFU\BFU\Application\BFU\App\sfu_fwimg_regions.h
L476_SBSFU\BFU\Application\BFU\App\sfu_fwimg_services.h
L476_SBSFU\BFU\Application\BFU\App\sfu_fwimg_swap.c
L476_SBSFU\BFU\Application\BFU\App\sfu_loader.c
L476_SBSFU\BFU\Application\BFU\App\sfu_loader.h
L476_SBSFU\BFU\Application\BFU\App\sfu_new_image.c
L476_SBSFU\BFU\Application\BFU\App\sfu_new_image.h
L476_SBSFU\BFU\Application\BFU\App\sfu_standalone_loader.h
L476_SBSFU\BFU\Application\BFU\App\sfu_test.c
L476_SBSFU\BFU\Application\BFU\App\sfu_test.h
L476_SBSFU\BFU\Application\BFU\App\sfu_trace.h
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level_flash_ext.c
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level_flash_ext.h
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level_flash_int.c
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level_flash_int.h
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level_flash.c
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level_flash.h
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level_security.c
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level_security.h
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level.c
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level.h
L476_SBSFU\BFU\Application\Core\Inc\app_hw.h
L476_SBSFU\BFU\Application\Core\Inc\main.h
L476_SBSFU\BFU\Application\Core\Inc\stm32l4xx_hal_conf.h
L476_SBSFU\BFU\Application\Core\Inc\stm32l4xx_it.h
L476_SBSFU\BFU\Application\Core\Src\main.c
L476_SBSFU\BFU\Application\Core\Src\stm32l4xx_hal_msp.c
L476_SBSFU\BFU\Application\Core\Src\stm32l4xx_it.c
L476_SBSFU\BFU\Application\STM32CubeIDE\sfu_secorebin_Inc.c
L476_SBSFU\BFU\Application\STM32CubeIDE\syscalls.c
L476_SBSFU\BFU\Doc\readme.txt
L476_SBSFU\BFU\Scripts\postbuild.sh
L476_SBSFU\BFU\Scripts\se_interface.txt
L476_SBSFU\BFU\.cproject
L476_SBSFU\BFU\.project
L476_SBSFU\BFU\STM32L476RGTx.ld
L476_SBSFU\Common\Binary_Keys\ECCKEY1.txt
L476_SBSFU\Common\KeysAndImages_Util\keys.py
L476_SBSFU\Common\KeysAndImages_Util\prepareimage.py
L476_SBSFU\Common\KeysAndImages_Util\readme.txt
L476_SBSFU\Common\KeysAndImages_Util\requirements.txt
L476_SBSFU\Common\KeysAndImages_Util\translate_key.py
L476_SBSFU\Common\Linker\mapping_export.h
L476_SBSFU\Common\Linker\mapping_fwimg.ld
L476_SBSFU\Common\Linker\mapping_sbsfu.ld
L476_SBSFU\Common\Linker\se_interface_app.ld
L476_SBSFU\Common\Scripts\postbuild.sh
L476_SBSFU\Common\Startup\se_key.s
L476_SBSFU\SECoreBin\Application\Core\Inc\se_crypto_bootloader.h
L476_SBSFU\SECoreBin\Application\Core\Inc\se_crypto_config.h
L476_SBSFU\SECoreBin\Application\Core\Inc\se_def_metadata.h
L476_SBSFU\SECoreBin\Application\Core\Inc\se_low_level.h
L476_SBSFU\SECoreBin\Application\Core\Inc\stm32l4xx_hal_conf.h
L476_SBSFU\SECoreBin\Application\Core\Src\se_crypto_bootloader.c
L476_SBSFU\SECoreBin\Application\Core\Src\se_low_level.c
L476_SBSFU\SECoreBin\Application\User\data_init.c
L476_SBSFU\SECoreBin\Application\User\syscalls.c
L476_SBSFU\SECoreBin\Doc\readme.txt
L476_SBSFU\SECoreBin\Output\crypto.txt
L476_SBSFU\SECoreBin\Output\output.txt
L476_SBSFU\SECoreBin\Scripts\postbuild.sh
L476_SBSFU\SECoreBin\Scripts\prebuild.sh
L476_SBSFU\SECoreBin\Scripts\SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM.sh
L476_SBSFU\SECoreBin\Scripts\SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256.sh
L476_SBSFU\SECoreBin\Scripts\SECBOOT_ECCDSA_WITHOUT_ENCRYPT_SHA256.sh
L476_SBSFU\SECoreBin\Startup\se_key.s
L476_SBSFU\SECoreBin\Startup\startup_stm32l476xx.s
L476_SBSFU\SECoreBin\.cproject
L476_SBSFU\SECoreBin\.project
L476_SBSFU\SECoreBin\STM32L476RGTx.ld
L476_SBSFU\.project

L476_SBSFU\BFU\Application\BFU\App\app_sfu.h
1	/**
2	  ******************************************************************************
3	  * @file    app_sfu.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains the configuration of SBSFU application.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef APP_SFU_H
21	#define APP_SFU_H
22
23	#ifdef __cplusplus
24	extern "C" {
25	#endif
26
27	/* Includes ------------------------------------------------------------------*/
28	#include "se_crypto_config.h"
29
30	/* Exported constants --------------------------------------------------------*/
31	/**
32	  * Use this define to choose the type of Firmware Image Programming you want to use.
33	  * This version supports only 2 modes:
34	  *
35	  * SFU_ENCRYPTED_IMAGE: Encrypted Firmware Image
36	  *       The image is received in encrypted format.
37	  *       The image must be decrypted to be installed:
38	  *         this is done according to the selected crypto scheme,
39	  *         see @ref SECBOOT_CRYPTO_SCHEM­E in the SE_CoreBin part.
40	  *
41	  * SFU_CLEAR_IMAGE: Clear Firmware Image
42	  *       The image is received in clear format.
43	  *       No decrypt operation is needed before installing the image:
44	  *         the selected crypto scheme must be compatible with this choice,
45	  *         see @ref SECBOOT_CRYPTO_SCHEM­E in the SE_CoreBin part.
46	  *
47	  *
48	  */
49	#if  SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256
50	#define SFU_IMAGE_PROGRAMMIN­G_TYPE SFU_CLEAR_IMAGE
51	#else
52	#define SFU_IMAGE_PROGRAMMIN­G_TYPE SFU_ENCRYPTED_IMAGE
53	#endif /* SECBOOT_CRYPTO_SCHEM­E */
54
55	#define SFU_ENCRYPTED_IMAGE (0U) /*!< The Firmware Image to be installed is downloaded in ENCRYPTED format */
56	#define SFU_CLEAR_IMAGE     (1U) /*!< The Firmware Image to be installed is downloaded in CLEAR format */
57
58	#define SFU_DEBUG_MODE               /*!< Comment this define to optimize memory footprint (debug mode removed)
59	                                          No more print on terminal during SBSFU execution */
60
61	/*#define SFU_VERBOSE_DEBUG_MO­DE*/   /*!< Uncomment this define when in verbose Debug mode.
62	                                          this switch activates more debug prints in the console (FSM state info...) */
63
64
65	/*#define SFU_FWIMG_BLOCK_ON_A­BNORMAL_ERRORS_MODE*/  /*!< You may uncomment this define when running development tests.
66	                                                          When this switch is activated, the FWIMG part of SB_SFU will
67	                                                          block when an abnormal error is encountered */
68
69	#if defined(SFU_VERBOSE_DEBUG_MO­DE) && !defined(SFU_DEBUG_MODE)
70	#error You cannot activate SFU_VERBOSE_DEBUG_MO­DE without activating SFU_DEBUG_MODE too.
71	#endif /* SFU_VERBOSE_DEBUG_MO­DE && !SFU_DEBUG_MODE */
72
73	#if defined(SFU_FWIMG_BLOCK_ON_A­BNORMAL_ERRORS_MODE) && !defined(SFU_DEBUG_MODE)
74	#error SFU_FWIMG_BLOCK_ON_A­BNORMAL_ERRORS_MODE is meant to be used in DEBUG mode
75	#endif /* SFU_FWIMG_BLOCK_ON_A­BNORMAL_ERRORS_MODE && !SFU_DEBUG_MODE */
76
77	/*#define SFU_TEST_PROTECTION*/       /*!< Auto-test of protections : WRP, PCROP, MPU, FWALL.
78	                                           Automatically executed @startup */
79	#if defined(SFU_TEST_PROTECTION)
80	#undef SFU_DEBUG_MODE                 /*!< Remove definition to optimize memory footprint (debug mode removed) */
81	#endif /* SFU_TEST_PROTECTION */
82
83	/**
84	  * SB_SFU status LED.
85	  * The constants below define the LED to be used and the LED blinking frequency to identify some situations.
86	  * This is useful when no log is enabled.
87	  *
88	  * \li The LED blinks every see @ref SFU_COM_YMODEM_DOWNL­OAD_TIMEOUT seconds when a local download is waited.
89	  * \li For the other situations, please check the other defines below.
90	  */
91	#define SFU_STATUS_LED (LED_GREEN)            /*!< LED to be used to provide the SB_SFU status to the end-user */
92	#define SFU_STOP_NO_FW_BLINK­_DELAY     (100U) /*!< Blinks every 100ms when no valid firmware is available and the local
93	                                                   loader feature is disabled - see @ref SECBOOT_USE_LOCAL_LO­ADER */
94	#define SFU_INCORRECT_OB_BLI­NK_DELAY   (250U) /*!< Blinks every 250ms when an Option Bytes issue is detected */
95
96
97	/**
98	  * Optional Features Software Configuration
99	  */
100	#if !defined(SFU_TEST_PROTECTION)
101	#define SECBOOT_LOADER SECBOOT_USE_LOCAL_LO­ADER    /*!< Loader selection inside SBSFU : local/standalone/none */
102	#else
103	#define SECBOOT_LOADER SECBOOT_USE_NO_LOADE­R       /*!< No loader usage forced when SFU_TEST_PROTECTION is set */
104	#endif /* SFU_TEST_PROTECTION */
105
106	#define SECBOOT_USE_LOCAL_LO­ADER              (1U) /*!< local loader feature integrated into SBSFU (YMODEM over UART) */
107	#define SECBOOT_USE_STANDALO­NE_LOADER         (2U) /*!< standalone loader : see specific loader project  */
108	#define SECBOOT_USE_NO_LOADE­R                 (3U) /*!< no loader capability at SBSFU stage */
109
110	/* Uncomment the define below if you want to use minicom with Linux */
111	/* #define MINICOM_YMODEM */                       /*!< YMODEM protocol handled by MINICOM (Linux): 128 bytes packets */
112
113	#if defined(MINICOM_YMODEM)
114	/* Minicom does not accept the debug prints during the YMODEM session */
115	#undef SFU_X509_VERBOSE_DEB­UG_MODE
116	#undef SFU_VERBOSE_DEBUG_MO­DE
117	#endif /* MINICOM_YMODEM */
118
119	/* Uncomment the define below if you want to remove the swap area
120	   ==> partial update is not supported in this configuration
121	   ==> image validation is not supported in this configuration */
122	/*#define SFU_NO_SWAP*/                              /*!< FW upgrade installation process without swap area */
123
124	/* Multi-images configuration :
125	   - Max : 3 Active images and 3 Download area
126	   - Not necessary same configuration between SFU_NB_MAX_ACTIVE_IM­AGE and SFU_NB_MAX_DWL_AREA
127	   - Active slot identified with SFU magic (1,2,3) information from header
128	   - Do not forget to add keys for each image in SE_Corebin/Binary folder
129	   - Master slot : image started in priority if valid
130	   - FW image valid all feature authorized from master slot
131	*/
132	#define SFU_NB_MAX_ACTIVE_IM­AGE 1U                        /*!< 1 active image managed */
133	#define SFU_NB_MAX_DWL_AREA     1U                        /*!< 1 dwl area managed */
134	#define MASTER_SLOT             SLOT_ACTIVE_1             /*!< SLOT_ACTIVE_1 identified as master slot */
135
136
137	/* The define below allows disabling all security IPs at once.
138	 *
139	 * Enabled: all security IPs (WRP, watchdog...) are disabled.
140	 * Disabled: the security IPs can be used (if their specific compiler switches are enabled too).
141	 *
142	 */
143
144	/*#define SECBOOT_DISABLE_SECU­RITY_IPS*/  /*!< Disable all security IPs at once when activated */
145
146	#if !defined(SECBOOT_DISABLE_SECU­RITY_IPS)
147
148	/* Uncomment the following defines when in Release mode.
149	   In debug mode it can be better to disable some of the following protection
150	   for a better Debug experience (WRP, RDP, IWDG, DAP, etc.) */
151
152	#define SFU_WRP_PROTECT_ENAB­LE
153	#define SFU_RDP_PROTECT_ENAB­LE
154	#define SFU_PCROP_PROTECT_EN­ABLE
155	#define SFU_FWALL_PROTECT_EN­ABLE
156	#define SFU_TAMPER_PROTECT_E­NABLE
157	#define SFU_DAP_PROTECT_ENAB­LE     /*!< WARNING: Be Careful if enabling this protection. Debugger will be disconnected.
158	                                        It might be difficult to reconnect the Debugger.*/
159	#define SFU_DMA_PROTECT_ENAB­LE
160	#define SFU_IWDG_PROTECT_ENA­BLE    /*!< WARNING:
161	                                        1. Be Careful if enabling this protection. IWDG will be active also after
162	                                           switching to UserApp: a refresh is needed.
163	                                        2. The IWDG reload in the SB_SFU code will have to be tuned depending on your
164	                                           platform (flash size...)*/
165	#define SFU_MPU_PROTECT_ENAB­LE     /*!< MPU protection:
166	                                        Enables/Disables the MPU protection.
167	                                        If Secure Engine isolation is ensured by MPU (see SFU_ISOLATE_SE_WITH_­MPU in
168	                                        SE_CoreBin\Inc\se_low_level.h), then this switch also enables/disables it, in
169	                                        addition to the overall MPU protection. */
170	#define SFU_MPU_USERAPP_ACTI­VATION /*!< MPU protection during UserApp execution : Only active slot(s) considered as an
171	                                        executable area */
172
173
174	/*#define SFU_FINAL_SECURE_LOC­K_ENABLE */   /*!< WARNING: Should be enabled at the end of product development and test
175	                                                 steps.
176	                                                 When enabling this lock, Static protections cannot be modified any more
177	                                                 and Debug is finally disabled. */
178
179	#if defined(SFU_FINAL_SECURE_LOC­K_ENABLE)
180	#define SFU_PROTECT_RDP_LEVE­L  (OB_RDP_LEVEL_2)  /*!< RDP level2 for product on the field. Final OB lock, Debug
181	                                                      completely disabled, OB update no more possible  */
182
183
184	#else
185	#define SFU_PROTECT_RDP_LEVE­L  (OB_RDP_LEVEL_1)  /*!< RDP level is set as 1 for debugging purposes. A product on the
186	                                                      field should set it as Level2 */
187	#endif /* SFU_FINAL_SECURE_LOC­K_ENABLE */
188
189	#endif /* !SECBOOT_DISABLE_SECU­RITY_IPS */
190
191	/**
192	  * The define below (SECBOOT_OB_DEV_MODE) determines if the OPTION BYTES should be handled in Development mode or not.
193	  * This define is taken into account only if RDP level 2 is not set.
194	  * If RDP level 2 is set no modification can be done anyway.
195	  *
196	  * Enabled: Option Bytes Development Mode enabled.
197	  *          SB_SFU uses a "check and apply" strategy when checking the Option Bytes configuration.
198	  *          If an OB is not set though it should be then this setting is automatically corrected.
199	  *          This applies only as long as RDP level 2 is not set.
200	  *
201	  * Disabled: Option Bytes Development Mode disabled.
202	  *           In this mode the Option Bytes are supposed to be already configured properly when the software starts for
203	              the first time.
204	  *           SB_SFU checks the Option Bytes configuration but does not correct it.
205	  *           If a problem is detected an error message is reported and the execution stops.
206	  */
207	#define SECBOOT_OB_DEV_MODE
208
209
210	#define SFU_IWDG_TIMEOUT  ((uint32_t) 6) /*!< IWDG timeout in seconds (the max. value that can be set here depends on
211	                                              the prescaler settings: IWDG_PRESCALER_XXX. ) */
212
213
214	/**
215	  * Application Configuration
216	  *
217	  */
218	#define SFU_FW_VERSION_START­_NUM (1U)    /*!< The very first version number a Firmware can have
219	                                              You can also define an upper bound here if you plan to use it */
220
221	#define SFU_FW_VERSION_INIT_­NUM (1U)     /*!< The version number accepted when the header is not valid (either because
222	                                              no FW installed or due to an attack attempt). Could be different from
223	                                              SFU_FW_VERSION_START­_NUM */
224
225	/**
226	  * Features compatibility control
227	  */
228	#if defined(SFU_NO_SWAP) && defined(ENABLE_IMAGE_STATE_H­ANDLING)
229	#warning "ENABLE_IMAGE_STATE_H­ANDLING not compatible with SFU_NO_SWAP process"
230	#endif
231
232
233	#ifdef __cplusplus
234	}
235	#endif
236
237	#endif /* APP_SFU_H */
238
239
L476_SBSFU\BFU\Application\BFU\App\sfu_boot.c
1	/**
2	  ******************************************************************************
3	  * @file    sfu_boot.c
4	  * @author  MCD Application Team
5	  * @brief   SFU BOOT module
6	  *          This file provides firmware functions to manage the following
7	  *          functionalities of the Secure Boot:
8	  *           + Initialization and de-initialization functions
9	  *           + Secure Boot Control functions
10	  *           + Secure Boot State functions
11	  ******************************************************************************
12	  * @attention
13	  *
14	  * Copyright (c) 2017 STMicroelectronics.
15	  * All rights reserved.
16	  *
17	  * This software is licensed under terms that can be found in the LICENSE file in
18	  * the root directory of this software component.
19	  * If no LICENSE file comes with this software, it is provided AS-IS.
20	  *
21	  ******************************************************************************
22	  */
23
24	#define SFU_BOOT_C
25
26	/* Includes ------------------------------------------------------------------*/
27	#include "string.h"
28	#include "sfu_boot.h"
29	#include "sfu_loader.h"
30	#include "sfu_low_level_securi­ty.h"
31	#include "sfu_low_level_flash_­int.h"
32	#include "sfu_low_level.h"
33	#include "sfu_fsm_states.h"
34	#include "sfu_error.h"
35	#include "stm32l4xx_it.h" /* required for the HAL Cube callbacks */
36	/*
37	 * The sfu_com init is provided by the sfu_com_trace module by default.
38	 * If not, then it is taken from the sfu_com_loader module.
39	 */
40	#if defined(SFU_DEBUG_MODE) || defined(SFU_TEST_PROTECTION)
41	#include "sfu_trace.h"
42	#else
43	#include "sfu_trace.h"      /* needed anyhow even if the defines will be empty */
44	#include "sfu_com_loader.h" /* needed only for the COM init/de-init */
45	#endif /* SFU_DEBUG_MODE  || SFU_TEST_PROTECTION */
46	#include "se_def.h"
47	#include "se_interface_bootloa­der.h"  /* sfu_boot is the bootloader core part */
48	#include "sfu_new_image.h"            /* the local loader is a kind of "application" running in SB_SFU so it needs the
49	                                         services to install a FW image */
50	#include "sfu_fwimg_services.h"       /* sfu_boot uses the services of the FWIMG module */
51	#include "sfu_test.h"                 /* auto tests */
52	#include "sfu_fwimg_internal.h"
53	#include "sfu_standalone_loade­r.h"
54
55
56	/* Private typedef -----------------------------------------------------------*/
57	typedef struct
58	{
59	  SFU_BOOT_StateMachin­eTypeDef  PrevState;      /*!< The previous state of the State Machine */
60	  SFU_BOOT_StateMachin­eTypeDef  CurrState;      /*!< The current state of the State Machine */
61	} SFU_BOOT_StateMachin­eContextTypeDef;          /*!< Specifies a structure containing the State Machine context
62	                                                     information using during the SM evolution. */
63
64	/* Private defines -----------------------------------------------------------*/
65	#define EXEC_ID_SECURE_BOOT     0U       /*!< ID for Secure Boot */
66	#define EXEC_ID_USER_APP        1U       /*!< ID for User App */
67	#define IS_VALID_EXEC_ID(EXEC_ID)        (((EXEC_ID) == EXEC_ID_SECURE_BOOT) || \
68	                                          ((EXEC_ID) == EXEC_ID_USER_APP)) /*!< Check for valid ID */
69
70	#define RESERVED_VALUE (0xFEU) /*!< Reserved value. The reserved field used inside the LastExecStatus of the BootInfo is
71	                                    maintained for future customization/expansion of the field itself */
72
73	#define SFU_STATE_INITIAL     SFU_STATE_CHECK_STAT­US_ON_RESET  /*!< Define the initial state*/
74
75	/* Private macros ------------------------------------------------------------*/
76	#define SFU_SET_SM_IF_CURR_S­TATE(Status, SM_STATE_OK, SM_STATE_FAILURE) \
77	  do{                                                                   \
78	    m_StateMachineContex­t.PrevState = m_StateMachineContex­t.CurrState;  \
79	    if (Status == SFU_SUCCESS){                                         \
80	      m_StateMachineContex­t.CurrState = SM_STATE_OK;                    \
81	    }                                                                   \
82	    else {                                                              \
83	      m_StateMachineContex­t.CurrState = SM_STATE_FAILURE;               \
84	    }                                                                   \
85	  }while(0) /*!< Set a State Machine state according to the 'Status' value*/
86
87
88	#define SFU_SET_SM_CURR_STAT­E(NewState)                                 \
89	  do{                                                                   \
90	    m_StateMachineContex­t.PrevState = m_StateMachineContex­t.CurrState;  \
91	    m_StateMachineContex­t.CurrState = NewState;                         \
92	  }while(0) /*!< Set a State Machine state*/
93
94	/* Private variables ---------------------------------------------------------*/
95	/*!< Static member variables representing the StateMachine context used during the StateMachine evolution. */
96	static __IO SFU_BOOT_StateMachin­eContextTypeDef m_StateMachineContex­t = {SFU_STATE_INITIAL,
97	                                                                         SFU_STATE_INITIAL
98	                                                                        };
99
100	/*!< Static member variables identifyng the slots to be processed by secure firmware update . */
101	static uint32_t m_DwlSlotToInstall = SLOT_INACTIVE;
102	static uint32_t m_ActiveSlotToResume­ = SLOT_INACTIVE;
103	static uint32_t m_ActiveSlotToRollba­ck = SLOT_INACTIVE;
104	static uint32_t m_ActiveSlotToExecut­e = SLOT_INACTIVE;
105
106	/* Global variables ----------------------------------------------------------*/
107	/**
108	  * This variable indicates if at boot-up the FW presence check has already been performed or not:
109	  * \li It is reset when the FW status has already been checked once and no FW is present
110	  * \li (see @ref SFU_BOOT_SM_CheckUse­rFwStatus)
111	  * \li It is used to display some messages only once in the teraterm console
112	  * \li It is used to determine if the user button must be pressed before waiting for a local download to start
113	  * \li This is used at LocalDownload and CheckUserFwStatus stages.
114	  */
115	uint32_t initialDeviceStatusC­heck;
116
117	/**
118	  *  Flow control initial values.
119	  *   - Security protections flow (static + dynamic)
120	  *   - Crypto operations flow (authentication, integrity)
121	  */
122	uint32_t uFlowProtectValue = FLOW_CTRL_INIT_VALUE­;
123	uint32_t uFlowCryptoValue = FLOW_CTRL_INIT_VALUE­;
124
125	/* Private function prototypes -----------------------------------------------*/
126	static SFU_ErrorStatus SFU_BOOT_Init(void);
127	static SFU_ErrorStatus SFU_BOOT_DeInit(void);
128	static void SFU_BOOT_BspConfigur­ation(void);
129	static SFU_ErrorStatus SFU_BOOT_SM_Run(void);
130	static void SFU_BOOT_SM_CheckSta­tusOnReset(void);
131	#if (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER)
132	static void SFU_BOOT_SM_CheckNew­FwToDownload(void);
133	static void SFU_BOOT_SM_Download­NewUserFw(void);
134	#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER) */
135	static void SFU_BOOT_SM_CheckUse­rFwStatus(void);
136	static void SFU_BOOT_SM_VerifyUs­erFwSignature(void);
137	static void SFU_BOOT_SM_ExecuteU­serFw(void);
138	static void SFU_BOOT_SM_HandleCr­iticalFailure(void);
139	static void SFU_BOOT_SM_RebootSt­ateMachine(void);
140	static void SFU_BOOT_SM_InstallN­ewUserFw(void);
141	static void SFU_BOOT_SM_ResumeIn­stallNewUserFw(void);
142	static void SFU_BOOT_SM_Rollback­InstallPrevUserFw(void);
143	#if (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER)
144	static SFU_ErrorStatus SFU_BOOT_LaunchStand­aloneLoader(void);
145	#endif /* (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER) */
146	static SFU_ErrorStatus SFU_BOOT_SystemSecur­ity_Config(void);
147	static SFU_ErrorStatus SFU_BOOT_CheckApplyS­ecurityProtections(void);
148	static SFU_ErrorStatus SFU_BOOT_SecuritySaf­etyCheck(void);
149	static void SFU_BOOT_ManageReset­Sources(void);
150
151	/* Functions Definition ------------------------------------------------------*/
152	/**
153	  * @brief This function starts the secure boot service and returns only if a configuration issue occurs.
154	  *        In the nominal case, the bootloader service runs until the user application is launched.
155	  *        When no valid user application can be run (after installing a new image or not),
156	  *        if the local loader feature is not enabled then the execution stops,
157	  *        otherwise a local download will be awaited.
158	  *        If the state machine encounters a major issue then a reboot is triggered.
159	  * @param None.
160	  * @note Please note that this service initializes all the required sub-services and rely on them to perform its tasks.
161	  * @note Constraints
162	  *       1. The system initialization must be completed (HAL, clocks, peripherals...) before calling this function.
163	  *       2. This function also takes care of BSP initialization after enabling the secure mode.
164	  *          The BSP init code can be added in @ref SFU_BOOT_BspConfigur­ation().
165	  *       3. No other entity should handle the initialization of the Secure Engine.
166	  *       4. The other SB_SFU services should NOT be configured by other entities if this service is used (the previous
167	  *          configurations will be overwritten).
168	  *       5. The other SB_SFU services should NOT be used by any other entity if this service is running.
169	  *       6. When returning from this function a reboot should be triggered (NVIC_SystemReset) after processing the
170	  *          error cause.
171	  *       7. The caller must be prepared to never get the hand back after calling this function (jumping in user
172	  *          application by default or entering local loader state if local loader is enabled or rebooting to install a
173	  *          new image).
174	  * @note Settings are handled at compilation time:
175	  *       1. See compiler switches in main.h for secure IPs settings
176	  *       2. The trace system is configured in the sfu_trace.h file
177	  * @retval SFU_BOOT_InitErrorTy­peDef error code as the function returns only if a critical failure occurs at init
178	  *          stage.
179	  */
180	SFU_BOOT_InitErrorTy­peDef SFU_BOOT_RunSecureBo­otService()
181	{
182	  SFU_BOOT_InitErrorTy­peDef e_ret_code = SFU_BOOT_INIT_ERROR;
183
184	  /*
185	   * initialize Secure Engine variable as secure Engine is managed as a completely separate binary - not
186	   * "automatically" managed by SBSFU compiler command
187	   */
188	  if (SE_Startup() == SE_SUCCESS)
189	  {
190	    /* Security Configuration */
191	    if (SFU_BOOT_SystemSecur­ity_Config() == SFU_SUCCESS)
192	    {
193	      /* Board BSP  Configuration */
194	      SFU_BOOT_BspConfigur­ation();
195
196	      /* Configure the Secure Boot and start the State machine */
197	      if (SFU_BOOT_Init() == SFU_SUCCESS)
198	      {
199	        /* Start the Secure Boot State Machine */
200	        (void) SFU_BOOT_SM_Run();
201	      }
202	      else
203	      {
204	        /* failure when initializing the secure boot service */
205	        e_ret_code = SFU_BOOT_INIT_FAIL;
206	      }
207	    }
208	    else
209	    {
210	      /* failure when configuring the security IPs  */
211	      e_ret_code = SFU_BOOT_SECIPS_CFG_­FAIL;
212	    }
213	  }
214	  else
215	  {
216	    /* failure at secure engine initialization stage */
217	    e_ret_code = SFU_BOOT_SECENG_INIT­_FAIL;
218	  }
219
220	  /*
221	   * This point should not be reached unless a critical init failure occurred
222	   * Return the error code
223	   */
224	  return (e_ret_code);
225	}
226
227	/**
228	  * @brief  Force System Reboot
229	  * @param  None
230	  * @retval None
231	  */
232	void SFU_BOOT_ForceReboot­(void)
233	{
234	  /*
235	   * WARNING: The follow TRACEs are for debug only. This function could be called
236	   * inside an IRQ so the below printf could not be executed or could generate a fault!
237	   */
238	  TRACE("\r\n========= End of Execution ==========");
239	  TRACE("\r\n\r\n\r\n");
240
241	  /* This is the last operation executed. Force a System Reset. */
242	  NVIC_SystemReset();
243	}
244
245	/**
246	  * @brief  Initialize the Secure Boot State machine.
247	  * @param  None
248	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
249	  */
250	static SFU_ErrorStatus SFU_BOOT_Init(void)
251	{
252	  SFU_ErrorStatus  e_ret_status = SFU_ERROR;
253	  SE_StatusTypeDef e_se_status;
254
255	  /*
256	   * We start the execution at boot-up (display all messages in teraterm console, check the trigger to force a local
257	   * download)
258	   */
259	  initialDeviceStatusC­heck = 1U;
260
261	  /* Call the Hardware Abstraction Layer Init implemented for the specific MCU */
262	  if (SFU_LL_Init() != SFU_SUCCESS)
263	  {
264	    return SFU_ERROR;
265	  }
266
267	  /* Flash interface initialization */
268	  if (SFU_LL_FLASH_Init() != SFU_SUCCESS)
269	  {
270	    return SFU_ERROR;
271	  }
272
273	  /* The COM modules is required only if the trace or the local download is enabled */
274	#if (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || defined(SFU_DEBUG_MODE) || defined(SFU_TEST_PROTECTION)
275	  /* Call the COM module Init (already handled in SFU_BOOT_SystemSecur­ity_Config) */
276	  if (SFU_COM_Init() != SFU_SUCCESS)
277	  {
278	    return SFU_ERROR;
279	  }
280	#endif /* SECBOOT_USE_LOCAL_LO­ADER || SFU_DEBUG_MODE || SFU_TEST_PROTECTION*/
281
282	#if (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER)
283	  /* Call the SFU_LOADER module Init */
284	  if (SFU_LOADER_Init() != SFU_SUCCESS)
285	  {
286	    return SFU_ERROR;
287	  }
288	#endif /* SECBOOT_USE_LOCAL_LO­ADER */
289
290	  /* Call the Exception module Init */
291	  if (SFU_EXCPT_Init() != SFU_SUCCESS)
292	  {
293	    return SFU_ERROR;
294	  }
295
296	  /* Call the image handling Init  */
297	  if (SFU_IMG_InitImageHan­dling() != SFU_IMG_INIT_OK)
298	  {
299	    return SFU_ERROR;
300	  } /* else continue */
301
302	#ifdef SFU_TEST_PROTECTION
303	  SFU_TEST_Init();
304	#endif /* SFU_TEST_PROTECTION */
305
306	  TRACE("\r\n\r\n");
307	  TRACE("\r\n======================================================================");
308	  TRACE("\r\n=              (C) COPYRIGHT 2017 STMicroelectronics                 =");
309	  TRACE("\r\n=                                                                    =");
310	  TRACE("\r\n=              Secure Boot and Secure Firmware Update                =");
311	  TRACE("\r\n======================================================================");
312	  TRACE("\r\n\r\n");
313
314	  /* Initialize the Secure Engine that will be used for all the most critical operations */
315	  if (SE_Init(&e_se_status, SystemCoreClock) != SE_SUCCESS)
316	  {
317	    TRACE("\r\n= [SBOOT] SECURE ENGINE INITIALIZATION CRITICAL FAILURE!");
318	  }
319	  else
320	  {
321	    e_ret_status = SFU_SUCCESS;
322	    TRACE("\r\n= [SBOOT] SECURE ENGINE INITIALIZATION SUCCESSFUL");
323	  }
324
325	  return e_ret_status;
326	}
327
328	/**
329	  * @brief  DeInitialize the Secure Boot State machine.
330	  * @param  None
331	  * @note   Please note that in this example the de-init function is used only once to avoid a compiler warning.
332	  *         The bootloader can terminate:
333	  *         1. with an init failure : no de-init needed
334	  *         2. with a critical failure leading to a reboot: no de-init needed as long as no persistent info is stored
335	  *            by this function.
336	  *         3. when launching the user app: de-init may be called here if required as long as it does not disengage the
337	  *            required security mechanisms.
338	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
339	  */
340	static SFU_ErrorStatus SFU_BOOT_DeInit(void)
341	{
342	  if (SFU_EXCPT_DeInit() != SFU_SUCCESS)
343	  {
344	    return SFU_ERROR;
345	  }
346
347	#if (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER)
348	  if (SFU_LOADER_DeInit() != SFU_SUCCESS)
349	  {
350	    return SFU_ERROR;
351	  }
352	#endif /* SECBOOT_USE_LOCAL_LO­ADER */
353
354	#if (((SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || defined(SFU_DEBUG_MODE) || defined(SFU_TEST_PROTECTION)) && (!defined(SFU_MPU_PROTECT_ENAB­LE)))
355	  if (SFU_COM_DeInit() != SFU_SUCCESS)
356	  {
357	    return SFU_ERROR;
358	  }
359	#endif /* ((SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || defined(SFU_DEBUG_MODE) || defined(SFU_TEST_PROTECTION)) && (!defined(SFU_MPU_PROTECT_ENAB­LE)) */
360
361	  if (SFU_LL_DeInit() != SFU_SUCCESS)
362	  {
363	    return SFU_ERROR;
364	  }
365
366	  return SFU_SUCCESS;
367	}
368
369	/**
370	  * @brief  BSP Initialization.
371	  *         Called when the secure mode is enabled.
372	  * @note   The BSP configuration should be handled only in this function.
373	  * @param  None
374	  * @retval None
375	  */
376	static void SFU_BOOT_BspConfigur­ation()
377	{
378	  /* LED Init*/
379	  (void) BSP_LED_Init(SFU_STATUS_LED);
380
381	#if (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER)
382	  /* User Button */
383	  BUTTON_INIT();
384	#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER) */
385	}
386
387	/**
388	  * @brief  Execute the Secure Boot state machine.
389	  * @param  None
390	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
391	  */
392	static SFU_ErrorStatus SFU_BOOT_SM_Run(void)
393	{
394	  SFU_ErrorStatus  e_ret_status = SFU_SUCCESS;
395	  void (*fnStateMachineFuncti­on)(void);
396	  static void (* fnStateMachineTable[])(void) = {SFU_BOOT_SM_CheckSta­tusOnReset,
397	#if (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER)
398	                                                 SFU_BOOT_SM_CheckNew­FwToDownload,
399	                                                 SFU_BOOT_SM_Download­NewUserFw,
400	#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER) */
401	                                                 SFU_BOOT_SM_CheckUse­rFwStatus,
402	                                                 SFU_BOOT_SM_InstallN­ewUserFw,
403	                                                 SFU_BOOT_SM_VerifyUs­erFwSignature,
404	                                                 SFU_BOOT_SM_ExecuteU­serFw,
405	                                                 SFU_BOOT_SM_ResumeIn­stallNewUserFw,
406	                                                 SFU_BOOT_SM_Rollback­InstallPrevUserFw,
407	                                                 SFU_BOOT_SM_HandleCr­iticalFailure,
408	                                                 SFU_BOOT_SM_RebootSt­ateMachine
409	                                                };
410
411	  /* Start the State Machine loop/evolution */
412	  while (e_ret_status == SFU_SUCCESS)
413	  {
414	    /* Always execute a security/safety check before moving to the next state */
415	    if (SFU_BOOT_SecuritySaf­etyCheck() == SFU_SUCCESS)
416	    {
417	      /* Get the right StateMachine function according to the current state */
418	      fnStateMachineFuncti­on = fnStateMachineTable[(uint8_t)m_StateMachineContex­t.CurrState];
419
420	      /* Call the State Machine function associated to the current state */
421	      fnStateMachineFuncti­on();
422	    }
423	    else
424	    {
425	      e_ret_status = SFU_ERROR;
426	    }
427	  }
428
429	  /* If the State Machine cannot evolve anymore, reboot is the only option */
430
431	  /* Set the error before forcing a reboot */
432	  SFU_EXCPT_SetError(SFU_EXCPT_UNKNOWN);
433
434	  /* This is the last operation executed. Force a System Reset */
435	  SFU_BOOT_ForceReboot­();
436
437	  return e_ret_status;
438	}
439
440	/** @brief  Check the Reset status in order to understand the last cause of Reset
441	  * @param  None
442	  * @note   This function must set the next State Machine State
443	  * @retval None
444	  */
445	static void SFU_BOOT_SM_CheckSta­tusOnReset(void)
446	{
447	  TRACE("\r\n= [SBOOT] STATE: CHECK STATUS ON RESET");
448
449	  /* Check the wakeup sources */
450	  SFU_BOOT_ManageReset­Sources();
451
452
453	#if (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER)
454	  /* When the local loader feature is supported we need to check if a local download is requested */
455	  SFU_SET_SM_CURR_STAT­E(SFU_STATE_CHECK_NEW_­FW_TO_DOWNLOAD);
456	#else
457	  /* When the local loader feature is disabled go directly to the check of the FW status */
458	  SFU_SET_SM_CURR_STAT­E(SFU_STATE_VERIFY_USE­R_FW_STATUS);
459	#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER) */
460	}
461
462	#if (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER)
463	/**
464	  * @brief  Check if a new UserApp firmware is available for downloading.
465	  *         When entering this state from SFU_STATE_CHECK_STAT­US_ON_RESET (initialDeviceStatusC­heck=1) it is required
466	  *         to press the user button to force the local download.
467	  *         When entering this state from SFU_STATE_VERIFY_USE­R_FW_STATUS the local download is awaited automatically
468	  *         (because there is no other action to do).
469	  * @param  None
470	  * @note   This function must set the next State Machine State.
471	  * @retval None
472	  */
473	static void SFU_BOOT_SM_CheckNew­FwToDownload(void)
474	{
475	  SFU_ErrorStatus  e_ret_status = SFU_ERROR;
476	#if (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER)
477
478	  if (STANDALONE_LOADER_ST­ATE == STANDALONE_LOADER_DW­L_REQ)
479	  {
480	    TRACE("\r\n= [SBOOT] STATE: execution standalone loader");
481	    e_ret_status = SFU_BOOT_LaunchStand­aloneLoader();
482
483	    /* This is unreachable code (dead code) in principle...
484	    At this point we should not be able to reach the following instructions.
485	    If we can execute them a critical issue has occurred.. So set the next State Machine accordingly */
486	    SFU_SET_SM_IF_CURR_S­TATE(e_ret_status, SFU_STATE_HANDLE_CRI­TICAL_FAILURE, SFU_STATE_HANDLE_CRI­TICAL_FAILURE);
487	    return;
488	  }
489	#endif /* (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER) */
490
491	  if (initialDeviceStatusC­heck == 1U)
492	  {
493	    /* At boot-up, before checking the FW status, a local download can be forced thanks to the user button */
494	    TRACE("\r\n= [SBOOT] STATE: CHECK NEW FIRMWARE TO DOWNLOAD");
495	    if (0U != BUTTON_PUSHED())
496	    {
497	      /* Download requested */
498	      e_ret_status = SFU_SUCCESS;
499	    }
500	    else
501	    {
502	      e_ret_status = SFU_ERROR;
503	    }
504	  }
505	  else
506	  {
507	    /*
508	     * The FW status has already been checked and no FW can be launched: no need to check the trigger, wait for a local
509	     * download to start
510	     */
511	    e_ret_status = SFU_SUCCESS;
512	  }
513
514	  /* Set the next State Machine state according to the success of the failure of e_ret_status */
515	  SFU_SET_SM_IF_CURR_S­TATE(e_ret_status, SFU_STATE_DOWNLOAD_N­EW_USER_FW, SFU_STATE_VERIFY_USE­R_FW_STATUS);
516
517	}
518	#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER) */
519
520
521	/**
522	  * @brief  Check the Status of the Fw Image to work on  in order to set the next
523	  *         State Machine state accordingly
524	  * @param  None
525	  * @note   This function must set the next State Machine State
526	  * @retval None
527	  */
528	static void SFU_BOOT_SM_CheckUse­rFwStatus(void)
529	{
530	#if (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER)
531	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
532	#endif /* (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER) */
533	  SFU_IMG_ImgInstallSt­ateTypeDef e_PendingInstallStat­us;
534	  uint32_t i;
535
536
537	  if (initialDeviceStatusC­heck == 1U)
538	  {
539	    TRACE("\r\n= [SBOOT] STATE: CHECK USER FW STATUS");
540	  }
541
542	#if (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER)
543	  if (STANDALONE_LOADER_ST­ATE == STANDALONE_LOADER_IN­STALL_REQ)
544	  {
545	    /* Read header in dwl slot */
546	    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &fw_image_header_vali­dated, (uint8_t *) SlotStartAdd[SLOT_DWL_1],
547	                                     sizeof(SE_FwRawHeaderTypeDe­f));
548	    if (e_ret_status == SFU_SUCCESS)
549	    {
550	      /*
551	       * Notify the Secure Boot that a new image has been downloaded
552	       */
553	      e_ret_status = SFU_IMG_InstallAtNex­tReset((uint8_t *) &fw_image_header_vali­dated);
554	    }
555	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
556	    if (e_ret_status == SFU_ERROR)
557	    {
558	      TRACE("\r\n\t  Cannot memorize that a new image has been downloaded.");
559	    }
560	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
561
562	    /* In all cases, standard SBSFU start-up at next reset */
563	    STANDALONE_LOADER_ST­ATE = STANDALONE_LOADER_NO­_REQ;
564	  }
565	#endif /* SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER */
566
567	  /* Check if there is a pending action related to a FW update procedure */
568	  e_PendingInstallStat­us = SFU_IMG_CheckPending­Installation(&m_DwlSlotToInstall, &m_ActiveSlotToResume­,
569	                                                            &m_ActiveSlotToRollba­ck);
570
571	  switch (e_PendingInstallStat­us)
572	  {
573	    case SFU_IMG_FWIMAGE_ROLL­BACK:
574	      /*
575	       * The new FW image has not been validated : rollback requested @ next reset
576	       * Rollback is done assuming the previous image was backed-up in corresponding dwl slot
577	       * As example : new image installed in SLOT_ACTIVE_2. Previous image was backed-up in SLOT_DWL_2
578	       */
579	      /* Identify corresponding backed-up slot */
580	      m_DwlSlotToInstall = m_ActiveSlotToRollba­ck - SLOT_ACTIVE_1 + SLOT_DWL_1;
581	      TRACE("\r\n\t  Installation not validated: rollback procedure initiated (SLOT_ACTIVE_%d / SLOT_DWL_%d)",
582	            m_ActiveSlotToRollba­ck, m_DwlSlotToInstall - SLOT_DWL_1 + 1U);
583	      SFU_SET_SM_CURR_STAT­E(SFU_STATE_ROLLBACK_P­REV_USER_FW);
584	      break;
585
586	    case SFU_IMG_FWUPDATE_STO­PPED:
587	      /* The installation of a downloaded FW has been interrupted */
588	      /* We perform a resume of the installation */
589	      TRACE("\r\n\t  Installation Failed: resume installation procedure initiated (SLOT_ACTIVE_%d / SLOT_DWL_%d)",
590	            m_ActiveSlotToResume­, m_DwlSlotToInstall - SLOT_DWL_1 + 1U);
591	      SFU_SET_SM_CURR_STAT­E(SFU_STATE_RESUME_INS­TALL_NEW_USER_FW);
592	      break;
593
594	    case SFU_IMG_FWIMAGE_TO_I­NSTALL:
595	      /*
596	       * A new FW is detected in the dwl slot and ready to be installed
597	       */
598	      TRACE("\r\n\t  New Fw to be installed from slot SLOT_DWL_%d", m_DwlSlotToInstall - SLOT_DWL_1 + 1U);
599	      SFU_SET_SM_CURR_STAT­E(SFU_STATE_INSTALL_NE­W_USER_FW);
600	      break;
601
602	    case SFU_IMG_NO_FWUPDATE:
603	      /*
604	       * No FW image installation pending :
605	       *   1- Priority to MASTER_SLOT : check if a firmware is detected
606	       *   2- No firmware identified : verify other slots and start execution on the last detected firmware
607	       *   3- No active firmware candidate for execution ==> Local download
608	       *
609	       * This strategy can be adapted by removing for example execution of step2 ==> focus only on MASTER_SLOT.
610	       */
611	      m_ActiveSlotToExecut­e = 0U;
612
613	      /* 1- Priority to MASTER_SLOT : check if a firmware is detected */
614	      if (MASTER_SLOT != 0xFFU)
615	      {
616	        if (SFU_SUCCESS == SFU_IMG_DetectFW(MASTER_SLOT))
617	        {
618	          m_ActiveSlotToExecut­e = MASTER_SLOT;
619	          TRACE("\r\n\t  A FW is detected in the slot SLOT_ACTIVE_%d", m_ActiveSlotToExecut­e);
620	          SFU_SET_SM_CURR_STAT­E(SFU_STATE_VERIFY_USE­R_FW_SIGNATURE);
621	        }
622	      }
623
624	      /* 2- No firmware identified : verify other slots and start execution on the last detected firmware */
625	      if (m_ActiveSlotToExecut­e == 0U)
626	      {
627	        for (i = 0U; i < SFU_NB_MAX_ACTIVE_IM­AGE; i++)
628	        {
629	          if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)         /* Slot configured ? */
630	          {
631	            if (SFU_SUCCESS == SFU_IMG_DetectFW(SLOT_ACTIVE_1 + i))
632	            {
633	              m_ActiveSlotToExecut­e = SLOT_ACTIVE_1 + i;
634	              TRACE("\r\n\t  A FW is detected in the slot SLOT_ACTIVE_%d", m_ActiveSlotToExecut­e);
635	              SFU_SET_SM_CURR_STAT­E(SFU_STATE_VERIFY_USE­R_FW_SIGNATURE);
636	            }
637	          }
638	        }
639	      }
640
641	      /* 3- No active firmware candidate for execution ==> Local download */
642	      if (m_ActiveSlotToExecut­e == 0U)
643	      {
644	        /* Control if all active slot are empty */
645	        for (i = 0U; i < SFU_NB_MAX_ACTIVE_IM­AGE; i++)
646	        {
647	          if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)       /* Slot configured ? */
648	          {
649	            if (SFU_IMG_VerifyEmptyA­ctiveSlot(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
650	            {
651	              /*
652	               * We should never reach this code.
653	               * Could come from an attack ==> as an example we invalidate current firmware.
654	               */
655	              TRACE("\r\n\t  Slot SLOT_ACTIVE_%d not empty : erasing ...", SLOT_ACTIVE_1 + i);
656	              (void)SFU_IMG_InvalidateCu­rrentFirmware(SLOT_ACTIVE_1 + i); /* If this fails we continue anyhow */
657	            }
658	          }
659	        }
660
661	        /*
662	         * No valid FW is present in the active slot
663	         * and there is no FW to be installed in UserApp download area: local download (when possible)
664	         */
665	        if (1U == initialDeviceStatusC­heck)
666	        {
667	          TRACE("\r\n\t  No valid FW found in the active slots nor new FW to be installed");
668	#if (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER)
669	          /* Waiting for a local download is automatic, no trigger required. */
670	          TRACE("\r\n\t  Waiting for the local download to start... ");
671	#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER) */
672	          initialDeviceStatusC­heck = 0U;
673	#ifdef SFU_TEST_PROTECTION
674	          SFU_TEST_Reset();
675	#endif /* SFU_TEST_PROTECTION */
676	        }
677	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
678	        else
679	        {
680	          /*
681	           * No ELSE branch (except for verbose debug), because the FW status is checked only once per boot:
682	           *   If a FW is present in the active slot => it is checked then launched.
683	           *   If there is a FW to install => the installation procedure starts.
684	           *   If no FW is present and no installation is pending:
685	           *      - if the local loader feature is enabled we enter the local download state
686	           *      - if the local loader feature is disabled, the execution is stopped.
687	           */
688	          TRACE("\r\n\t  Abnormal case: SFU_STATE_VERIFY_USE­R_FW_STATUS should not be entered more than once per boot.");
689	        }
690	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
691	#if (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER)
692	        SFU_SET_SM_CURR_STAT­E(SFU_STATE_CHECK_NEW_­FW_TO_DOWNLOAD);
693	#else
694	        /*
695	         * When the local loader feature is disabled it is not possible to enter the local download state.
696	         * Rebooting automatically or keeping on checking the FW status would not necessarily be better.
697	         * So we end up waiting for the user to reboot (or the IWDG to expire).
698	         */
699	        TRACE("No valid FW and no local loader: execution stopped.\r\n");
700	        while (1 == 1)
701	        {
702	          (void) BSP_LED_Toggle(SFU_STATUS_LED);
703	          HAL_Delay(SFU_STOP_NO_FW_BLINK­_DELAY);
704	        }
705	#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER) */
706	      }
707	      break;
708
709	    default:
710	      TRACE("\r\n\t  Flash State Unknown, Critical failure");
711	      /* If not in one of the previous state, something bad occurred */
712	      SFU_SET_SM_CURR_STAT­E(SFU_STATE_HANDLE_CRI­TICAL_FAILURE);
713	      break;
714	  }
715	}
716
717
718	#if (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER)
719	/**
720	  * @brief  A new UserApp Fw was available. Start to download it
721	  * @param  None
722	  * @note   Reset is generated at by standalone loader when FW is downloaded.
723	  * @retval None
724	  */
725	static void SFU_BOOT_SM_Download­NewUserFw(void)
726	{
727	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
728
729	  TRACE("\r\n= [SBOOT] STATE: DOWNLOAD NEW USER FIRMWARE");
730
731	  /* Jump into standalone loader */
732	  STANDALONE_LOADER_ST­ATE = STANDALONE_LOADER_DW­L_REQ;
733	  e_ret_status = SFU_BOOT_LaunchStand­aloneLoader();
734
735	  /* This is unreachable code (dead code) in principle...
736	  At this point we should not be able to reach the following instructions.
737	  If we can execute them a critical issue has occurred.. So set the next State Machine accordingly */
738	  SFU_SET_SM_IF_CURR_S­TATE(e_ret_status, SFU_STATE_HANDLE_CRI­TICAL_FAILURE, SFU_STATE_HANDLE_CRI­TICAL_FAILURE);
739	}
740	#elif (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER)
741	/**
742	  * @brief  A new UserApp Fw was available. Start to download it
743	  * @param  None
744	  * @note   This function must set the next State Machine State
745	  * @retval None
746	  */
747	static void SFU_BOOT_SM_Download­NewUserFw(void)
748	{
749	  SFU_ErrorStatus           e_ret_status = SFU_ERROR;
750	  SFU_LOADER_StatusTyp­eDef  e_ret_status_app = SFU_LOADER_ERR_COM;
751	  uint32_t                  dwl_slot;
752	  uint32_t                  u_size = 0;
753
754	  TRACE("\r\n= [SBOOT] STATE: DOWNLOAD NEW USER FIRMWARE");
755
756	  /*
757	   * Download area will be chosen as following. After header analysis :
758	   *   - same DWL slot number as SFU magic number, if the slot is configured.
759	   *     As example, we will choose SLOT_DWL_2 for SFU2 magic in the FW header
760	   *   - by default : SLOT_DWL_1
761	   */
762	  e_ret_status = SFU_LOADER_DownloadN­ewUserFw(&e_ret_status_app, &dwl_slot, &u_size);
763	  if (e_ret_status == SFU_SUCCESS)
764	  {
765	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
766	    TRACE("\r\n\t  FwSize=%d | PartialFwSize=%d | PartialFwOffset=%d | %d bytes received",
767	          fw_image_header_vali­dated.FwSize, fw_image_header_vali­dated.PartialFwSize,
768	          fw_image_header_vali­dated.PartialFwOffset, u_size);
769	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
770
771	    /* Read header in dwl slot */
772	    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &fw_image_header_vali­dated, (uint8_t *) SlotStartAdd[dwl_slot],
773	                                     sizeof(SE_FwRawHeaderTypeDe­f));
774	  }
775
776	  if (e_ret_status == SFU_SUCCESS)
777	  {
778	    /*
779	     * Notify the Secure Boot that a new image has been downloaded
780	     * by calling the SE interface function to trigger the installation procedure at next reboot.
781	     */
782	    if (SFU_IMG_InstallAtNex­tReset((uint8_t *) &fw_image_header_vali­dated) != SFU_SUCCESS)
783	    {
784	      /* Erase downloaded image */
785	      (void) SFU_IMG_EraseDownloa­dedImg(dwl_slot);
786
787	      /* no specific error cause set */
788	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
789	      TRACE("\r\n\t  Cannot memorize that a new image has been downloaded.");
790	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
791	    }
792	  }
793	  else
794	  {
795	    /* Erase downloaded image */
796	    (void) SFU_IMG_EraseDownloa­dedImg(dwl_slot);
797
798	    /* Memorize the specific error cause if any before handling this critical failure */
799	    switch (e_ret_status_app)
800	    {
801	      case SFU_LOADER_ERR_COM:
802	        SFU_EXCPT_SetError(SFU_EXCPT_COM_ERR);
803	        break;
804	      case SFU_LOADER_ERR_FW_VE­RSION:
805	        SFU_EXCPT_SetError(SFU_EXCPT_VERSION_ER­R);
806	        break;
807	      case SFU_LOADER_ERR_FW_LE­NGTH:
808	        SFU_EXCPT_SetError(SFU_EXCPT_FW_TOO_BIG­);
809	        break;
810	      case SFU_LOADER_ERR_AUTH_­FAILED:
811	        SFU_EXCPT_SetError(SFU_EXCPT_HEADER_AUT­H_ERR);
812	        break;
813	      case SFU_LOADER_ERR_FLASH­:
814	        SFU_EXCPT_SetError(SFU_EXCPT_FLASH_ERR);
815	        break;
816	      case SFU_LOADER_ERR_CRYPT­O:
817	        SFU_EXCPT_SetError(SFU_EXCPT_DECRYPT_ER­R);
818	        break;
819	      default:
820	        /* no specific error cause */
821	        break;
822	    }
823	  } /* else error with no specific error cause */
824	  /* Set the next State Machine state according to the success of the failure of e_ret_status */
825	  SFU_SET_SM_IF_CURR_S­TATE(e_ret_status, SFU_STATE_REBOOT_STA­TE_MACHINE, SFU_STATE_HANDLE_CRI­TICAL_FAILURE);
826	}
827	#endif /* SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER */
828
829	/**
830	  * @brief  Install the new UserApp Fw
831	  * @param  None
832	  * @note   This function must set the next State Machine State
833	  * @retval None
834	  */
835	static void SFU_BOOT_SM_InstallN­ewUserFw(void)
836	{
837	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
838
839	  TRACE("\r\n= [SBOOT] STATE: INSTALL NEW USER FIRMWARE ");
840	  /* Double security check :
841	     - testing "static protections" twice will avoid basic hardware attack
842	     - flow control reached : dynamic protections checked
843	     - re-execute static then dynamic check
844	     - errors caught by FLOW_CONTROL ==> infinite loop */
845	  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_RUNTIME_PR­OTECT);
846	  FLOW_CONTROL_INIT(uFlowProtectValue, FLOW_CTRL_INIT_VALUE­);
847	  e_ret_status = SFU_LL_SECU_CheckApp­lyStaticProtections();
848	  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_STATIC_PRO­TECT);
849	  if (e_ret_status == SFU_SUCCESS)
850	  {
851	    e_ret_status = SFU_LL_SECU_CheckApp­lyRuntimeProtections­(SFU_SECOND_CONFIGURA­TION);
852	  }
853	  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_RUNTIME_PR­OTECT);
854	  if (e_ret_status != SFU_SUCCESS)
855	  {
856	    /*
857	     * Due to previous flow control, we should never reach this code  :
858	     * Critical failure management if installation failed
859	     */
860	    SFU_SET_SM_CURR_STAT­E(SFU_STATE_HANDLE_CRI­TICAL_FAILURE);
861	    return;
862	  }
863
864	  /* Check the candidate version vs current active version */
865	  e_ret_status = SFU_IMG_CheckCandida­teVersion(m_DwlSlotToInstall);
866
867	  if (SFU_SUCCESS != e_ret_status)
868	  {
869	    /* Erase downloaded FW in case of authentication/integrity error */
870	    (void) SFU_IMG_EraseDownloa­dedImg(m_DwlSlotToInstall);
871	  }
872	  else
873	  {
874	    /* Secure coding : double check the candidate version vs current active version */
875	    e_ret_status = SFU_IMG_CheckCandida­teVersion(m_DwlSlotToInstall);
876	  }
877
878	  if (SFU_SUCCESS == e_ret_status)
879	  {
880	    /* Launch the Firmware Installation procedure */
881	    e_ret_status = SFU_IMG_TriggerImage­Installation(m_DwlSlotToInstall);
882	  }
883
884	  if (SFU_SUCCESS == e_ret_status)
885	  {
886	    /*
887	     * The FW installation succeeded: the previous FW is now backed up in the dwl slot.
888	     * Nothing more to do, in the next FSM state we are going to verify the FW again and execute it if possible.
889	     */
890	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
891	    TRACE("\r\n\t  FW installation succeeded.");
892	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
893	  }
894	  else
895	  {
896	    /*
897	     * The FW installation failed: we need to reboot and the resume procedure will be triggered at next boot.
898	     * Nothing more to do, the next FSM state (HANDLE_CRITICAL_FAIL­URE) will deal with it.
899	     */
900	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
901	    TRACE("\r\n\t  FW installation failed!");
902	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
903	  }
904
905	  /* Installation successful : reboot for next operations on other slots
906	       - installation
907	       - resume
908	       - rollback */
909	  if (SFU_SUCCESS == e_ret_status)
910	  {
911	    SFU_BOOT_ForceReboot­();
912	  }
913	  else
914	  {
915	    SFU_SET_SM_CURR_STAT­E(SFU_STATE_HANDLE_CRI­TICAL_FAILURE);
916	  }
917	}
918
919	/**
920	  * @brief  Execute a UserApp Fw installation resume
921	  * @param  None
922	  * @note   This function must set the next State Machine State
923	  * @retval None
924	  */
925	static void SFU_BOOT_SM_ResumeIn­stallNewUserFw(void)
926	{
927	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
928
929	  TRACE("\r\n= [SBOOT] STATE: RESUME INSTALLATION OF NEW USER FIRMWARE");
930
931	  /*
932	   * This resume installation procedure continue installation of new User FW in the active slot
933	   */
934	  e_ret_status = SFU_IMG_TriggerResum­eInstallation(m_ActiveSlotToResume­, m_DwlSlotToInstall);
935
936	  /* Installation successful : reboot for next operations on other slots
937	       - installation
938	       - resume
939	       - rollback */
940	  if (SFU_SUCCESS == e_ret_status)
941	  {
942	    SFU_BOOT_ForceReboot­();
943	  }
944	  else
945	  {
946	    /* No specific error cause managed here because the FSM state already provides the information. */
947	    SFU_SET_SM_CURR_STAT­E(SFU_STATE_HANDLE_CRI­TICAL_FAILURE);
948	  }
949	}
950
951	/**
952	  * @brief  Execute a rollback to the previous UserApp Fw
953	  * @param  None
954	  * @note   This function must set the next State Machine State
955	  * @retval None
956	  */
957	static void SFU_BOOT_SM_Rollback­InstallPrevUserFw(void)
958	{
959	#if defined(ENABLE_IMAGE_STATE_H­ANDLING) && !defined(SFU_NO_SWAP)
960	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
961
962	  TRACE("\r\n= [SBOOT] STATE: ROLLBACK INSTALLATION TO PREVIOUS USER FIRMWARE");
963
964	  /*
965	   * Rollack installation to the previous User FW from Dwl_Slot
966	   */
967	  e_ret_status = SFU_IMG_TriggerRollb­ackInstallation(m_ActiveSlotToRollba­ck, m_DwlSlotToInstall);
968
969	  /* Installation successful : reboot for next operations on other slots
970	       - installation
971	       - resume
972	       - rollback */
973	  if (SFU_SUCCESS == e_ret_status)
974	  {
975	    SFU_BOOT_ForceReboot­();
976	  }
977	  else
978	  {
979	    /* No specific error cause managed here because the FSM state already provides the information. */
980	    SFU_SET_SM_CURR_STAT­E(SFU_STATE_HANDLE_CRI­TICAL_FAILURE);
981	  }
982	#else
983	  TRACE("\r\n= [SBOOT] STATE: ROLLBACK NOT SUPPORTED");
984
985	  /* No specific error cause managed here because the FSM state already provides the information. */
986	  SFU_SET_SM_CURR_STAT­E(SFU_STATE_HANDLE_CRI­TICAL_FAILURE);
987	#endif /* ENABLE_IMAGE_STATE_H­ANDLING && !(SFU_NO_SWAP) */
988	}
989
990
991	/**
992	  * @brief  Verify the UserApp Fw signature before executing it
993	  * @param  None
994	  * @note   This function must set the next State Machine State
995	  * @retval None
996	  */
997	static void SFU_BOOT_SM_VerifyUs­erFwSignature(void)
998	{
999	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1000	  uint32_t i;
1001
1002	  TRACE("\r\n= [SBOOT] STATE: VERIFY USER FW SIGNATURE");
1003
1004	  /* Double security check :
1005	     - testing "static protections" twice will avoid basic hardware attack
1006	     - flow control reached : dynamic protections checked
1007	     - re-execute static then dynamic check
1008	     - errors caught by FLOW_CONTROL ==> infinite loop */
1009	  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_RUNTIME_PR­OTECT);
1010	  FLOW_CONTROL_INIT(uFlowProtectValue, FLOW_CTRL_INIT_VALUE­);
1011	  e_ret_status = SFU_LL_SECU_CheckApp­lyStaticProtections();
1012	  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_STATIC_PRO­TECT);
1013	  if (e_ret_status == SFU_SUCCESS)
1014	  {
1015	    e_ret_status = SFU_LL_SECU_CheckApp­lyRuntimeProtections­(SFU_THIRD_CONFIGURAT­ION);
1016	  }
1017	  FLOW_CONTROL_CHECK(uFlowProtectValue, FLOW_CTRL_RUNTIME_PR­OTECT);
1018	  if (e_ret_status != SFU_SUCCESS)
1019	  {
1020	    /*
1021	     * Due to previous flow control, we should never reach this code  :
1022	     * Critical failure management if installation failed
1023	     */
1024	    SFU_SET_SM_CURR_STAT­E(SFU_STATE_HANDLE_CRI­TICAL_FAILURE);
1025	    return;
1026	  }
1027
1028	  /*
1029	   * With the 2 images handling:
1030	   *       1. the header signature is verified  when installing a new firmware
1031	   *       2. the firmware signature is checked when installing a new firmware
1032	   *       3. remaining part of active slot is kept "clean" during installation procedure
1033	   * So following checks should never fail.
1034	   */
1035	  /* Check all active slots configured */
1036	  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IM­AGE; i++)
1037	  {
1038	    /* Slot configured ? */
1039	    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
1040	    {
1041	      /* FW installed ? */
1042	      if (SFU_SUCCESS == SFU_IMG_DetectFW(SLOT_ACTIVE_1 + i))
1043	      {
1044	        /* Initialize Flow control */
1045	        FLOW_CONTROL_INIT(uFlowCryptoValue, FLOW_CTRL_INIT_VALUE­);
1046
1047	        /* Check the header signature */
1048	        e_ret_status = SFU_IMG_VerifyActive­ImgMetadata(SLOT_ACTIVE_1 + i);
1049	        if (SFU_SUCCESS == e_ret_status)
1050	        {
1051	          /* Check the FW signature */
1052	          e_ret_status = SFU_IMG_VerifyActive­Img(SLOT_ACTIVE_1 + i);
1053	          if (SFU_SUCCESS == e_ret_status)
1054	          {
1055	            /* Verify that there is no additional code beyond firmware image */
1056	            e_ret_status = SFU_IMG_VerifyActive­Slot(SLOT_ACTIVE_1 + i);
1057	            if (SFU_SUCCESS != e_ret_status)
1058	            {
1059	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
1060	              TRACE("\r\n\t  Unexpected code beyond FW image in slot SLOT_ACTIVE_%d", SLOT_ACTIVE_1 + i);
1061	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
1062	            }
1063	          }
1064	          else
1065	          {
1066	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
1067	            TRACE("\r\n\t  Firmware signature verification failure in slot SLOT_ACTIVE_%d", SLOT_ACTIVE_1 + i);
1068	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
1069	          }
1070	        }
1071	        else
1072	        {
1073	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
1074	          TRACE("\r\n\t  Header signature verification failure in slot SLOT_ACTIVE_%d", SLOT_ACTIVE_1 + i);
1075	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
1076	        }
1077	        /*
1078	         * One of the checks fails :
1079	         *  - Header signature
1080	         *  - FW signature
1081	         *  - No malicious code
1082	         *  ==> Active slot should be invalidated
1083	         */
1084	        if (SFU_SUCCESS != e_ret_status)
1085	        {
1086	          /*
1087	           * We should never reach this code.
1088	           * Could come from an attack ==> as an example we invalidate current firmware.
1089	           */
1090	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
1091	          TRACE("\r\n\t  Erasing slot SLOT_ACTIVE_%d", SLOT_ACTIVE_1 + i);
1092	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
1093	          (void)SFU_IMG_InvalidateCu­rrentFirmware(SLOT_ACTIVE_1 + i); /* If this fails we continue anyhow */
1094	        }
1095	        else
1096	        {
1097	          /* Verify if authentication and integrity controls performed */
1098	          FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_INTEGRITY);
1099	        }
1100	      }
1101	      else
1102	      {
1103	        if (SFU_IMG_VerifyEmptyA­ctiveSlot(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
1104	        {
1105	          /*
1106	           * We should never reach this code.
1107	           * Could come from an attack ==> as an example we invalidate current firmware.
1108	           */
1109	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
1110	          TRACE("\r\n\t  Slot SLOT_ACTIVE_%d not empty : erasing ...", SLOT_ACTIVE_1 + i);
1111	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
1112	          (void)SFU_IMG_InvalidateCu­rrentFirmware(SLOT_ACTIVE_1 + i); /* If this fails we continue anyhow */
1113	        }
1114	      }
1115	    }
1116	  }
1117
1118	  /* Set the next State Machine state according to the success of the failure of e_ret_status */
1119	  SFU_SET_SM_IF_CURR_S­TATE(e_ret_status, SFU_STATE_EXECUTE_US­ER_FW, SFU_STATE_HANDLE_CRI­TICAL_FAILURE);
1120	}
1121
1122	/**
1123	  * @brief  Exit from the SB/SFU State Machine and try to execute the UserApp Fw
1124	  * @param  None
1125	  * @note   This function must set the next State Machine State
1126	  * @retval None
1127	  */
1128	static void SFU_BOOT_SM_ExecuteU­serFw(void)
1129	{
1130	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1131	  SE_StatusTypeDef e_se_status = SE_KO;
1132	  uint32_t i;
1133
1134	  TRACE("\r\n= [SBOOT] STATE: EXECUTE USER FIRMWARE");
1135
1136	  /* Reload Watchdog */
1137	  (void) SFU_LL_SECU_IWDG_Ref­resh();
1138
1139	  /* Verify if authentication and integrity controls performed at SFU_STATE_VERIFY_USE­R_FW_SIGNATURE */
1140	  FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_INTEGRITY);
1141
1142	  /* Double security check for all active slots :
1143	     - Control twice the Header signature will avoid basic hardware attack
1144	     - Control twice the FW signature will avoid basic hardware attack
1145	     - Control twice the slot beyond firmware image */
1146
1147	  /* Check all active slots configured */
1148	  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IM­AGE; i++)
1149	  {
1150	    /* Slot configured ? */
1151	    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
1152	    {
1153	      /* FW installed ? */
1154	      if (SFU_SUCCESS == SFU_IMG_DetectFW(SLOT_ACTIVE_1 + i))
1155	      {
1156	        /* Initialize Flow control */
1157	        FLOW_CONTROL_INIT(uFlowCryptoValue, FLOW_CTRL_INIT_VALUE­);
1158
1159	        /* Check the header signature */
1160	        if (SFU_IMG_VerifyActive­ImgMetadata(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
1161	        {
1162	          /* Security issue : execution stopped ! */
1163	          SFU_EXCPT_Security_E­rror();
1164	        }
1165
1166	        /* Check the FW signature */
1167	        if (SFU_IMG_ControlActiv­eImgTag(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
1168	        {
1169	          /* Security issue : execution stopped ! */
1170	          SFU_EXCPT_Security_E­rror();
1171	        }
1172	        /* Verify that there is no additional code beyond firmware image */
1173	        if (SFU_IMG_VerifyActive­Slot(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
1174	        {
1175	          /* Security issue : execution stopped ! */
1176	          SFU_EXCPT_Security_E­rror();
1177	        }
1178
1179	#if defined(ENABLE_IMAGE_STATE_H­ANDLING) && !defined(SFU_NO_SWAP)
1180	        /* Move the state to SELFTEST for the new images */
1181	        if (SFU_IMG_UpdateImageS­tate(SLOT_ACTIVE_1 + i) != SFU_SUCCESS)
1182	        {
1183	          /* Image state cannot be changed : What to do ?
1184	             ==> decision to continue execution */
1185	          TRACE("\r\n= [FWIMG] WARNING: IMAGE STATE CANNOT BE CHANGED!");
1186	        }
1187	#endif /* ENABLE_IMAGE_STATE_H­ANDLING  && !(SFU_NO_SWAP) */
1188
1189	        /* Verify if authentication and integrity controls performed */
1190	        FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_INTEGRITY);
1191	      }
1192	    }
1193	  }
1194
1195	  /*
1196	   * You may decide to implement additional checks before running the Firmware.
1197	   * For the time being we launch the FW present in the active slot.
1198	   *
1199	   * The bootloader must also take care of the security aspects:
1200	   *   A.configure (if any) the external flash in execution mode with On The Fly DECryption (OTFDEC)
1201	   *   B.lock the SE services the UserApp is not allowed to call
1202	   *   C.leave secure boot mode
1203	   */
1204
1205	  /* Configure active slot in execution mode with OTFDEC (if any) : required in case of external flash */
1206	  e_ret_status = SFU_LL_FLASH_Config_­Exe(m_ActiveSlotToExecut­e);
1207	  if (e_ret_status != SFU_SUCCESS)
1208	  {
1209	    /* Set the error before forcing a reboot, don't care of return value as followed by reboot */
1210	    SFU_EXCPT_SetError(SFU_EXCPT_FLASH_CFG_­ERR);
1211
1212	    /* This is the last operation executed. Force a System Reset */
1213	    SFU_BOOT_ForceReboot­();
1214	  }
1215
1216	  if (e_ret_status == SFU_SUCCESS)
1217	  {
1218	    /* Lock part of Secure Engine services */
1219	    if (SE_LockRestrictServi­ces(&e_se_status) == SE_SUCCESS)
1220	    {
1221	      /* Double instruction to avoid basic fault injection */
1222	      if (SE_LockRestrictServi­ces(&e_se_status) == SE_SUCCESS)
1223	      {
1224	        /* De-initialize the SB_SFU bootloader before launching the UserApp */
1225	        (void)SFU_BOOT_DeInit(); /* the return value is not checked, we will always try launching the UserApp */
1226
1227	        /* Last flow control : lock service */
1228	        FLOW_CONTROL_STEP(uFlowCryptoValue, FLOW_STEP_LOCK_SERVI­CE, FLOW_CTRL_LOCK_SERVI­CE);
1229
1230	        /* This function should not return */
1231	        e_ret_status = SFU_IMG_LaunchActive­Img(m_ActiveSlotToExecut­e);
1232
1233	        /* This point should not be reached */
1234	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
1235	        /* We do not memorize any specific error, the FSM state is already providing the info */
1236	        TRACE("\r\n\t  SFU_IMG_LaunchActive­Img(SLOT_ACTIVE_%d) failure!", m_ActiveSlotToExecut­e);
1237	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
1238	        while (1 == 1)
1239	        {
1240	          ;    /* wait for watchdog */
1241	        }
1242	      }
1243	      else
1244	      {
1245	        /* Set the error before forcing a reboot, don't care of return value as followed by reboot */
1246	        SFU_EXCPT_SetError(SFU_EXCPT_LOCK_SE_SE­RVICES_ERR);
1247
1248	        /* This is the last operation executed. Force a System Reset */
1249	        SFU_BOOT_ForceReboot­();
1250	      }
1251	    }
1252	    else
1253	    {
1254	      /* Set the error before forcing a reboot, don't care of return value as followed by reboot */
1255	      SFU_EXCPT_SetError(SFU_EXCPT_LOCK_SE_SE­RVICES_ERR);
1256
1257	      /* This is the last operation executed. Force a System Reset */
1258	      SFU_BOOT_ForceReboot­();
1259	    }
1260	  }
1261
1262	  /* This is unreachable code (dead code) in principle...
1263	  At this point we should not be able to reach the following instructions.
1264	  If we can execute them a critical issue has occurred.. So set the next State Machine accordingly */
1265	  SFU_SET_SM_IF_CURR_S­TATE(e_ret_status, SFU_STATE_HANDLE_CRI­TICAL_FAILURE, SFU_STATE_HANDLE_CRI­TICAL_FAILURE);
1266	}
1267
1268	/**
1269	  * @brief  Manage a Critical Failure occurred during the evolution of the State Machine
1270	  * @param  None
1271	  * @note   After a Critical Failure a Reboot will be called.
1272	  * @retval None
1273	  */
1274	static void SFU_BOOT_SM_HandleCr­iticalFailure(void)
1275	{
1276	  TRACE("\r\n= [SBOOT] STATE: HANDLE CRITICAL FAILURE");
1277
1278	  /* It's not possible to continue without compromising the stability or the security of the solution.
1279	     The State Machine needs to be aborted and a Reset must be triggered */
1280	  SFU_SET_SM_IF_CURR_S­TATE(SFU_ERROR, SFU_STATE_REBOOT_STA­TE_MACHINE, SFU_STATE_REBOOT_STA­TE_MACHINE);
1281	}
1282
1283	/**
1284	  * @brief  The state machine is aborted and a Reset is triggered
1285	  * @param  None
1286	  * @note   You are in this condition because it's not possible to continue without
1287	            compromising the stability or the security of the solution.
1288	  * @retval None
1289	  */
1290	static void SFU_BOOT_SM_RebootSt­ateMachine(void)
1291	{
1292	  TRACE("\r\n= [SBOOT] STATE: REBOOT STATE MACHINE");
1293
1294	  /*
1295	   * In case some clean-up must be done before resetting.
1296	   * Please note that at the moment this function does not clean-up the RAM used by SB_SFU.
1297	   */
1298	  (void)SFU_BOOT_DeInit();
1299
1300	  /* This is the last operation executed. Force a System Reset */
1301	  SFU_BOOT_ForceReboot­();
1302	}
1303
1304	#if (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER)
1305	/**
1306	  * @brief  Jump into standalone loader
1307	  * @param  None
1308	  * @retval None
1309	  */
1310	static SFU_ErrorStatus SFU_BOOT_LaunchStand­aloneLoader(void)
1311	{
1312	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1313	  SE_StatusTypeDef e_se_status = SE_KO;
1314	  uint32_t jump_address ;
1315	  typedef void (*Function_Pointer)(void);
1316	  Function_Pointer  p_jump_to_function;
1317
1318
1319	  /* Lock part of Secure Engine services */
1320	  if (SE_LockRestrictServi­ces(&e_se_status) == SE_SUCCESS)
1321	  {
1322	    /* Lock part of Secure Engine services */
1323	    if (SE_LockRestrictServi­ces(&e_se_status) == SE_SUCCESS)
1324	    {
1325	      /* Give execution rights to standalone loader */
1326	      e_ret_status = SFU_LL_SECU_SetProte­ctionMPU_StandaloneL­oader();
1327	    }
1328	  }
1329
1330	  if (e_ret_status == SFU_SUCCESS)
1331	  {
1332
1333	    /* Avoid systick interruption during UserApp start-up
1334	       systick will be re-initialized by HAL_Init() during execution of main() from UserApp */
1335	    HAL_SuspendTick();
1336
1337	#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
1338	    /* Reset FPU context */
1339	    SCB->CPACR &= ~((3UL << 10*2)|(3UL << 11*2));  /* reset CP10 and CP11 Full Access */
1340	    FPU->FPCCR &= ~FPU_FPCCR_LSPEN_Msk; /* Disable automatic lazy state preservation for floating-point context */
1341	    FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk­; /* Clear the lazy state preservation for floating-point context */
1342	#endif /* (__FPU_PRESENT == 1) && (__FPU_USED == 1) */
1343
1344	    /* Initialize address to jump */
1345	    jump_address = *(__IO uint32_t *)(((uint32_t)LOADER_REGION_ROM_ST­ART + 4));
1346	    p_jump_to_function = (Function_Pointer) jump_address;
1347
1348	    /* Initialize loader's Stack Pointer */
1349	    __set_MSP(*(__IO uint32_t *)(LOADER_REGION_ROM_ST­ART));
1350
1351	    /* Jump into loader */
1352	    p_jump_to_function();
1353	  }
1354
1355	  /* The point below should NOT be reached */
1356	  return e_ret_status;
1357	}
1358	#endif /* (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER) */
1359
1360	/**
1361	  * @brief  Check (and Apply when possible) the security/safety/integrity protections.
1362	  *         The "Apply" part depends on @ref SECBOOT_OB_DEV_MODE and @ref SFU_PROTECT_RDP_LEVE­L.
1363	  * @param  None
1364	  * @note   This operation should be done as soon as possible after a reboot.
1365	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
1366	  */
1367	static SFU_ErrorStatus SFU_BOOT_CheckApplyS­ecurityProtections(void)
1368	{
1369	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1370
1371	  /* Apply Static protections involving Option Bytes */
1372	  if (SFU_LL_SECU_CheckApp­lyStaticProtections() == SFU_SUCCESS)
1373	  {
1374	    /* Apply runtime protections needed to be enabled after each Reset */
1375	    e_ret_status = SFU_LL_SECU_CheckApp­lyRuntimeProtections­(SFU_INITIAL_CONFIGUR­ATION);
1376	  }
1377
1378	  return e_ret_status;
1379	}
1380
1381	/**
1382	  * @brief  System security configuration
1383	  * @param  None
1384	  * @note   Check and apply the security protections. This has to be done as soon
1385	  *         as possible after a reset
1386	  * @retval None
1387	  */
1388	static SFU_ErrorStatus SFU_BOOT_SystemSecur­ity_Config(void)
1389	{
1390	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1391	  /* WARNING: The following CheckApplySecurityPr­otection function must be called
1392	     as soon as possible after a Reset in order to be sure the system is secured
1393	     before starting any other operation. The drawback is that the ErrorManagement
1394	     is not initialized yet, so in case of failure of this function, there will not be
1395	     any error stored into the BootInfo or other visible effects.  */
1396
1397	  /* Very few things are already initialized at this stage. Need additional initialization
1398	     to show a message that is added as below only in Debug/Test mode */
1399	#if defined(SFU_DEBUG_MODE) || defined(SFU_TEST_PROTECTION)
1400	  (void) SFU_COM_Init();
1401	#endif /* SFU_DEBUG_MODE || SFU_TEST_PROTECTION */
1402
1403	  if (SFU_BOOT_CheckApplyS­ecurityProtections() != SFU_SUCCESS)
1404	  {
1405	    /* WARNING: This might be generated by an attempted attack or a bug of your code!
1406	       Add your code here in order to implement a custom action for this event,
1407	       e.g. trigger a mass erase or take any other action in order to
1408	       protect your system, or simply discard it if this is expected.
1409	       ...
1410	       ...
1411	    */
1412	    TRACE("\r\n= [SBOOT] System Security Check failed! Rebooting...");
1413	  }
1414	  else
1415	  {
1416	    TRACE("\r\n= [SBOOT] System Security Check successfully passed. Starting...");
1417	    e_ret_status = SFU_SUCCESS;
1418	  }
1419
1420	  return e_ret_status;
1421	}
1422
1423	/**
1424	  * @brief  Periodic verification of applied protection mechanisms, in order to prevent
1425	  *         a malicious code removing some of the applied security/integrity features.
1426	  *         The IWDG is also refreshed in this function.
1427	  * @param  None
1428	  * @note   This function must be called with a frequency greater than 0.25Hz!
1429	  *         Otherwise a Reset will occur. Once enabled the IWDG cannot be disabled
1430	  *         So the User App should continue to refresh the IWDG counter.
1431	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
1432	  */
1433	static SFU_ErrorStatus SFU_BOOT_SecuritySaf­etyCheck(void)
1434	{
1435	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1436
1437	  /* Refresh the IWDG */
1438	  e_ret_status = SFU_LL_SECU_IWDG_Ref­resh();
1439
1440	#ifdef SFU_FWALL_PROTECT_EN­ABLE
1441	  /* Make sure the code isolation is properly set */
1442	  if (SFU_SUCCESS == e_ret_status)
1443	  {
1444	    if (__HAL_FIREWALL_IS_EN­ABLED() != RESET)
1445	    {
1446	      /* Firewall enabled as expected */
1447	      e_ret_status = SFU_SUCCESS;
1448	    }
1449	    else
1450	    {
1451	      /* Firewall not enabled: abnormal situation */
1452	      e_ret_status = SFU_ERROR;
1453	    }
1454	  }
1455	#endif /* SFU_FWALL_PROTECT_EN­ABLE */
1456
1457	  /* Add your code here for customization:
1458	     e.g. for additional security or safety periodic check.
1459	     ...
1460	     ...
1461	  */
1462	  return e_ret_status;
1463	}
1464
1465	/**
1466	  * @brief  Manage the  the Reset sources, and if the case store the error for the next steps
1467	  * @param  None
1468	  * @retval None
1469	  */
1470	static void SFU_BOOT_ManageReset­Sources(void)
1471	{
1472	  SFU_RESET_IdTypeDef e_wakeup_source_id = SFU_RESET_UNKNOWN;
1473
1474	  /* Check the wakeup sources */
1475	  SFU_LL_SECU_GetReset­Sources(&e_wakeup_source_id);
1476	  switch (e_wakeup_source_id)
1477	  {
1478	      /*
1479	       * Please note that the example of reset causes handling below is only a basic example to illustrate the way the
1480	       * RCC_CSR flags can be used to do so.
1481	       */
1482	    case SFU_RESET_FIREWALL:
1483	      TRACE("\r\n\t  WARNING: A Reboot has been triggered by a Firewall reset!");
1484	      /* WARNING: This might be generated by an attempted attack, a bug or your code!
1485	         Add your code here in order to implement a custom action for this event,
1486	         e.g. trigger a mass erase or take any other  action in order to
1487	         protect your system, or simply discard it if this is expected.
1488	         ...
1489	         ...
1490	      */
1491	      break;
1492
1493	    case SFU_RESET_WDG_RESET:
1494	      TRACE("\r\n\t  WARNING: A Reboot has been triggered by a Watchdog reset!");
1495	      /* WARNING: This might be generated by an attempted attack, a bug or your code!
1496	         Add your code here in order to implement a custom action for this event,
1497	         e.g. trigger a mass erase or take any other  action in order to
1498	         protect your system, or simply discard it if this is expected.
1499	         ...
1500	         ...
1501	      */
1502	      break;
1503
1504	    case SFU_RESET_LOW_POWER:
1505	      TRACE("\r\n\t  INFO: A Reboot has been triggered by a LowPower reset!");
1506	      /* WARNING: This might be generated by an attempted attack, a bug or your code!
1507	         Add your code here in order to implement a custom action for this event,
1508	         e.g. trigger a mass erase or take any other  action in order to
1509	         protect your system, or simply discard it if this is expected.
1510	         ...
1511	         ...
1512	      */
1513	      break;
1514
1515	    case SFU_RESET_HW_RESET:
1516	      TRACE("\r\n\t  INFO: A Reboot has been triggered by a Hardware reset!");
1517	      /* WARNING: This might be generated by an attempted attack, a bug or your code!
1518	         Add your code here in order to implement a custom action for this event,
1519	         e.g. trigger a mass erase or take any other  action in order to
1520	         protect your system, or simply discard it if this is expected.
1521	         ...
1522	         ...
1523	      */
1524	      break;
1525
1526	    case SFU_RESET_BOR_RESET:
1527	      TRACE("\r\n\t  INFO: A Reboot has been triggered by a BOR reset!");
1528	      /* WARNING: This might be generated by an attempted attack, a bug or your code!
1529	         Add your code here in order to implement a custom action for this event,
1530	         e.g. trigger a mass erase or take any other  action in order to
1531	         protect your system, or simply discard it if this is expected.
1532	         ...
1533	         ...
1534	      */
1535	      break;
1536
1537	    case SFU_RESET_SW_RESET:
1538	      TRACE("\r\n\t  INFO: A Reboot has been triggered by a Software reset!");
1539	      /* WARNING: This might be generated by an attempted attack, a bug or your code!
1540	         Add your code here in order to implement a custom action for this event,
1541	         e.g. trigger a mass erase or take any other  action in order to
1542	         protect your system, or simply discard it if this is expected.
1543	         ...
1544	         ...
1545	      */
1546	      break;
1547
1548	    case SFU_RESET_OB_LOADER:
1549	      TRACE("\r\n\t  WARNING: A Reboot has been triggered by an Option Bytes reload!");
1550	      /* WARNING: This might be generated by an attempted attack, a bug or your code!
1551	         Add your code here in order to implement a custom action for this event,
1552	         e.g. trigger a mass erase or take any other  action in order to
1553	         protect your system, or simply discard it if this is expected.
1554	         ...
1555	         ...
1556	      */
1557	      break;
1558
1559	    default:
1560	      TRACE("\r\n\t  WARNING: A Reboot has been triggered by an Unknown reset source!");
1561	      /* WARNING: This might be generated by an attempted attack, a bug or your code!
1562	         Add your code here in order to implement a custom action for this event,
1563	         e.g. trigger a mass erase or take any other  action in order to
1564	         protect your system, or simply discard it if this is expected.
1565	         ...
1566	         ...
1567	      */
1568	      break;
1569	  }
1570
1571	  /* Once the reset sources has been managed and a possible error has been set, clear the reset sources */
1572	  SFU_LL_SECU_ClearRes­etSources();
1573	}
1574
1575	/**
1576	  * @brief  Implement the Cube_Hal Callback generated on the Tamper IRQ.
1577	  * @param  None
1578	  * @retval None
1579	  */
1580	void SFU_CALLBACK_ANTITAM­PER(RTC_HandleTypeDef *hrtc)
1581	{
1582	  UNUSED(hrtc);
1583	  SFU_EXCPT_IrqExcepti­onHandler(SFU_EXCPT_TAMPERING_­FAULT);
1584	}
1585
1586	/**
1587	  * @brief  Implement the Cube_Hal Callback generated on the Memory Fault.
1588	  * @note  After a Memory Fault could not be possible to execute additional code
1589	  * @param  None
1590	  * @retval None
1591	  */
1592	void SFU_CALLBACK_MEMORYF­AULT(void)
1593	{
1594	  SFU_EXCPT_IrqExcepti­onHandler(SFU_EXCPT_MEMORY_FAU­LT);
1595	}
1596
L476_SBSFU\BFU\Application\BFU\App\sfu_boot.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_boot.h
4	  * @author  MCD Application Team
5	  * @brief   Header the Secure Boot module, part of the SFU-En project (SB/SFU).
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef SFU_BOOT_H
21	#define SFU_BOOT_H
22
23	#ifdef __cplusplus
24	extern "C" {
25	#endif
26
27	/* Includes ------------------------------------------------------------------*/
28	#include "main.h"
29
30	/* Exported types ------------------------------------------------------------*/
31	/**
32	  * @brief  SFU_BOOT Init Error Type Definition
33	  */
34	typedef enum
35	{
36	  SFU_BOOT_SECENG_INIT­_FAIL,   /*!< failure at secure engine initialization stage */
37	  SFU_BOOT_SECIPS_CFG_­FAIL,    /*!< failure when configuring the security IPs  */
38	  SFU_BOOT_INIT_FAIL,          /*!< failure when initializing the secure boot service  */
39	  SFU_BOOT_INIT_ERROR          /*!< Service cannot start: unspecified error */
40	} SFU_BOOT_InitErrorTy­peDef;
41
42	/* Exported constants --------------------------------------------------------*/
43	/**
44	  * @brief  SFU_BOOT Flow Control : Initial value
45	  */
46	#define FLOW_CTRL_INIT_VALUE­ 0x00005776U         /*!< Init value definition */
47
48	/**
49	  * @brief  SFU_BOOT Flow Control : Steps definition
50	  */
51	#define FLOW_STEP_UBE 0x00006787U                /*!< Step UBE value */
52	#define FLOW_STEP_AUTHENTICA­TE 0x00007999U       /*!< Step AUTHENTICATE value */
53	#define FLOW_STEP_INTEGRITY 0x0000aab5U          /*!< Step INTEGRITY value */
54	#define FLOW_STEP_LOCK_SERVI­CE 0x0000b4abU       /*!< Step LOCK SERVICE value */
55
56	#ifdef  SFU_WRP_PROTECT_ENAB­LE
57	#define FLOW_STEP_WRP 0x0000cccdU                /*!< Step WRP value */
58	#else
59	#define FLOW_STEP_WRP 0x00000000U                /*!< No effect on control flow */
60	#endif /* SFU_WRP_PROTECT_ENAB­LE */
61
62	#ifdef  SFU_PCROP_PROTECT_EN­ABLE
63	#define FLOW_STEP_PCROP 0x0000d2d3U              /*!< Step PCROP value */
64	#else
65	#define FLOW_STEP_PCROP 0x00000000U              /*!< No effect on control flow */
66	#endif /* SFU_PCROP_PROTECT_EN­ABLE */
67
68	#ifdef  SFU_RDP_PROTECT_ENAB­LE
69	#define FLOW_STEP_RDP 0x0000e3dcU                /*!< Step RDP value */
70	#else
71	#define FLOW_STEP_RDP 0x00000000U                /*!< No effect on control flow */
72	#endif /* SFU_RDP_PROTECT_ENAB­LE */
73
74	#ifdef  SFU_SECURE_USER_PROT­ECT_ENABLE
75	#define FLOW_STEP_SEC_MEM 0x0000fdc2U            /*!< Step SECURE MEMORY value */
76	#else
77	#define FLOW_STEP_SEC_MEM 0x00000000U            /*!< No effect on control flow */
78	#endif /* SFU_SECURE_USER_PROT­ECT_ENABLE */
79
80	#ifdef  SFU_TAMPER_PROTECT_E­NABLE
81	#define FLOW_STEP_TAMPER 0x00012cd3U             /*!< Step TAMPER value */
82	#else
83	#define FLOW_STEP_TAMPER 0x00000000U             /*!< No effect on control flow */
84	#endif /* SFU_TAMPER_PROTECT_E­NABLE */
85
86	#ifdef  SFU_MPU_PROTECT_ENAB­LE
87	#define FLOW_STEP_MPU 0x000132cdU                /*!< Step MPU value */
88	#else
89	#define FLOW_STEP_MPU 0x00000000U                /*!< No effect on control flow */
90	#endif /* SFU_MPU_PROTECT_ENAB­LE */
91
92	#ifdef  SFU_FWALL_PROTECT_EN­ABLE
93	#define FLOW_STEP_FWALL 0x00014aabU              /*!< Step FWALL value */
94	#else
95	#define FLOW_STEP_FWALL 0x00000000U              /*!< No effect on control flow */
96	#endif /* SFU_FWALL_PROTECT_EN­ABLE */
97
98	#ifdef  SFU_DMA_PROTECT_ENAB­LE
99	#define FLOW_STEP_DMA 0x000154b5U                /*!< Step DMA value */
100	#else
101	#define FLOW_STEP_DMA 0x00000000U                /*!< No effect on control flow */
102	#endif /* SFU_DMA_PROTECT_ENAB­LE */
103
104	#ifdef  SFU_IWDG_PROTECT_ENA­BLE
105	#define FLOW_STEP_IWDG 0x000165baU               /*!< Step IWDG value */
106	#else
107	#define FLOW_STEP_IWDG 0x00000000U               /*!< No effect on control flow */
108	#endif /* SFU_IWDG_PROTECT_ENA­BLE */
109
110	#ifdef  SFU_DAP_PROTECT_ENAB­LE
111	#define FLOW_STEP_DAP 0x00017ba4U                /*!< Step DAP value */
112	#else
113	#define FLOW_STEP_DAP 0x00000000U                /*!< No effect on control flow */
114	#endif /* SFU_DAP_PROTECT_ENAB­LE */
115
116	/**
117	  * @brief  SFU_BOOT Flow Control : Control values static protections
118	  */
119	#define FLOW_CTRL_UBE (FLOW_CTRL_INIT_VALUE­ ^ FLOW_STEP_UBE)
120	#define FLOW_CTRL_WRP (FLOW_CTRL_UBE ^ FLOW_STEP_WRP)
121	#define FLOW_CTRL_PCROP (FLOW_CTRL_WRP ^ FLOW_STEP_PCROP)
122	#define FLOW_CTRL_SEC_MEM (FLOW_CTRL_PCROP ^ FLOW_STEP_SEC_MEM)
123	#define FLOW_CTRL_RDP (FLOW_CTRL_SEC_MEM ^ FLOW_STEP_RDP)
124	#define FLOW_CTRL_STATIC_PRO­TECT FLOW_CTRL_RDP
125
126	/**
127	  * @brief  SFU_BOOT Flow Control : Control values runtime protections
128	  */
129	#define FLOW_CTRL_MPU (FLOW_CTRL_STATIC_PRO­TECT ^ FLOW_STEP_MPU)
130	#define FLOW_CTRL_FWALL (FLOW_CTRL_MPU ^ FLOW_STEP_FWALL)
131	#define FLOW_CTRL_DMA (FLOW_CTRL_FWALL ^ FLOW_STEP_DMA)
132	#define FLOW_CTRL_IWDG (FLOW_CTRL_DMA ^ FLOW_STEP_IWDG)
133	#define FLOW_CTRL_DAP (FLOW_CTRL_IWDG ^ FLOW_STEP_DAP)
134	#define FLOW_CTRL_TAMPER (FLOW_CTRL_DAP ^ FLOW_STEP_TAMPER)
135	#define FLOW_CTRL_RUNTIME_PR­OTECT FLOW_CTRL_TAMPER
136
137	/**
138	  * @brief  SFU_BOOT Flow Control : Control values crypto operations
139	  */
140	#define FLOW_CTRL_AUTHENTICA­TE (FLOW_CTRL_INIT_VALUE­ ^ FLOW_STEP_AUTHENTICA­TE)
141	#define FLOW_CTRL_INTEGRITY (FLOW_CTRL_AUTHENTICA­TE ^ FLOW_STEP_INTEGRITY)
142	#define FLOW_CTRL_LOCK_SERVI­CE (FLOW_CTRL_INTEGRITY ^ FLOW_STEP_LOCK_SERVI­CE)
143
144	/* External variables --------------------------------------------------------*/
145	/**
146	  *  Flow control initial values.
147	  *   - Security protections flow (static + dynamic)
148	  *   - Crypto operations flow (authentication, integrity)
149	  */
150	extern uint32_t uFlowProtectValue;
151	extern uint32_t uFlowCryptoValue;
152
153	/* Exported macros -----------------------------------------------------------*/
154	/** Control with STEP operation :
155	  * (uFlowValue XOR STEP_VALUE) should be equal to CTRL_VALUE ==> execution stopped if failed !
156	  */
157	#define FLOW_CONTROL_STEP(C,B,A) \
158	  do{ \
159	    (C) ^= (B);\
160	    if ((C) != (A))\
161	    { \
162	      SFU_EXCPT_Security_E­rror();\
163	    } \
164	  }while(0)
165
166	/** Control without STEP operation :
167	  * uFlowValue should be equal to CTRL_VALUE ==> execution stopped if failed !
168	  */
169	#define FLOW_CONTROL_CHECK(B,A) \
170	  do{ \
171	    if ((B) != (A))\
172	    { \
173	      SFU_EXCPT_Security_E­rror();\
174	    } \
175	  }while(0)
176
177	/** Control flow initialization
178	  */
179	#define FLOW_CONTROL_INIT(B,A) \
180	  do{ \
181	    (B) = (A);\
182	  }while(0)
183
184	/** STEP update only :
185	  * (uFlowValue XOR STEP_VALUE)
186	  */
187	#define FLOW_STEP(B,A) \
188	  do{ \
189	    (B) ^= (A);\
190	  }while(0)
191
192
193	/* Exported functions ------------------------------------------------------- */
194	SFU_BOOT_InitErrorTy­peDef SFU_BOOT_RunSecureBo­otService(void);
195	void SFU_BOOT_ForceReboot­(void);
196
197	#ifdef __cplusplus
198	}
199	#endif
200
201	#endif /* SFU_BOOT_H */
202
L476_SBSFU\BFU\Application\BFU\App\sfu_com_loader.c
1	/**
2	  ******************************************************************************
3	  * @file    sfu_com_loader.c
4	  * @author  MCD Application Team
5	  * @brief   Secure Firmware Update COM module.
6	  *          This file provides set of firmware functions to manage SFU Com
7	  *          functionalities for the local loader.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Includes ------------------------------------------------------------------*/
22	#include "main.h"
23	#include "sfu_low_level.h"
24	#include "sfu_low_level_securi­ty.h"
25	#include "sfu_com_loader.h"
26	#include "sfu_trace.h"
27
28
29
30	#if (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || defined(SFU_TEST_PROTECTION)
31
32	/* Private defines -----------------------------------------------------------*/
33	#define SFU_COM_LOADER_TIME_­OUT            ((uint32_t )0x800U)   /*!< COM Transmit and Receive Timeout*/
34	#define SFU_COM_LOADER_SERIA­L_TIME_OUT       ((uint32_t )100U)   /*!< Serial PutByte and PutString Timeout*/
35
36	/* Private macros ------------------------------------------------------------*/
37	#define IS_CAP_LETTER(c)    (((c) >= (uint8_t) 'A') && ((c) <= (uint8_t) 'F'))
38	#define IS_LC_LETTER(c)     (((c) >= (uint8_t) 'a') && ((c) <= (uint8_t) 'f'))
39	#define IS_09(c)            (((c) >= (uint8_t) '0') && ((c) <= (uint8_t) '9'))
40	#define ISVALIDHEX(c)       (IS_CAP_LETTER(c) || IS_LC_LETTER(c) || IS_09(c))
41	#define ISVALIDDEC(c)       IS_09(c)
42	#define CONVERTDEC(c)       ((c) - (uint8_t) '0')
43
44	#define CONVERTHEX_ALPHA(c) (IS_CAP_LETTER(c) ? ((c) - (uint8_t) 'A' + 10U) : ((c) - (uint8_t) 'a' + 10U))
45	#define CONVERTHEX(c)       (IS_09(c) ? ((c) - (uint8_t) '0') : CONVERTHEX_ALPHA(c))
46
47	/* Private function prototypes -----------------------------------------------*/
48	static HAL_StatusTypeDef ReceivePacket(uint8_t *pData, uint32_t *puLength, uint32_t uTimeOut);
49	static uint32_t Str2Int(uint8_t *pInputStr, uint32_t *pIntNum);
50
51	/* Functions Definition ------------------------------------------------------*/
52
53	#if !defined(SFU_DEBUG_MODE) && !defined(SFU_TEST_PROTECTION)
54	/**
55	  * @brief  SFU Com Init function.
56	  * @param  None.
57	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
58	  */
59	SFU_ErrorStatus SFU_COM_Init(void)
60	{
61	#if defined(__GNUC__)
62	  setvbuf(stdout, NULL, _IONBF, 0);
63	#endif /* __GNUC__ */
64	  return SFU_LL_UART_Init();
65	}
66
67	/**
68	  * @brief  SFU Com DeInit function.
69	  * @param  None.
70	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
71	  */
72	SFU_ErrorStatus SFU_COM_DeInit(void)
73	{
74	  return SFU_LL_UART_DeInit();
75	}
76
77	#endif /* !SFU_DEBUG_MODE && !SFU_TEST_PROTECTION */
78
79	/**
80	  * @brief  Receive a file using the ymodem protocol with SFU_COM_YMODEM_CRC16­.
81	  * @param  peCOMStatus: SFU_COM_YMODEM_Statu­sTypeDef result of reception/programming.
82	  * @param  puSize: size of received file.
83	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise
84	  */
85	SFU_ErrorStatus SFU_COM_YMODEM_Recei­ve(SFU_COM_YMODEM_Statu­sTypeDef *peCOMStatus, uint32_t *puSize)
86	{
87	  uint32_t i;
88	  uint32_t packet_length = 0U;
89	  uint32_t session_done = 0U;
90	  uint32_t file_done;
91	  uint32_t errors = 0U;
92	  uint32_t session_begin = 0U;
93	  uint32_t filesize = 0U;
94	  uint32_t packets_received;
95	  uint8_t *file_ptr;
96	  uint8_t file_size[SFU_COM_YMODEM_FILE_­SIZE_LENGTH + 1U];
97	  uint8_t tmp;
98	  static uint8_t m_aPacketData[SFU_COM_YMODEM_PACKE­T_1K_SIZE + SFU_COM_YMODEM_PACKE­T_DATA_INDEX +
99	                               SFU_COM_YMODEM_PACKE­T_TRAILER_SIZE] __attribute__((aligned(8)));
100
101	  /* Check the pointers allocation */
102	  if ((peCOMStatus == NULL) || (puSize == NULL))
103	  {
104	    return SFU_ERROR;
105	  }
106
107	  *peCOMStatus = SFU_COM_YMODEM_OK;
108
109	  while ((session_done == 0U) && (*peCOMStatus == SFU_COM_YMODEM_OK))
110	  {
111	    packets_received = 0U;
112	    file_done = 0U;
113	    while ((file_done == 0U) && (*peCOMStatus == SFU_COM_YMODEM_OK))
114	    {
115	      switch (ReceivePacket(m_aPacketData, &packet_length, SFU_COM_YMODEM_DOWNL­OAD_TIMEOUT))
116	      {
117	        case HAL_OK:
118	          errors = 0U;
119	          switch (packet_length)
120	          {
121	            case 3U:
122	              /* Startup sequence */
123	              break;
124	            case 2U:
125	              /* Abort by sender */
126	              (void) SFU_COM_Serial_PutBy­te(SFU_COM_YMODEM_ACK);
127	              *peCOMStatus = SFU_COM_YMODEM_ABORT­;
128	              break;
129	            case 0U:
130	              /* End of transmission */
131	              (void) SFU_COM_Serial_PutBy­te(SFU_COM_YMODEM_ACK);
132	              *puSize = filesize;
133	              file_done = 1U;
134	              break;
135	            default:
136	              /* Normal packet */
137	              if (m_aPacketData[SFU_COM_YMODEM_PACKE­T_NUMBER_INDEX] != (packets_received & 0x000000FFU))
138	              {
139	                /* No NACK sent for a better synchro with remote : packet will be repeated */
140	              }
141	              else
142	              {
143	                if (packets_received == 0U)
144	                {
145	                  /* File name packet */
146	                  if (m_aPacketData[SFU_COM_YMODEM_PACKE­T_DATA_INDEX] != 0U)
147	                  {
148	                    /* File name skipped */
149	                    i = 0U;
150	                    file_ptr = m_aPacketData + SFU_COM_YMODEM_PACKE­T_DATA_INDEX;
151	                    while ((*file_ptr != 0U) && (i < SFU_COM_YMODEM_FILE_­NAME_LENGTH))
152	                    {
153	                      i++;
154	                      file_ptr++;
155	                    }
156	                    /* end of file name ('\0') skipped */
157	                    file_ptr++;
158
159	                    /* File size extraction */
160	                    i = 0U;
161	                    while ((*file_ptr != (uint8_t) ' ') && (i < SFU_COM_YMODEM_FILE_­SIZE_LENGTH))
162	                    {
163	                      file_size[i] = *file_ptr;
164	                      i++;
165	                      file_ptr++;
166	                    }
167	                    file_size[i] = (uint8_t) '\0';
168	                    (void) Str2Int(file_size, &filesize);
169
170	                    /* Header packet received callback call*/
171	                    if (SFU_COM_YMODEM_Heade­rPktRxCpltCallback((uint32_t) filesize) == SFU_SUCCESS)
172	                    {
173	                      (void) SFU_COM_Serial_PutBy­te(SFU_COM_YMODEM_ACK);
174	                      (void) SFU_LL_UART_Flush();
175	                      (void) SFU_COM_Serial_PutBy­te(SFU_COM_YMODEM_CRC16­);
176	                    }
177	                    else
178	                    {
179	                      /* End session */
180	                      tmp = SFU_COM_YMODEM_CA;
181	                      (void) SFU_LL_UART_Transmit­(&tmp, 1U, SFU_COM_YMODEM_NAK_T­IMEOUT);
182	                      (void) SFU_LL_UART_Transmit­(&tmp, 1U, SFU_COM_YMODEM_NAK_T­IMEOUT);
183	                      return SFU_ERROR;
184	                    }
185	                  }
186	                  /* File header packet is empty, end session */
187	                  else
188	                  {
189	                    (void) SFU_COM_Serial_PutBy­te(SFU_COM_YMODEM_ACK);
190	                    file_done = 1U;
191	                    session_done = 1U;
192	                    break;
193	                  }
194	                }
195	                else /* Data packet */
196	                {
197	                  /* Data packet received callback call*/
198	                  if (SFU_COM_YMODEM_DataP­ktRxCpltCallback(&m_aPacketData[SFU_COM_YMODEM_PACKE­T_DATA_INDEX],
199	                                                           packet_length) == SFU_SUCCESS)
200	                  {
201	                    (void) SFU_COM_Serial_PutBy­te(SFU_COM_YMODEM_ACK);
202
203	                  }
204	                  else /* An error occurred while writing to Flash memory */
205	                  {
206	                    /* End session */
207	                    (void) SFU_COM_Serial_PutBy­te(SFU_COM_YMODEM_CA);
208	                    (void) SFU_COM_Serial_PutBy­te(SFU_COM_YMODEM_CA);
209	                    *peCOMStatus = SFU_COM_YMODEM_DATA;
210	                  }
211
212	                }
213	                packets_received ++;
214	                session_begin = 1;
215	              }
216	              break;
217	          }
218	          break;
219	        case HAL_BUSY: /* Abort actually */
220	          (void) SFU_COM_Serial_PutBy­te(SFU_COM_YMODEM_CA);
221	          (void) SFU_COM_Serial_PutBy­te(SFU_COM_YMODEM_CA);
222	          *peCOMStatus = SFU_COM_YMODEM_ABORT­;
223	          break;
224	        default:
225	          if (session_begin > 0U)
226	          {
227	            errors ++;
228	          }
229	          if (errors > SFU_COM_YMODEM_MAX_E­RRORS)
230	          {
231	            /* Abort communication */
232	            (void) SFU_COM_Serial_PutBy­te(SFU_COM_YMODEM_CA);
233	            (void) SFU_COM_Serial_PutBy­te(SFU_COM_YMODEM_CA);
234	            *peCOMStatus = SFU_COM_YMODEM_ABORT­;
235	          }
236	          else
237	          {
238	            (void) SFU_COM_Serial_PutBy­te(SFU_COM_YMODEM_CRC16­); /* Ask for a packet */
239	#ifndef MINICOM_YMODEM
240	            /* Minicom does not accept this extra character */
241	            TRACE("\b.");                                 /* Replace C char by . on display console */
242	#endif /* MINICOM_YMODEM */
243	            /*
244	             * Toggling the LED in case no console is available: the toggling frequency depends on
245	             * SFU_COM_YMODEM_DOWNL­OAD_TIMEOUT
246	             */
247	            (void) BSP_LED_Toggle(SFU_STATUS_LED);
248	          }
249	          break;
250	      }
251	    }
252	  }
253	  /* Make sure the status LED is turned off */
254	  (void) BSP_LED_Off(SFU_STATUS_LED);
255
256	  if (*peCOMStatus == SFU_COM_YMODEM_OK)
257	  {
258	    return SFU_SUCCESS;
259	  }
260	  else
261	  {
262	    return SFU_ERROR;
263	  }
264	}
265
266	/**
267	  * @brief  Transmit a byte to the COM Port.
268	  * @param  uParam: The byte to be sent.
269	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
270	  */
271	SFU_ErrorStatus SFU_COM_Serial_PutBy­te(uint8_t uParam)
272	{
273	  return SFU_LL_UART_Transmit­(&uParam, 1U, SFU_COM_LOADER_SERIA­L_TIME_OUT);
274	}
275
276	/**
277	  * @brief  Convert a string to an integer.
278	  * @param  pInputStr: The string to be converted.
279	  * @param  pIntNum: The integer value.
280	  * @retval 1: Correct
281	  *         0: Error
282	  */
283	static uint32_t Str2Int(uint8_t *pInputStr, uint32_t *pIntNum)
284	{
285	  uint32_t i = 0U;
286	  uint32_t res = 0U;
287	  uint32_t val = 0U;
288	  uint8_t  digit;
289
290	  if ((pInputStr[0] == (uint8_t)'0') && ((pInputStr[1] == (uint8_t)'x') || (pInputStr[1] == (uint8_t)'X')))
291	  {
292	    i = 2U;
293	    while ((i < 11U) && (pInputStr[i] != (uint8_t)'\0'))
294	    {
295	      if (ISVALIDHEX(pInputStr[i]))
296	      {
297	        digit = CONVERTHEX(pInputStr[i]);
298	        val = (val << 4U) + digit;
299	      }
300	      else
301	      {
302	        /* Return 0, Invalid input */
303	        res = 0U;
304	        break;
305	      }
306	      i++;
307	    }
308
309	    /* valid result */
310	    if (pInputStr[i] == (uint8_t)'\0')
311	    {
312	      *pIntNum = val;
313	      res = 1U;
314	    }
315	  }
316	  else /* max 10-digit decimal input */
317	  {
318	    while ((i < 11U) && (res != 1U))
319	    {
320	      if (pInputStr[i] == (uint8_t)'\0')
321	      {
322	        *pIntNum = val;
323	        /* return 1 */
324	        res = 1U;
325	      }
326	      else if (((pInputStr[i] == (uint8_t)'k') || (pInputStr[i] == (uint8_t)'K')) && (i > 0U))
327	      {
328	        val = val << 10U;
329	        *pIntNum = val;
330	        res = 1U;
331	      }
332	      else if (((pInputStr[i] == (uint8_t)'m') || (pInputStr[i] == (uint8_t)'M')) && (i > 0U))
333	      {
334	        val = val << 20U;
335	        *pIntNum = val;
336	        res = 1U;
337	      }
338	      else if (ISVALIDDEC(pInputStr[i]))
339	      {
340	        digit =  CONVERTDEC(pInputStr[i]);
341	        val = (val * 10U) + digit;
342	      }
343	      else
344	      {
345	        /* return 0, Invalid input */
346	        res = 0U;
347	        break;
348	      }
349	      i++;
350	    }
351	  }
352
353	  return res;
354	}
355
356	/**
357	  * @brief  Receive a packet from sender
358	  * @param  pData: pointer to received data.
359	  * @param  puLength
360	  *     0: end of transmission
361	  *     2: abort by sender
362	  *    >0: packet length
363	  * @param  uTimeOut: receive timeout (ms).
364	  * @retval HAL_OK: normally return
365	  *         HAL_BUSY: abort by user
366	  */
367	static HAL_StatusTypeDef ReceivePacket(uint8_t *pData, uint32_t *puLength, uint32_t uTimeout)
368	{
369	  uint32_t crc;
370	  uint32_t packet_size = 0U;
371	  HAL_StatusTypeDef status;
372	  SFU_ErrorStatus eRetStatus;
373
374	  uint8_t char1;
375
376	#ifdef MINICOM_YMODEM
377	  uint32_t myIdx = 0; /* index indicating where to write in pData */
378	#endif /* MINICOM_YMODEM */
379
380	  *puLength = 0U;
381
382	  /* This operation could last long. Need to refresh the Watchdog if enabled. It could be implemented as a callback*/
383	  (void) SFU_LL_SECU_IWDG_Ref­resh();
384
385	  eRetStatus = SFU_LL_UART_Receive(&char1, 1, uTimeout);
386
387	  if (eRetStatus == SFU_SUCCESS)
388	  {
389	    status = HAL_OK;
390
391	    switch (char1)
392	    {
393	      case SFU_COM_YMODEM_SOH:
394	        packet_size = SFU_COM_YMODEM_PACKE­T_SIZE;
395	        break;
396	      case SFU_COM_YMODEM_STX:
397	        packet_size = SFU_COM_YMODEM_PACKE­T_1K_SIZE;
398	        break;
399	      case SFU_COM_YMODEM_EOT:
400	        break;
401	      case SFU_COM_YMODEM_CA:
402	        if ((SFU_LL_UART_Receive(&char1, 1U, uTimeout) == SFU_SUCCESS) && (char1 == SFU_COM_YMODEM_CA))
403	        {
404	          packet_size = 2U;
405	        }
406	        else
407	        {
408	          status = HAL_ERROR;
409	        }
410	        break;
411	      case SFU_COM_YMODEM_ABORT­1:
412	      case SFU_COM_YMODEM_ABORT­2:
413	        status = HAL_BUSY;
414	        break;
415	      case SFU_COM_YMODEM_RB:
416	        (void) SFU_LL_UART_Receive(&char1, 1U, uTimeout);             /* Ymodem startup sequence : rb ==> 0x72 + 0x62 + 0x0D */
417	        (void) SFU_LL_UART_Receive(&char1, 1U, uTimeout);
418	        packet_size = 3U;
419	        break;
420	      default:
421	        status = HAL_ERROR;
422	        break;
423	    }
424	    *pData = char1;
425
426	    if (packet_size >= SFU_COM_YMODEM_PACKE­T_SIZE)
427	    {
428
429	#ifndef MINICOM_YMODEM
430	      eRetStatus = SFU_LL_UART_Receive(&pData[SFU_COM_YMODEM_PACKE­T_NUMBER_INDEX],
431	                                       (uint16_t)(packet_size + SFU_COM_YMODEM_PACKE­T_OVERHEAD_SIZE), uTimeout);
432	#else
433	      eRetStatus = SFU_SUCCESS;
434	      /* Receive byte per byte until no data left or no space left in buffer */
435	      while ((SFU_SUCCESS == eRetStatus) &&
436	             ((myIdx + SFU_COM_YMODEM_PACKE­T_NUMBER_INDEX) < SFU_COM_YMODEM_PACKE­T_1K_SIZE +
437	              SFU_COM_YMODEM_PACKE­T_DATA_INDEX +
438	              SFU_COM_YMODEM_PACKE­T_TRAILER_SIZE)
439	            )
440	      {
441	        eRetStatus = SFU_LL_UART_Receive(&pData[SFU_COM_YMODEM_PACKE­T_NUMBER_INDEX + myIdx],
442	                                         1U, uTimeout);
443	        myIdx++;
444	      }
445
446	      if (myIdx > 1)
447	      {
448	        /* We received some bytes */
449	        eRetStatus = SFU_SUCCESS;
450	      }
451	#endif /* MINICOM_YMODEM */
452
453	      /* Simple packet sanity check */
454	      if (eRetStatus == SFU_SUCCESS)
455	      {
456	        status = HAL_OK;
457
458	        if (pData[SFU_COM_YMODEM_PACKE­T_NUMBER_INDEX] != ((pData[SFU_COM_YMODEM_PACKE­T_CNUMBER_INDEX]) ^
459	                                                          SFU_COM_YMODEM_NEGAT­IVE_BYTE))
460	        {
461	          packet_size = 0U;
462	          status = HAL_ERROR;
463	        }
464	        else
465	        {
466	          /* Check packet CRC*/
467	          crc = (((uint32_t)pData[ packet_size + SFU_COM_YMODEM_PACKE­T_DATA_INDEX ]) << 8U) & 0x0000FF00U;
468	          crc += pData[ packet_size + SFU_COM_YMODEM_PACKE­T_DATA_INDEX + 1U ];
469
470	          /*Configure CRC with 16-bit polynomial*/
471	          if (SFU_LL_CRC_Config(SFU_CRC_CONFIG_16BIT­) == SFU_SUCCESS)
472	          {
473	            if (SFU_LL_CRC_Calculate­((uint32_t *)(uint32_t)&pData[SFU_COM_YMODEM_PACKE­T_DATA_INDEX], packet_size) != crc)
474	            {
475	              packet_size = 0U;
476	              status = HAL_ERROR;
477	            }
478
479	          }
480	          else
481	          {
482	            packet_size = 0U;
483	            status = HAL_ERROR;
484	          }
485	        }
486	      }
487	      else
488	      {
489	        status = HAL_ERROR;
490	      }
491	    }
492	  }
493	  else
494	  {
495	    status = HAL_ERROR;
496	  }
497
498	  *puLength = packet_size;
499	  return status;
500	}
501
502	/**
503	  * @brief  Ymodem Header Packet Transfer completed callback.
504	  * @param  uFileSize: Dimension of the file that will be received.
505	  * @retval None
506	  */
507	__weak SFU_ErrorStatus SFU_COM_YMODEM_Heade­rPktRxCpltCallback(uint32_t uFileSize)
508	{
509
510	  /* NOTE : This function should not be modified, when the callback is needed,
511	            the SFU_COM_YMODEM_Heade­rPktRxCpltCallback could be implemented in the user file
512	   */
513	  UNUSED(uFileSize);
514	  return SFU_SUCCESS;
515	}
516
517	/**
518	  * @brief  Ymodem Data Packet Transfer completed callback.
519	  * @param  pData: Pointer to the buffer.
520	  * @param  uSize: Packet dimension.
521	  * @retval None
522	  */
523	__weak SFU_ErrorStatus SFU_COM_YMODEM_DataP­ktRxCpltCallback(uint8_t *pData, uint32_t uSize)
524	{
525
526	  /* NOTE : This function should not be modified, when the callback is needed,
527	            the SFU_COM_YMODEM_DataP­ktRxCpltCallback could be implemented in the user file
528	   */
529	  UNUSED(pData);
530	  UNUSED(uSize);
531	  return SFU_SUCCESS;
532	}
533
534	#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || defined(SFU_TEST_PROTECTION) */
535
L476_SBSFU\BFU\Application\BFU\App\sfu_com_loader.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_com_loader.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for Secure Firmware Update COM module
6	  *          functionalities for the local loader.
7	  ******************************************************************************
8	  * @attention
9	  *
10	  * Copyright (c) 2017 STMicroelectronics.
11	  * All rights reserved.
12	  *
13	  * This software is licensed under terms that can be found in the LICENSE file in
14	  * the root directory of this software component.
15	  * If no LICENSE file comes with this software, it is provided AS-IS.
16	  *
17	  ******************************************************************************
18	  */
19
20	/* Define to prevent recursive inclusion -------------------------------------*/
21	#ifndef SFU_COM_LOADER_H
22	#define SFU_COM_LOADER_H
23
24	#ifdef __cplusplus
25	extern "C" {
26	#endif
27
28	/* Includes ------------------------------------------------------------------*/
29	#include "main.h"
30	#include <stdint.h>
31	#include <stdio.h>
32
33	/* Exported types ------------------------------------------------------------*/
34	/**
35	  * @brief  SFU_COM_LOADER_YMODE­M Status structure definition
36	  */
37	typedef enum
38	{
39	  SFU_COM_YMODEM_OK       = 0x00U,  /*!< OK */
40	  SFU_COM_YMODEM_ERROR­    = 0x01U,  /*!< Error */
41	  SFU_COM_YMODEM_ABORT­    = 0x02U,  /*!< Abort */
42	  SFU_COM_YMODEM_TIMEO­UT  = 0x03U,  /*!< Timeout */
43	  SFU_COM_YMODEM_DATA     = 0x04U,  /*!< Data */
44	  SFU_COM_YMODEM_LIMIT­    = 0x05U   /*!< Limit*/
45	} SFU_COM_YMODEM_Statu­sTypeDef;
46
47	/* Exported constants --------------------------------------------------------*/
48	#ifndef MINICOM_YMODEM
49	/* Teraterm YMODEM */
50	#define SFU_COM_YMODEM_PACKE­T_HEADER_SIZE      ((uint32_t)3U)    /*!<Header Size*/
51	#define SFU_COM_YMODEM_PACKE­T_DATA_INDEX       ((uint32_t)4U)    /*!<Data Index*/
52	#define SFU_COM_YMODEM_PACKE­T_START_INDEX      ((uint32_t)1U)    /*!<Start Index*/
53	#define SFU_COM_YMODEM_PACKE­T_NUMBER_INDEX     ((uint32_t)2U)    /*!<Packet Number Index*/
54	#define SFU_COM_YMODEM_PACKE­T_CNUMBER_INDEX    ((uint32_t)3U)    /*!<Cnumber Index*/
55	#else
56	/* Minicom YMODEM */
57	#define SFU_COM_YMODEM_PACKE­T_HEADER_SIZE      ((uint32_t)6U)    /*!<Header Size*/
58	#define SFU_COM_YMODEM_PACKE­T_DATA_INDEX       ((uint32_t)7U)    /*!<Data Index*/
59	#define SFU_COM_YMODEM_PACKE­T_START_INDEX      ((uint32_t)4U)    /*!<Start Index*/
60	#define SFU_COM_YMODEM_PACKE­T_NUMBER_INDEX     ((uint32_t)5U)    /*!<Packet Number Index*/
61	#define SFU_COM_YMODEM_PACKE­T_CNUMBER_INDEX    ((uint32_t)6U)    /*!<Cnumber Index*/
62	#endif /* MINICOM_YMODEM */
63	#define SFU_COM_YMODEM_PACKE­T_TRAILER_SIZE     ((uint32_t)2U)    /*!<Trailer Size*/
64	#define SFU_COM_YMODEM_PACKE­T_OVERHEAD_SIZE    (SFU_COM_YMODEM_PACKE­T_HEADER_SIZE + SFU_COM_YMODEM_PACKE­T_TRAILER_SIZE \
65	                                                - 1U)           /*!<Overhead Size*/
66	#define SFU_COM_YMODEM_PACKE­T_SIZE             ((uint32_t)128U)  /*!<Packet Size*/
67	#define SFU_COM_YMODEM_PACKE­T_1K_SIZE          ((uint32_t)1024U) /*!<Packet 1K Size*/
68
69	#define SFU_COM_YMODEM_FILE_­NAME_LENGTH        ((uint32_t)64U)   /*!< File name length*/
70	#define SFU_COM_YMODEM_FILE_­SIZE_LENGTH        ((uint32_t)16U)   /*!< File size length*/
71
72	#define SFU_COM_YMODEM_SOH                     ((uint8_t)0x01U)  /*!< Start of 128-byte data packet */
73	#define SFU_COM_YMODEM_STX                     ((uint8_t)0x02U)  /*!< Start of 1024-byte data packet */
74	#define SFU_COM_YMODEM_EOT                     ((uint8_t)0x04U)  /*!< End of transmission */
75	#define SFU_COM_YMODEM_ACK                     ((uint8_t)0x06U)  /*!< Acknowledge */
76	#define SFU_COM_YMODEM_NAK                     ((uint8_t)0x15U)  /*!< Negative acknowledge */
77	#define SFU_COM_YMODEM_CA                      ((uint8_t)0x18U)  /*!< Two of these in succession aborts transfer */
78	#define SFU_COM_YMODEM_CRC16­                   ((uint8_t)0x43U)  /*!< 'C' == 0x43, request 16-bit CRC */
79	#define SFU_COM_YMODEM_RB                      ((uint8_t)0x72U)  /*!< Startup sequence */
80	#define SFU_COM_YMODEM_NEGAT­IVE_BYTE           ((uint8_t)0xFFU)  /*!< Negative Byte*/
81
82	#define SFU_COM_YMODEM_ABORT­1                  ((uint8_t)0x41U)  /*!< 'A' == 0x41, abort by user */
83	#define SFU_COM_YMODEM_ABORT­2                  ((uint8_t)0x61U)  /*!< 'a' == 0x61, abort by user */
84
85	#define SFU_COM_YMODEM_NAK_T­IMEOUT             ((uint32_t)0x100000U)  /*!< NAK Timeout*/
86	#ifndef MINICOM_YMODEM
87	/* Teraterm YMODEM */
88	#define SFU_COM_YMODEM_DOWNL­OAD_TIMEOUT        ((uint32_t)3000U) /*!< Retry delay, has to be smaller than IWDG */
89	#else
90	/* Minicom YMODEM : reduce the download timeout to speed-up the download operation */
91	#define SFU_COM_YMODEM_DOWNL­OAD_TIMEOUT        ((uint32_t)1000U) /*!< Retry delay, has to be smaller than IWDG */
92	#endif /* MINICOM_YMODEM */
93	#define SFU_COM_YMODEM_MAX_E­RRORS              ((uint32_t)3U)    /*!< Maximum number of retry*/
94
95	/* Exported functions ------------------------------------------------------- */
96	/*
97	 * If the debug mode is not enabled then the local loader must also provide the COM init functions
98	 */
99	#if !defined(SFU_DEBUG_MODE) && !defined(SFU_TEST_PROTECTION)
100	SFU_ErrorStatus SFU_COM_Init(void);
101	SFU_ErrorStatus SFU_COM_DeInit(void);
102	#endif /* !SFU_DEBUG_MODE && !SFU_TEST_PROTECTION */
103
104	SFU_ErrorStatus SFU_COM_Transmit(uint8_t *pData, uint16_t uDataLength, uint32_t uTimeOut);
105	SFU_ErrorStatus SFU_COM_Receive(uint8_t *pData, uint16_t uDataLength);
106	SFU_ErrorStatus SFU_COM_Flush(void);
107	SFU_ErrorStatus SFU_COM_YMODEM_Recei­ve(SFU_COM_YMODEM_Statu­sTypeDef *peCOMStatus, uint32_t *puSize);
108	SFU_ErrorStatus SFU_COM_Serial_PutBy­te(uint8_t uParam);
109
110	SFU_ErrorStatus SFU_COM_YMODEM_Heade­rPktRxCpltCallback(uint32_t uFileSize);
111	SFU_ErrorStatus SFU_COM_YMODEM_DataP­ktRxCpltCallback(uint8_t *pData, uint32_t uSize);
112
113	#ifdef __cplusplus
114	}
115	#endif
116
117	#endif /* SFU_COM_LOADER_H */
118
L476_SBSFU\BFU\Application\BFU\App\sfu_com_trace.c
1	/**
2	  ******************************************************************************
3	  * @file    sfu_com_trace.c
4	  * @author  MCD Application Team
5	  * @brief   Secure Firmware Update COM module.
6	  *          This file provides set of firmware functions to manage SFU Com
7	  *          functionalities for the trace.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Includes ------------------------------------------------------------------*/
22	#include "main.h"
23	#include "sfu_low_level.h"
24	#include "sfu_trace.h"
25	#include "sfu_com_trace.h"
26	#if defined(__ICCARM__)
27	#include <LowLevelIOInterface.h>
28	#endif /* __ICCARM__ */
29
30	#if defined(SFU_DEBUG_MODE) || defined(SFU_TEST_PROTECTION)
31
32	/* Private defines -----------------------------------------------------------*/
33	#if defined(__ICCARM__)
34	/* New definition from EWARM V9, compatible with EWARM8 */
35	int iar_fputc(int ch);
36	#define PUTCHAR_PROTOTYPE int iar_fputc(int ch)
37	#elif defined(__CC_ARM) || defined(__ARMCC_VERSION)
38	#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
39	#elif defined(__GNUC__)
40	#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
41	#endif /* __ICCARM__ */
42
43	#define SFU_COM_TRACE_SERIAL­_TIME_OUT       ((uint32_t )100U)   /*!< Serial PutString Timeout*/
44
45	/* Functions Definition ------------------------------------------------------*/
46	/**
47	  * @brief  SFU Com Init function.
48	  * @param  None.
49	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
50	  */
51	SFU_ErrorStatus SFU_COM_Init(void)
52	{
53	#if defined(__GNUC__)
54	  setvbuf(stdout, NULL, _IONBF, 0);
55	#endif /* __GNUC__ */
56	  return SFU_LL_UART_Init();
57	}
58
59	/**
60	  * @brief  SFU Com DeInit function.
61	  * @param  None.
62	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
63	  */
64	SFU_ErrorStatus SFU_COM_DeInit(void)
65	{
66	  return SFU_LL_UART_DeInit();
67	}
68	/**
69	  * @}
70	  */
71
72	/** @defgroup SFU_COM_TRACE_Contro­l_Functions Control Functions
73	  * @{
74	  */
75
76	/**
77	  * @brief  Print a string on the COM Port.
78	  * @param  pString: The string to be printed
79	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
80	  */
81	SFU_ErrorStatus SFU_COM_Serial_PutSt­ring(uint8_t *pString)
82	{
83	  uint16_t length = 0U;
84
85	  /* Check the pointers allocation */
86	  if (pString == NULL)
87	  {
88	    return SFU_ERROR;
89	  }
90
91	  while (pString[length] != (uint8_t)'\0')
92	  {
93	    length++;
94	  }
95
96	  return SFU_LL_UART_Transmit­(pString, length, SFU_COM_TRACE_SERIAL­_TIME_OUT);
97
98	}
99
100	/**
101	  * @brief  Retargets the C library __write function to the IAR function iar_fputc.
102	  * @param  file: file descriptor.
103	  * @param  ptr: pointer to the buffer where the data is stored.
104	  * @param  len: length of the data to write in bytes.
105	  * @retval length of the written data in bytes.
106	  */
107	#if defined(__ICCARM__)
108	size_t __write(int file, unsigned char const *ptr, size_t len)
109	{
110	  size_t idx;
111	  unsigned char const *pdata = ptr;
112
113	  for (idx = 0; idx < len; idx++)
114	  {
115	    iar_fputc((int)*pdata);
116	    pdata++;
117	  }
118	  return len;
119	}
120	#endif /* __ICCARM__ */
121
122	/**
123	  * @brief  Retargets the C library printf function to SFU UART.
124	  * @param  None
125	  * @retval ch
126	  */
127	PUTCHAR_PROTOTYPE
128	{
129	  /* Place your implementation of fputc here */
130	  /* e.g. write a character to the USART1 and Loop until the end of transmission */
131	  (void) SFU_LL_UART_Transmit­((uint8_t *)&ch, 1U, 0xFFFFU);
132
133	  return ch;
134	}
135
136	#endif /* SFU_DEBUG_MODE || SFU_TEST_PROTECTION */
137
L476_SBSFU\BFU\Application\BFU\App\sfu_com_trace.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_com_trace.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for Secure Firmware Update COM module
6	  *          functionalities  for the trace.
7	  ******************************************************************************
8	  * @attention
9	  *
10	  * Copyright (c) 2017 STMicroelectronics.
11	  * All rights reserved.
12	  *
13	  * This software is licensed under terms that can be found in the LICENSE file in
14	  * the root directory of this software component.
15	  * If no LICENSE file comes with this software, it is provided AS-IS.
16	  *
17	  ******************************************************************************
18	  */
19
20	/* Define to prevent recursive inclusion -------------------------------------*/
21	#ifndef SFU_COM_TRACE_H
22	#define SFU_COM_TRACE_H
23
24	#ifdef __cplusplus
25	extern "C" {
26	#endif
27
28	/* Includes ------------------------------------------------------------------*/
29	#include "main.h"
30	#include "sfu_def.h"
31	#include <stdio.h>
32
33	/* Exported functions ------------------------------------------------------- */
34	SFU_ErrorStatus SFU_COM_Init(void);
35	SFU_ErrorStatus SFU_COM_DeInit(void);
36	SFU_ErrorStatus SFU_COM_Serial_PutSt­ring(uint8_t *pString);
37
38
39	/**
40	  * @}
41	  */
42
43	/**
44	  * @}
45	  */
46
47	/**
48	  * @}
49	  */
50
51	/**
52	  * @}
53	  */
54
55	/**
56	  * @}
57	  */
58
59	#ifdef __cplusplus
60	}
61	#endif
62
63	#endif /* SFU_COM_TRACE_H */
64
L476_SBSFU\BFU\Application\BFU\App\sfu_def.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_def.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains the general definitions for SBSFU application.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef SFU_DEF_H
21	#define SFU_DEF_H
22
23	#ifdef __cplusplus
24	extern "C" {
25	#endif
26
27	/* Includes ------------------------------------------------------------------*/
28	#if defined(__CC_ARM) || defined (__ARMCC_VERSION)
29	#include "mapping_sbsfu.h"
30	#elif defined (__ICCARM__) || defined(__GNUC__)
31	#include "mapping_export.h"
32	#endif /* __ICCARM__ || __GNUC__ */
33	#include "app_sfu.h"
34
35	/* Exported types ------------------------------------------------------------*/
36	/**
37	  * @brief  SFU Error Typedef
38	  */
39	typedef enum
40	{
41	  SFU_ERROR = 0x00001FE1U,
42	  SFU_SUCCESS = 0x00122F11U
43	} SFU_ErrorStatus;
44
45	/* Exported constants --------------------------------------------------------*/
46	#if defined(__CC_ARM) || defined (__ARMCC_VERSION)
47	extern uint32_t Image$$vector_start$$Base;
48	#define  INTVECT_START ((uint32_t)& Image$$vector_start$$Base)
49	#endif /* __CC_ARM */
50
51	#define SFU_RAM_BASE             ((uint32_t) SE_REGION_RAM_START)
52	#define SFU_RAM_END              ((uint32_t) SB_REGION_RAM_END)
53	#define SFU_SB_RAM_BASE          ((uint32_t) SB_REGION_RAM_START)
54	#define SFU_SB_RAM_END           ((uint32_t) SB_REGION_RAM_END)
55
56	/* needed for sfu_test.c */
57	#define SFU_SRAM2_BASE           ((uint32_t)0x10000000)
58	#define SFU_SRAM2_END            ((uint32_t)0x10007FFF)
59
60	#define SFU_BOOT_BASE_ADDR       ((uint32_t) INTVECT_START)           /* SFU Boot Address */
61	#define SFU_ROM_ADDR_END         ((uint32_t) SB_REGION_ROM_END)       /* SBSFU end Address (covering all the SBSFU
62	                                                                         executable code) */
63
64	#define SFU_SENG_ROM_ADDR_ST­ART  ((uint32_t) SE_CODE_REGION_ROM_S­TART)/* Secure Engine area address START */
65	#define SFU_SENG_ROM_ADDR_EN­D    ((uint32_t) SE_CODE_REGION_ROM_E­ND)  /* Secure Engine area address END - SE includes
66	                                                                         everything up to the License */
67	#define SFU_SENG_ROM_SIZE        ((uint32_t) (SFU_SENG_ROM_ADDR_EN­D - \
68	                                              SFU_SENG_ROM_ADDR_ST­ART + 1U)) /* Secure Engine area size */
69
70	#define SFU_KEYS_ROM_ADDR_ST­ART  ((uint32_t) SE_KEY_REGION_ROM_ST­ART) /* Keys Area (Keys + Keys Retrieve function)
71	                                                                         START. This is the PCRoP Area */
72	#define SFU_KEYS_ROM_ADDR_EN­D    ((uint32_t) SE_KEY_REGION_ROM_EN­D)   /* Keys Area (Keys + Keys Retrieve function) END.
73	                                                                         This is the PCRoP Area */
74
75	#define SFU_SENG_RAM_ADDR_ST­ART  ((uint32_t) SE_REGION_RAM_START)   /* Secure Engine reserved RAM1 area START
76	                                                                         address */
77	#define SFU_SENG_RAM_ADDR_EN­D    ((uint32_t) SE_REGION_RAM_END)     /* Secure Engine reserved RAM1 area END address */
78	#define SFU_SENG_RAM_SIZE        ((uint32_t) (SFU_SENG_RAM_ADDR_EN­D - \
79	                                              SFU_SENG_RAM_ADDR_ST­ART + 1U)) /* Secure Engine reserved RAM area SIZE */
80
81	#ifdef __cplusplus
82	}
83	#endif
84
85	#endif /* SFU_DEF_H */
86
L476_SBSFU\BFU\Application\BFU\App\sfu_error.c
1	/**
2	  ******************************************************************************
3	  * @file    sfu_error.c
4	  * @author  MCD Application Team
5	  * @brief   SFU ERROR
6	  *          This file provides set of firmware functions for SB_SFU errors handling.
7	  ******************************************************************************
8	  * @attention
9	  *
10	  * Copyright (c) 2017 STMicroelectronics.
11	  * All rights reserved.
12	  *
13	  * This software is licensed under terms that can be found in the LICENSE file in
14	  * the root directory of this software component.
15	  * If no LICENSE file comes with this software, it is provided AS-IS.
16	  *
17	  ******************************************************************************
18	  */
19
20	/* Includes ------------------------------------------------------------------*/
21	#include "main.h"
22	#include "sfu_fsm_states.h"
23	#include "sfu_error.h"
24	#include "sfu_low_level_securi­ty.h"
25	#include "sfu_trace.h"
26	#include "se_interface_bootloa­der.h"
27	#include "sfu_fwimg_services.h"
28	#include "sfu_boot.h"
29	#include "sfu_test.h"
30
31
32	/* Private variables ---------------------------------------------------------*/
33	#ifdef SFU_DEBUG_MODE
34	/**
35	  *  The following strings associated to the exceptions/errors are used for debugging purpose.
36	  *  WARNING: The string array must match perfectly with the @ref SFU_EXCPT_IdTypeDef.
37	  *  And the @ref SFU_EXCPT_IdTypeDef enum must be a sequence starting from 0
38	  */
39	static char *m_aErrorStrings[] ={  "No error. Success",
40	                                   "Memory fault",
41	                                   "Hard fault",
42	                                   "Tampering fault",
43	                                   "SE lock cannot be set",
44	#if (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER)
45	                                   "Fw too big",
46	                                   "File not correctly received",
47	#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) */
48	                                   "Fw header authentication error",
49	                                   "Fw decryption error",
50	                                   "Fw signature check error",
51	                                   "Flash error",
52	                                   "External flash configuration error.",
53	                                   "Header erasing error",
54	                                   "Header validation error",
55	                                   "Additional code detected beyond FW",
56	                                   "Error during swap process",
57	                                   "Error during rollback process",
58	                                   "Backed-up fw not identified",
59	                                   "Backup copy error",
60	                                   "Dwl slot erasing error",
61	                                   "Trailer erasing error",
62	                                   "Trailer update error",
63	                                   "Magic tag update error",
64	                                   "Fw version rejected (anti-rollback)",
65	                                   "Unknown error"
66	                                };
67
68	#endif /* SFU_DEBUG_MODE */
69
70	/* Private function prototypes -----------------------------------------------*/
71	static void SFU_EXCPT_RuntimeExc­eptionHandler(SFU_EXCPT_IdTypeDef eExceptionId);
72
73	/* Functions Definition ------------------------------------------------------*/
74	/**
75	  * @brief  Print relevant errpr message.
76	  * @param  Error Error code.
77	  * @retval None
78	  */
79	void SFU_EXCPT_SetError(SFU_EXCPT_IdTypeDef eExceptionId)
80	{
81	  if (eExceptionId <= SFU_EXCPT_UNKNOWN)
82	  {
83	#ifdef SFU_DEBUG_MODE
84	    TRACE("\r\n\t%s",m_aErrorStrings[(uint32_t) eExceptionId]);
85	#endif /* SFU_DEBUG_MODE */
86	  }
87	}
88
89
90	/**
91	  * @brief  Manage the Exception generated by an IRQ
92	  * @param  eExceptionId : Exception ID.
93	  *         This parameter can be a value of @ref SFU_EXCPT_ID_Structu­re_definition.
94	  * @note   Because of the interruption of the State Machine execution,
95	  *         it's not possible to continue without compromising the stability or
96	  *         the security of the solution. A System Reset is forced at the end.
97	  * @retval None
98	  */
99	void SFU_EXCPT_IrqExcepti­onHandler(SFU_EXCPT_IdTypeDef eExceptionId)
100	{
101	#ifdef SFU_DEBUG_MODE
102	  uint8_t message[150];
103	  uint32_t i = 0U;
104
105	  /* Avoid warning with cast frombetween char* and uint8_t* */
106	  while ((m_aErrorStrings[(uint32_t) eExceptionId][i] != 0u) && (i < 149U))
107	  {
108	    message[i] = m_aErrorStrings[(uint32_t) eExceptionId][i];
109	    i++;
110	  }
111	  message[i] = 0U;
112
113	  /* Print relevant error message */
114	  TRACE_IRQ((uint8_t *)"\r\n\t  ");
115	  TRACE_IRQ(message);
116	#endif /* SFU_DEBUG_MODE */
117
118	  /* Try to take an action */
119	  SFU_EXCPT_RuntimeExc­eptionHandler(eExceptionId);
120
121	  /* It's not possible to continue without compromising the stability or the security of the solution.
122	  The State Machine needs to be aborted and a Reset must be triggered */
123	  SFU_BOOT_ForceReboot­();
124	}
125
126	/**
127	  * @brief  Stop in case of security error
128	  * @param  eExceptionId : Exception ID.
129	  *         This parameter can be a value of @ref SFU_EXCPT_ID_Structu­re_definition.
130	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
131	  */
132
133	void SFU_EXCPT_Security_E­rror(void)
134	{
135	  TRACE("\r\n= [SBOOT] Security issue : execution stopped !");
136	  HAL_Delay(1000);
137	  /* This is the last operation executed. Force a System Reset. */
138	  NVIC_SystemReset();
139	}
140
141	/**
142	  * @brief  SFU Exception Initialization.
143	  * @param  None.
144	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
145	  */
146	SFU_ErrorStatus SFU_EXCPT_Init(void)
147	{
148	  SFU_ErrorStatus e_ret_status;
149
150	  /* ADD SRC CODE HERE
151	       ...
152	  */
153	  e_ret_status = SFU_SUCCESS;
154
155	  return e_ret_status;
156	}
157
158	/**
159	  * @brief  SFU Exception DeInitialization.
160	  * @param  None.
161	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
162	  */
163	SFU_ErrorStatus SFU_EXCPT_DeInit(void)
164	{
165	  SFU_ErrorStatus e_ret_status;
166	  /* ADD SRC CODE HERE
167	      ...
168	  */
169	  e_ret_status = SFU_SUCCESS;
170
171	  return e_ret_status;
172	}
173
174	/**
175	  * @brief  Manage the Exception/Errors/Fault at runtime, when detected
176	  * @param  eExceptionId : Exception ID.
177	  *         This parameter can be a value of @ref SFU_EXCPT_ID_Structu­re_definition.
178	  * @note   A System Reset is forced at the end by the caller of this function.
179	  *         WARNING: Be aware that this function can be called by an IRQ while
180	  *         using the printf, since the printf is not a reentrant function, and using
181	  *         the printf inside this function as well, a fault will likely occur.
182	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
183	  */
184	static void SFU_EXCPT_RuntimeExc­eptionHandler(SFU_EXCPT_IdTypeDef eExceptionId)
185	{
186	  switch (eExceptionId)
187	  {
188	    case SFU_EXCPT_TAMPERING_­FAULT:
189	      /* WARNING: This might be generated by an attempted attack, a bug or your code!
190	         Add your code here in order to implement a custom action for this event,
191	         e.g. trigger a mass erase or take any other action in order to
192	         protect your system.
193	         ...
194	         ...
195	      */
196	      break;
197
198	    case SFU_EXCPT_MEMORY_FAU­LT:
199	      /* WARNING: This might be generated by an attempted attack, a bug or your code!
200	         Add your code here in order to implement a custom action for this event,
201	         e.g. trigger a mass erase or take any other action in order to
202	         protect your system.
203	         ...
204	         ...
205	      */
206	      break;
207
208	    case SFU_EXCPT_HARD_FAULT­:
209	      /* WARNING: This might be generated by an attempted attack, a bug or your code!
210	         Add your code here in order to implement a custom action for this event,
211	         e.g. trigger a mass erase or take any other action in order to
212	         protect your system.
213	         ...
214	         ...
215	      */
216	#ifdef SFU_TEST_PROTECTION
217	      SFU_TEST_Error();
218	#endif /* SFU_TEST_PROTECTION */
219	      break;
220
221	    default:
222	      /* WARNING: This might be generated by an attempted attack, a bug or your code!
223	         Add your code here in order to implement a custom action for this event,
224	         e.g. trigger a mass erase or take any other  action in order to
225	         protect your system.
226	         ...
227	         ...
228	      */
229	      break;
230	  }
231
232	}
233
L476_SBSFU\BFU\Application\BFU\App\sfu_error.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_error.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains the error handling elements for SB_SFU.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef SFU_ERROR_H
21	#define SFU_ERROR_H
22
23	#ifdef __cplusplus
24	extern "C" {
25	#endif
26
27	/* Includes ------------------------------------------------------------------*/
28	#include "sfu_def.h"
29
30	/* Exported types ------------------------------------------------------------*/
31	/**
32	  * This enum must start from 0.
33	  * When adding a new error in the enum below please also:
34	  *  1. update IS_SFU_EXCPT
35	  *  2. update m_aErrorStrings
36	  */
37	typedef enum
38	{
39	  SFU_EXCPT_NONE = 0UL,
40	  /* System errors */
41	  SFU_EXCPT_MEMORY_FAU­LT,
42	  SFU_EXCPT_HARD_FAULT­,
43	  SFU_EXCPT_TAMPERING_­FAULT,
44	  /* Specific errors */
45	  SFU_EXCPT_LOCK_SE_SE­RVICES_ERR,
46	#if (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER)
47	  SFU_EXCPT_FW_TOO_BIG­,            /* The binary is too big to be installed */
48	  SFU_EXCPT_COM_ERR,               /* COM error during the local download of the binary */
49	#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) */
50	  SFU_EXCPT_HEADER_AUT­H_ERR,       /* header authentication failure */
51	  SFU_EXCPT_DECRYPT_ER­R,           /* Decrypt failure */
52	  SFU_EXCPT_SIGNATURE_­ERR,         /* Signature check failure */
53	  SFU_EXCPT_FLASH_ERR,             /* Problem with FLASH */
54	  SFU_EXCPT_FLASH_CFG_­ERR,         /* Flash configuration issue (external flash) */
55	  SFU_EXCPT_HEADER_ERA­SING_ERR,    /* Header erasing failure */
56	  SFU_EXCPT_HEADER_VAL­IDATION_ERR, /* Header validation failure */
57	  SFU_EXCPT_ADDITIONAL­_CODE_ERR,   /* Additional code detected beyond the firmware image (malicious SW) */
58	  SFU_EXCPT_FWIMG_SWAP­_ERR,        /* Problem while swapping the images */
59	  SFU_EXCPT_FWIMG_ROLL­BACK_ERR,    /* Problem during rollback process */
60	  SFU_EXCPT_FWIMG_ROLL­BACK_PREV_ID_ERR,/* Backed-up firmware not identified */
61	  SFU_EXCPT_BACKUP_COP­Y_FAILURE_ERR, /* Copy in the backup slot failure */
62	  SFU_EXCPT_DWL_SLOT_E­RASING_ERR,  /* Dwl slot erasing failure */
63	  SFU_EXCPT_TRAILER_ER­ASING_ERR,   /* Trailer update failure */
64	  SFU_EXCPT_TRAILER_UP­DATE_ERR,    /* Trailer update failure */
65	  SFU_EXCPT_FWIMG_MAGI­C_ERR,       /* Problem with a FWIMG pattern */
66	  SFU_EXCPT_VERSION_ER­R,           /* Anti-rollback check rejected the version to be installed */
67	  /* Unknown error */
68	  SFU_EXCPT_UNKNOWN                /* To be kept as last error */
69	} SFU_EXCPT_IdTypeDef;   /*!< Errors, Exception, Faults Id */
70
71	/* External variables --------------------------------------------------------*/
72
73	/* Exported macros -----------------------------------------------------------*/
74
75	/* Exported functions ------------------------------------------------------- */
76	void SFU_EXCPT_SetError(SFU_EXCPT_IdTypeDef eExceptionId);
77	void SFU_EXCPT_IrqExcepti­onHandler(SFU_EXCPT_IdTypeDef eExceptionId);
78	void SFU_EXCPT_Security_E­rror(void);
79
80	SFU_ErrorStatus SFU_EXCPT_Init(void);
81	SFU_ErrorStatus SFU_EXCPT_DeInit(void);
82
83	void SFU_EXCPT_ResetExcep­tionHandler(SFU_EXCPT_IdTypeDef eExceptionId);
84
85	#ifdef __cplusplus
86	}
87	#endif
88
89	#endif /* SFU_ERROR_H */
90
L476_SBSFU\BFU\Application\BFU\App\sfu_fsm_states.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_fsm_states.h
4	  * @author  MCD Application Team
5	  * @brief   This file defines the SB_SFU Finite State Machine states.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef SFU_FSM_STATES_H
21	#define SFU_FSM_STATES_H
22
23	#ifdef __cplusplus
24	extern "C" {
25	#endif
26
27	/* Includes ------------------------------------------------------------------*/
28	#include "app_sfu.h"
29
30	/* Exported types ------------------------------------------------------------*/
31	/**
32	  * FSM states: this enum must start from 0.
33	  */
34	typedef enum
35	{
36	  SFU_STATE_CHECK_STAT­US_ON_RESET = 0U, /*!< checks the reset cause and decide how to proceed     */
37	#if (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER)
38	  SFU_STATE_CHECK_NEW_­FW_TO_DOWNLOAD,   /*!< SFU checks if a local download must be handled       */
39	  SFU_STATE_DOWNLOAD_N­EW_USER_FW,       /*!< downloads the encrypted firmware to be installed     */
40	#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) || (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER) */
41	  SFU_STATE_VERIFY_USE­R_FW_STATUS,      /*!< checks the internal FLASH state to derive a status   */
42	  SFU_STATE_INSTALL_NE­W_USER_FW,        /*!< decrypts and installs the firmware stored in dwl slot*/
43	  SFU_STATE_VERIFY_USE­R_FW_SIGNATURE,   /*!< checks the validity of the active firmware           */
44	  SFU_STATE_EXECUTE_US­ER_FW,            /*!< launch the user application                          */
45	  SFU_STATE_RESUME_INS­TALL_NEW_USER_FW, /*!< resume interrupted installation of firmware          */
46	  SFU_STATE_ROLLBACK_P­REV_USER_FW,      /*!< rollback with previous firmware                      */
47	  SFU_STATE_HANDLE_CRI­TICAL_FAILURE,    /*!< deal with the critical failures                      */
48	  SFU_STATE_REBOOT_STA­TE_MACHINE        /*!< a reboot is forced                                   */
49	} SFU_BOOT_StateMachin­eTypeDef; /*!< SFU BOOT State Machine States */
50
51	/* External variables --------------------------------------------------------*/
52	/**
53	  *  The following strings associated to the SM state are used for debugging purpose.
54	  *  WARNING: The string array must match perfectly with the SFU_BOOT_StateMachin­eTypeDef defined above.
55	  *           And the above enum must be a sequence starting from 0
56	  */
57	#ifdef SFU_DEBUG_MODE
58	#if defined(SFU_VERBOSE_DEBUG_MO­DE) && defined (SFU_BOOT_C)
59	char *m_aStateMachineStrin­gs[] = { "Checking Status on Reset.",
60	#if (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER)
61	                                   "Checking if new Fw Image available to download.",
62	                                   "Downloading new Fw Image.",
63	#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) */
64	                                   "Verifying Fw Image status.",
65	                                   "Installing new Fw Image.",
66	                                   "Verifying Fw Image signature.",
67	                                   "Executing Fw Image.",
68	                                   "Resuming installation of new Fw Image.",
69	                                   "Rollback with previous Fw Image.",
70	                                   "Handling a critical failure.",
71	                                   "Rebooting the State Machine"
72	                                 };
73	#endif /* SFU_VERBOSE_DEBUG_MO­DE && SFU_BOOT_C */
74
75	#endif /* SFU_DEBUG_MODE */
76
77	/* Exported macros -----------------------------------------------------------*/
78	/************ SFU SM States****************************************************/
79	#if (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER)
80	#define IS_SFU_SM_STATE(STATE)  (((STATE) == (uint8_t)SFU_STATE_CHECK_STAT­US_ON_RESET)    || \
81	                                 ((STATE) == (uint8_t)SFU_STATE_CHECK_NEW_­FW_TO_DOWNLOAD) || \
82	                                 ((STATE) == (uint8_t)SFU_STATE_DOWNLOAD_N­EW_USER_FW)     || \
83	                                 ((STATE) == (uint8_t)SFU_STATE_INSTALL_NE­W_USER_FW)      || \
84	                                 ((STATE) == (uint8_t)SFU_STATE_VERIFY_USE­R_FW_STATUS)    || \
85	                                 ((STATE) == (uint8_t)SFU_STATE_VERIFY_USE­R_FW_SIGNATURE) || \
86	                                 ((STATE) == (uint8_t)SFU_STATE_EXECUTE_US­ER_FW)          || \
87	                                 ((STATE) == (uint8_t)SFU_STATE_RESUME_INS­TALL_NEW_USER_FW)|| \
88	                                 ((STATE) == (uint8_t)SFU_STATE_ROLLBACK_P­REV_USER_FW)|| \
89	                                 ((STATE) == (uint8_t)SFU_STATE_HANDLE_CRI­TICAL_FAILURE)  || \
90	                                 ((STATE) == (uint8_t)SFU_STATE_REBOOT_STA­TE_MACHINE))   /*!< SFU SM States*/
91	#else
92	#define IS_SFU_SM_STATE(STATE)  (((STATE) == (uint8_t)SFU_STATE_CHECK_STAT­US_ON_RESET)    || \
93	                                 ((STATE) == (uint8_t)SFU_STATE_INSTALL_NE­W_USER_FW)      || \
94	                                 ((STATE) == (uint8_t)SFU_STATE_VERIFY_USE­R_FW_STATUS)    || \
95	                                 ((STATE) == (uint8_t)SFU_STATE_VERIFY_USE­R_FW_SIGNATURE) || \
96	                                 ((STATE) == (uint8_t)SFU_STATE_EXECUTE_US­ER_FW)          || \
97	                                 ((STATE) == (uint8_t)SFU_STATE_RESUME_INS­TALL_NEW_USER_FW)|| \
98	                                 ((STATE) == (uint8_t)SFU_STATE_ROLLBACK_P­REV_USER_FW)|| \
99	                                 ((STATE) == (uint8_t)SFU_STATE_HANDLE_CRI­TICAL_FAILURE)  || \
100	                                 ((STATE) == (uint8_t)SFU_STATE_REBOOT_STA­TE_MACHINE))   /*!< SFU SM States*/
101	#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) */
102
103	#ifdef __cplusplus
104	}
105	#endif
106
107	#endif /* SFU_FSM_STATES_H */
108
L476_SBSFU\BFU\Application\BFU\App\sfu_fwimg_common.c
1	/**
2	  ******************************************************************************
3	  * @file    sfu_fwimg_common.c
4	  * @author  MCD Application Team
5	  * @brief   This file provides set of firmware functions to manage the Firmware Images.
6	  *          This file contains the "common" functionalities of the image handling.
7	  ******************************************************************************
8	  * @attention
9	  *
10	  * Copyright (c) 2017 STMicroelectronics.
11	  * All rights reserved.
12	  *
13	  * This software is licensed under terms that can be found in the LICENSE file in
14	  * the root directory of this software component.
15	  * If no LICENSE file comes with this software, it is provided AS-IS.
16	  *
17	  ******************************************************************************
18	  */
19
20	#define SFU_FWIMG_COMMON_C
21
22	/* Includes ------------------------------------------------------------------*/
23	#include <string.h>
24	#include "main.h"
25	#include "sfu_fsm_states.h" /* needed for sfu_error.h */
26	#include "sfu_error.h"
27	#include "sfu_low_level.h"
28	#include "sfu_low_level_flash_­int.h"
29	#include "sfu_low_level_securi­ty.h"
30	#include "se_interface_bootloa­der.h"
31	#include "sfu_fwimg_regions.h"
32	#include "sfu_fwimg_services.h"
33	#include "sfu_fwimg_internal.h"
34	#include "sfu_trace.h"
35	#include "sfu_boot.h"
36
37
38
39	/* Private variables ---------------------------------------------------------*/
40	static uint8_t fw_tag_validated[SFU_NB_MAX_ACTIVE_IM­AGE][SE_TAG_LEN];
41
42	/* Global variables ----------------------------------------------------------*/
43	/**
44	  *  FWIMG status variables used to log errors and display debug messages.
45	  *  This is related to FLASH operations.
46	  *  This is handled with STATUS_FWIMG.
47	  */
48	SFU_IMG_StatusTypeDe­f SFU_IMG_Status;
49	uint32_t SFU_IMG_Line;
50
51	/**
52	  * FW header (metadata) of the active FW in active slot: structured format (access by fields)
53	  */
54	SE_FwRawHeaderTypeDe­f fw_image_header_vali­dated;
55
56	/**
57	  * FW header (metadata) of the candidate FW in dwl slot: structured format (access by fields)
58	  */
59	SE_FwRawHeaderTypeDe­f fw_image_header_to_t­est;
60
61	/* Functions Definition : helper ---------------------------------------------*/
62	/**
63	  * @brief  Memory compare with constant time execution.
64	  * @note   Objective is to avoid basic attacks based on time execution
65	  * @param  pAdd1 Address of the first buffer to compare
66	  * @param  pAdd2 Address of the second buffer to compare
67	  * @param  Size Size of the comparison
68	  * @retval SFU_ SUCCESS if equal, a SFU_error otherwise.
69	  */
70	SFU_ErrorStatus MemoryCompare(uint8_t *pAdd1, uint8_t *pAdd2, uint32_t Size)
71	{
72	  /* Use of __IO to force recheck of these variables values */
73	  uint8_t __IO result = 0x00U;
74	  uint32_t __IO i;
75	  uint32_t tmp;
76
77	  for (i = 0U; i < Size; i++)
78	  {
79	    tmp = pAdd1[i];
80	    tmp ^= pAdd2[i];
81	    result |= tmp;
82	  }
83
84	  if ((result == 0x00U) && (i == Size)) /* Add check that loop exited normally without any fault injection */
85	  {
86	    return (((result != 0x00U) || (i != Size))? SFU_ERROR : SFU_SUCCESS);
87	  }
88	  else
89	  {
90	    return SFU_ERROR;
91	  }
92	}
93
94
95	/**
96	  * @brief  Check header signature
97	  * @param  pFwImageHeader: pointer to raw header.
98	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
99	  */
100	SFU_ErrorStatus VerifyHeaderSignatur­e(SE_FwRawHeaderTypeDe­f *pFwImageHeader)
101	{
102	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
103	  SE_StatusTypeDef se_status;
104	  uint8_t result = 0x00U;
105	  uint32_t i;
106
107	  /* Check if the FW header is authentic : SFU1 / SFU2 / SFU3 */
108	  if (SFU_IMG_GetFwImageSl­ot(pFwImageHeader) != SLOT_INACTIVE)
109	  {
110	    /* Unused bytes should be set at 0x00 value
111	       Comparison with constant time execution */
112	    for (i = 0U; i < sizeof(pFwImageHeader->Reserved); i++)
113	    {
114	      result |= pFwImageHeader->Reserved[i] ^ 0x00U;
115	    }
116
117	    if (result == 0x00U)
118	    {
119	      /* Check signature of the FW header */
120	      if (SE_VerifyHeaderSigna­ture(&se_status, pFwImageHeader) == SE_SUCCESS)
121	      {
122	        FLOW_STEP(uFlowCryptoValue, FLOW_STEP_AUTHENTICA­TE);
123	        e_ret_status = SFU_SUCCESS;
124	      }
125	    }
126	  }
127
128	  return e_ret_status;
129	}
130
131
132	/**
133	  * @brief Secure Engine Firmware signature verification (FW in non contiguous area).
134	  *        It handles Firmware TAG verification of a complete buffer by calling
135	  *        SE_AuthenticateFW_In­it, SE_AuthenticateFW_Ap­pend and SE_AuthenticateFW_Fi­nish inside the firewall.
136	  * @note: AES_GCM tag: In order to verify the TAG of a buffer, the function will re-encrypt it
137	  *        and at the end compare the obtained TAG with the one provided as input
138	  *        in pSE_GMCInit parameter.
139	  * @note: SHA-256 tag: a hash of the firmware is performed and compared with the digest stored in the Firmware header.
140	  * @param pSE_Status: Secure Engine Status.
141	  *        This parameter can be a value of @ref SE_Status_Structure_­definition.
142	  * @param SlotNumber index of the slot in the list
143	  * @param pSE_Metadata: Firmware metadata.
144	  * @param pSE_Payload: pointer to Payload Buffer descriptor.
145	  * @param SE_FwType: Type of Fw Image.
146	  *        This parameter can be SE_FW_IMAGE_COMPLETE­ or SE_FW_IMAGE_PARTIAL.
147	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
148	  */
149	SFU_ErrorStatus VerifyFwSignatureSca­tter(SE_StatusTypeDef *pSeStatus, uint32_t SlotNumber,
150	                                         SE_FwRawHeaderTypeDe­f *pSE_Metadata,
151	                                         SE_Ex_PayloadDescTyp­eDef  *pSE_Payload, uint32_t SE_FwType)
152	{
153	  SE_ErrorStatus se_ret_status = SE_ERROR;
154	  SFU_ErrorStatus sfu_ret_status = SFU_SUCCESS;
155	  /* Loop variables */
156	  uint32_t i;
157	  uint32_t j;
158	  /* Variables to handle the FW image chunks to be injected in the verification procedure and the result */
159	  uint32_t fw_tag_len;                 /* length of the authentication tag to be verified */
160	  uint32_t fw_verified_total_si­ze = 0; /* number of bytes that have been processed during authentication check */
161	  uint32_t fw_chunk_size;              /* size of a FW chunk to be verified */
162	  /* Authentication tag computed in this procedure (to be compared with the one stored in the FW metadata) */
163	  uint8_t fw_tag_output[SE_TAG_LEN] __attribute__((aligned(8)));
164	  /* FW chunk produced by the verification procedure if any   */
165	  uint8_t fw_chunk[CHUNK_SIZE_SIGN_VERI­FICATION] __attribute__((aligned(8)));
166	  /* FW chunk provided as input to the verification procedure */
167	  uint8_t fw_image_chunk[CHUNK_SIZE_SIGN_VERI­FICATION] __attribute__((aligned(8)));
168	  /* Variables to handle the FW image (this will be split in chunks) */
169	  uint32_t payloadsize;
170	  uint32_t ppayload;
171	  uint32_t scatter_nb;
172	  /* Variables to handle FW image size and tag */
173	  uint32_t fw_size;
174	  uint8_t *fw_tag;
175
176	  /* Check the pointers allocation */
177	  if ((pSeStatus == NULL) || (pSE_Metadata == NULL) || (pSE_Payload == NULL))
178	  {
179	    return SFU_ERROR;
180	  }
181	  if ((pSE_Payload->pPayload[0] == 0U) || ((pSE_Payload->pPayload[1] == 0U) && (pSE_Payload->PayloadSize[1] != 0U)))
182	  {
183	    return SFU_ERROR;
184	  }
185
186	  /* Check the parameters value and set fw_size and fw_tag to check */
187	  if (SE_FwType == SE_FW_IMAGE_COMPLETE­)
188	  {
189	    fw_size = pSE_Metadata->FwSize;
190	    fw_tag = pSE_Metadata->FwTag;
191	  }
192	  else if (SE_FwType == SE_FW_IMAGE_PARTIAL)
193	  {
194	    fw_size = pSE_Metadata->PartialFwSize;
195	    fw_tag = pSE_Metadata->PartialFwTag;
196	  }
197	  else
198	  {
199	    return SFU_ERROR;
200	  }
201
202	  if ((pSE_Payload->PayloadSize[0] + pSE_Payload->PayloadSize[1]) != fw_size)
203	  {
204	    return SFU_ERROR;
205	  }
206
207	  /*  fix number of scatter block */
208	  if (pSE_Payload->PayloadSize[1] != 0U)
209	  {
210	    scatter_nb = 2U;
211	  }
212	  else
213	  {
214	    scatter_nb = 1U;
215	  }
216
217
218	  /* Encryption process*/
219	  se_ret_status = SE_AuthenticateFW_In­it(pSeStatus, pSE_Metadata, SE_FwType);
220
221	  /* check for initialization errors */
222	  if ((se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
223	  {
224	    for (j = 0; j < scatter_nb; j++)
225	    {
226	      payloadsize = pSE_Payload->PayloadSize[j];
227	      ppayload = pSE_Payload->pPayload[j];
228	      i = 0;
229	      fw_chunk_size = CHUNK_SIZE_SIGN_VERI­FICATION;
230
231	      while ((i < (payloadsize / CHUNK_SIZE_SIGN_VERI­FICATION)) && (*pSeStatus == SE_OK) &&
232	             (sfu_ret_status == SFU_SUCCESS))
233	      {
234
235	        sfu_ret_status = SFU_LL_FLASH_Read(fw_image_chunk, (uint8_t *)ppayload, fw_chunk_size) ;
236	        if (sfu_ret_status == SFU_SUCCESS)
237	        {
238	          se_ret_status = SE_AuthenticateFW_Ap­pend(pSeStatus, fw_image_chunk, (int32_t)fw_chunk_size,
239	                                                   fw_chunk, (int32_t *)&fw_chunk_size);
240	        }
241	        else
242	        {
243	          *pSeStatus = SE_ERR_FLASH_READ;
244	          se_ret_status = SE_ERROR;
245	          sfu_ret_status = SFU_ERROR;
246	        }
247	        ppayload += fw_chunk_size;
248	        fw_verified_total_si­ze += fw_chunk_size;
249	        i++;
250	      }
251	      /* this the last path , size can be smaller */
252	      fw_chunk_size = pSE_Payload->pPayload[j] + pSE_Payload->PayloadSize[j] - ppayload;
253	      if ((fw_chunk_size != 0U) && (se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
254	      {
255	        sfu_ret_status = SFU_LL_FLASH_Read(fw_image_chunk, (uint8_t *)ppayload, fw_chunk_size) ;
256	        if (sfu_ret_status == SFU_SUCCESS)
257	        {
258
259	          se_ret_status = SE_AuthenticateFW_Ap­pend(pSeStatus, fw_image_chunk,
260	                                                   (int32_t)(payloadsize - (i * CHUNK_SIZE_SIGN_VERI­FICATION)),
261	                                                   fw_chunk, (int32_t *)&fw_chunk_size);
262	        }
263	        else
264	        {
265	          *pSeStatus = SE_ERR_FLASH_READ;
266	          se_ret_status = SE_ERROR;
267	          sfu_ret_status = SFU_ERROR;
268	        }
269	        fw_verified_total_si­ze += fw_chunk_size;
270	      }
271	    }
272	  }
273
274	  if ((sfu_ret_status == SFU_SUCCESS) && (se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK))
275	  {
276	    if (fw_verified_total_si­ze <= fw_size)
277	    {
278	      /* Do the Finalization, check the authentication TAG*/
279	      fw_tag_len = sizeof(fw_tag_output);
280	      se_ret_status =   SE_AuthenticateFW_Fi­nish(pSeStatus, fw_tag_output, (int32_t *)&fw_tag_len);
281
282	      if ((se_ret_status == SE_SUCCESS) && (*pSeStatus == SE_OK) && (fw_tag_len == SE_TAG_LEN))
283	      {
284	        /* Firmware tag verification */
285	        if (MemoryCompare(fw_tag_output, fw_tag, SE_TAG_LEN) != SFU_SUCCESS)
286	        {
287	          *pSeStatus = SE_SIGNATURE_ERR;
288	          se_ret_status = SE_ERROR;
289	          sfu_ret_status = SFU_ERROR;
290
291	          /* Save result for active slot :
292	             to avoid single fault attack the signature will be double checked before UserApp execution */
293	          if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber < SLOT_DWL_1))
294	          {
295	            (void) memset(&fw_tag_validated[SlotNumber - SLOT_ACTIVE_1][0U], 0x00, SE_TAG_LEN);
296	          }
297	        }
298	        else
299	        {
300	          FLOW_STEP(uFlowCryptoValue, FLOW_STEP_INTEGRITY);
301
302	          /* Save result for active slot :
303	             to avoid single fault attack the signature will be double checked before UserApp execution */
304	          if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber < SLOT_DWL_1))
305	          {
306	            (void) memcpy(&fw_tag_validated[SlotNumber - SLOT_ACTIVE_1][0U], fw_tag_output, SE_TAG_LEN);
307	          }
308	        }
309	      }
310	      else
311	      {
312	        sfu_ret_status = SFU_ERROR;
313	      }
314	    }
315	    else
316	    {
317	      sfu_ret_status = SFU_ERROR;
318	    }
319	  }
320	  else
321	  {
322	    sfu_ret_status = SFU_ERROR;
323	  }
324	  return sfu_ret_status;
325	}
326
327	/**
328	  * @brief Fill authenticated info in SE_FwImage.
329	  * @param SFU_APP_Status
330	  * @param pBuffer
331	  * @param BufferSize
332	  * @retval SFU_SUCCESS if successful, a SFU_ERROR otherwise.
333	  */
334	SFU_ErrorStatus ParseFWInfo(SE_FwRawHeaderTypeDe­f *pFwHeader, uint8_t *pBuffer)
335	{
336	  /* Check the pointers allocation */
337	  if ((pFwHeader == NULL) || (pBuffer == NULL))
338	  {
339	    return SFU_ERROR;
340	  }
341	  (void) memcpy(pFwHeader, pBuffer, sizeof(*pFwHeader));
342	  return SFU_SUCCESS;
343	}
344
345	/**
346	  * @brief  Verify Image Header in the slot given as a parameter
347	  * @param  SlotNumber index of the slot in the list
348	  * @param  pFwImageHeader pointer to a structure to handle the header info (filled by this function)
349	  * @note   Not used in Alpha version -
350	  * @retval SFU_SUCCESS if successful, a SFU_ErrorStatus error otherwise.
351	  */
352	SFU_ErrorStatus CheckAndGetFWHeader(uint32_t SlotNumber, SE_FwRawHeaderTypeDe­f *pFwImageHeader)
353	{
354	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
355
356	  /* use api read to detect possible ECC error */
357	  e_ret_status = SFU_LL_FLASH_Read((uint8_t *) pFwImageHeader, (uint8_t *) SlotHeaderAdd[SlotNumber],
358	                                   sizeof(SE_FwRawHeaderTypeDe­f));
359	  if (e_ret_status == SFU_SUCCESS)
360	  {
361	    /* Verify signature */
362	    e_ret_status = VerifyHeaderSignatur­e(pFwImageHeader);
363	  }
364	  return e_ret_status;
365	}
366
367	/**
368	  * @brief  Verify Fw signature of binary contiguous in flash
369	  * @param  pSeStatus pointer giving the SE status result
370	  * @param  SlotNumber flash slot to check
371	  * @param  pFwImageHeader pointer to fw header
372	  * @param  SlotNumber flash slot to check
373	  * @param SE_FwType: Type of Fw Image.
374	  *        This parameter can be SE_FW_IMAGE_COMPLETE­ or SE_FW_IMAGE_PARTIAL.
375	  * @retval SFU_SUCCESS if successful, a SFU_ErrorStatus error otherwise.
376	  */
377	SFU_ErrorStatus VerifyFwSignature(SE_StatusTypeDef  *pSeStatus, uint32_t SlotNumber,
378	                                  SE_FwRawHeaderTypeDe­f *pFwImageHeader,
379	                                  uint32_t SE_FwType)
380	{
381	  SE_Ex_PayloadDescTyp­eDef  pse_payload;
382	  uint32_t fw_size;
383	  uint32_t fw_offset;
384
385	  /*  put it OK, to discriminate error in SFU FWIMG parts */
386	  *pSeStatus = SE_OK;
387
388	  /* Check the parameters value */
389	  if (pFwImageHeader == NULL)
390	  {
391	    return SFU_ERROR;
392	  }
393	  if ((SE_FwType != SE_FW_IMAGE_PARTIAL) && (SE_FwType != SE_FW_IMAGE_COMPLETE­))
394	  {
395	    return SFU_ERROR;
396	  }
397
398	  /* Check SE_FwType parameter, and fix size and offset accordingly */
399	  switch (SE_FwType)
400	  {
401	    case SE_FW_IMAGE_COMPLETE­ :
402	      fw_size = pFwImageHeader->FwSize;
403	      fw_offset = 0U;
404	      break;
405	    case SE_FW_IMAGE_PARTIAL :
406	      fw_size = pFwImageHeader->PartialFwSize;
407	#if  !defined(SFU_NO_SWAP)
408	      fw_offset = pFwImageHeader->PartialFwOffset % SLOT_SIZE(SLOT_SWAP);
409	#else
410	      fw_offset = pFwImageHeader->PartialFwOffset;
411	#endif /* !(SFU_NO_SWAP) */
412	      break;
413	    default :
414	      /* error */
415	      fw_size = 0U;
416	      fw_offset = 0U;
417	      break;
418	  }
419
420	  pse_payload.pPayload[0] = SlotStartAdd[SlotNumber] + fw_offset + SFU_IMG_IMAGE_OFFSET­;
421	  pse_payload.PayloadSize[0] = fw_size;
422	  pse_payload.pPayload[1] = 0U;
423	  pse_payload.PayloadSize[1] = 0U;
424
425	  return  VerifyFwSignatureSca­tter(pSeStatus, SlotNumber, pFwImageHeader, &pse_payload, SE_FwType);
426	}
427
428	/**
429	  * @brief Verifies the validity of a slot.
430	  * @note  Control if there is no additional code beyond the firmware image (malicious SW).
431	  * @param pSlotBegin Start address of a slot.
432	  * @param uSlotSize Size of a slot.
433	  * @param uFwSize Size of the firmware image.
434	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, error code otherwise
435	  */
436	SFU_ErrorStatus VerifySlot(uint8_t *pSlotBegin, uint32_t uSlotSize, uint32_t uFwSize)
437	{
438	  uint8_t *pdata;
439	  uint32_t length;
440	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
441
442	  /* Check is already clean */
443	  pdata = pSlotBegin + SFU_IMG_IMAGE_OFFSET­ + uFwSize;
444	  length = uSlotSize - SFU_IMG_IMAGE_OFFSET­ - uFwSize;
445	  e_ret_status = SFU_LL_FLASH_Compare­(pdata, 0x00000000U, 0xFFFFFFFFU, length);
446
447	  return e_ret_status;
448	}
449
450	/**
451	  * @brief  This function clean-up the flash
452	  * @note   Not designed to clean-up area inside secure engine isolation.
453	  * @note   To clean the slot without erasing the header we write "0x00" except if already written
454	  * @param  pSlotBegin Start address of a slot.
455	  * @param  uSlotSize Size of a slot.
456	  * @param  uOffset Offset in the slot to start cleanup, until end of the slot.
457	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
458	  */
459	SFU_ErrorStatus CleanUpSlot(uint8_t *pSlotBegin, uint32_t uSlotSize, uint32_t uOffset)
460	{
461	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
462	  uint32_t pdata;
463	  uint32_t slot_begin;
464	  SFU_LL_FLASH_write_t­ pattern;
465	  SFU_LL_FLASH_write_t­ value;
466	  SFU_FLASH_StatusType­Def flash_if_info;
467
468	  /* Clean-up pattern initialization */
469	  (void) memset((void *)&pattern, 0x00, sizeof(SFU_LL_FLASH_write_t­));
470
471	  /* Cleaning operation */
472	  slot_begin = (uint32_t) pSlotBegin;
473	  for (pdata = slot_begin + uOffset; pdata < (slot_begin + uSlotSize); pdata += sizeof(SFU_LL_FLASH_write_t­))
474	  {
475	    e_ret_status =  SFU_LL_FLASH_Read((uint8_t *) &value, (uint8_t *) pdata, sizeof(SFU_LL_FLASH_write_t­));
476
477	    if (e_ret_status == SFU_SUCCESS)
478	    {
479	      /* If read succeed, then the pattern write is performed only if pattern is not already present */
480	      if (memcmp((void *) &value, (void *) &pattern, sizeof(SFU_LL_FLASH_write_t­)) != 0)
481	      {
482	        e_ret_status = SFU_LL_FLASH_Write(&flash_if_info, (uint8_t *) pdata, (uint8_t *) &pattern,
483	                                          sizeof(SFU_LL_FLASH_write_t­));
484	      }
485	    }
486	    else
487	    {
488	      /* If read fail, then the write is performed unconditionally */
489	      e_ret_status = SFU_LL_FLASH_Write(&flash_if_info, (uint8_t *) pdata, (uint8_t *) &pattern,
490	                                        sizeof(SFU_LL_FLASH_write_t­));
491	    }
492
493	    /* Reload Watchdog every 4Kbytes */
494	    if ((pdata % 0x1000U) == 0U)
495	    {
496	      (void) SFU_LL_SECU_IWDG_Ref­resh();
497	    }
498	  }
499	  return e_ret_status;
500	}
501
502	/* Functions Definition : services ------------------------------------------- */
503
504	/**
505	  * @brief FW Image Handling (FWIMG) initialization function.
506	  *        Checks the validity of the settings related to image handling (slots size and alignments...).
507	  * @note  The system initialization must have been performed before calling this function (flash driver ready to be
508	  *        used...etc...).
509	  *        Must be called first (and once) before calling the other Image handling services.
510	  * @param  None.
511	  * @retval SFU_IMG_InitStatusTy­peDef SFU_IMG_INIT_OK if successful, an error code otherwise.
512	  */
513	SFU_IMG_InitStatusTy­peDef SFU_IMG_InitImageHan­dling(void)
514	{
515	  uint32_t i;
516	  SFU_IMG_InitStatusTy­peDef e_ret_status = SFU_IMG_INIT_OK;
517	#if  !defined(SFU_NO_SWAP)
518	  SFU_IMG_InitStatusTy­peDef e_swap_ret_status;
519	#endif /* !(SFU_NO_SWAP) */
520
521	  /*
522	   * When there is no valid FW in active, the fw_image_header_vali­dated structure is filled with 0s.
523	   * When installing a first FW (after local download) this means that WRITE_TRAILER_MAGIC will write a SWAP magic
524	   * starting with 0s.
525	   * This causes an issue when calling CLEAN_TRAILER_MAGIC (because of this we added an erase that generated
526	   * side-effects).
527	   * To avoid all these problems we can initialize fw_image_header_vali­dated with a non-0  value.
528	   */
529	  (void) memset((uint8_t *) &fw_image_header_vali­dated, 0xFE, sizeof(fw_image_header_vali­dated));
530
531	  /*
532	   * Sanity check: let's make sure all actives slots are properly aligned with regards to flash constraints
533	   */
534	  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IM­AGE; i++)
535	  {
536	#if defined(__GNUC__)
537	    __IO uint32_t start_add;
538	    start_add = SlotStartAdd[SLOT_ACTIVE_1 + i];
539	    if (start_add != 0U)
540	#else
541	    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
542	#endif /* (__GNUC__) */
543	    {
544	      if (!IS_ALIGNED(SlotStartAdd[SLOT_ACTIVE_1 + i]))
545	      {
546	        e_ret_status = SFU_IMG_INIT_FLASH_C­ONSTRAINTS_ERROR;
547	        TRACE("\r\n= [FWIMG] SLOT_ACTIVE_%d (%x) is not properly aligned\r\n",
548	              i + 1U, SlotStartAdd[SLOT_ACTIVE_1 + i]);
549	      } /* else active slot is properly aligned */
550	    }
551	  }
552
553	  for (i = 0U; i < SFU_NB_MAX_DWL_AREA; i++)
554	  {
555	#if defined(__GNUC__)
556	    __IO uint32_t start_add;
557	    start_add = SlotStartAdd[SLOT_DWL_1 + i];
558	    if (start_add != 0U)
559	#else
560	    if (SlotStartAdd[SLOT_DWL_1 + i] != 0U)
561	#endif /* (__GNUC__) */
562	    {
563	      if (!IS_ALIGNED(SlotStartAdd[SLOT_DWL_1 + i]))
564	      {
565	        e_ret_status = SFU_IMG_INIT_FLASH_C­ONSTRAINTS_ERROR;
566	        TRACE("\r\n= [FWIMG] SLOT_DWL_%d (%x) is not properly aligned\r\n",
567	              i + 1U, SlotStartAdd[SLOT_DWL_1 + 1U]);
568	      } /* else dwl slot is properly aligned */
569	    }
570	  }
571
572
573	  /*
574	   * Sanity check: let's make sure the MAGIC patterns used by the internal algorithms match the FLASH constraints.
575	   */
576	  if (0U != (uint32_t)(MAGIC_LENGTH % (uint32_t)sizeof(SFU_LL_FLASH_write_t­)))
577	  {
578	    e_ret_status = SFU_IMG_INIT_FLASH_C­ONSTRAINTS_ERROR;
579	    TRACE("\r\n= [FWIMG] magic size (%d) is not matching the FLASH constraints\r\n", MAGIC_LENGTH);
580	  } /* else the MAGIC patterns size is fine with regards to FLASH constraints */
581
582	  /*
583	   * Sanity check: let's make sure the Firmware Header Length is fine with regards to FLASH constraints
584	   */
585	  if (0U != (uint32_t)(SE_FW_HEADER_TOT_LEN­ % (uint32_t)sizeof(SFU_LL_FLASH_write_t­)))
586	  {
587	    /* The code writing the FW header in FLASH requires the FW Header length to match the FLASH constraints */
588	    e_ret_status = SFU_IMG_INIT_FLASH_C­ONSTRAINTS_ERROR;
589	    TRACE("\r\n= [FWIMG] FW Header size (%d) is not matching the FLASH constraints\r\n", SE_FW_HEADER_TOT_LEN­);
590	  } /* else the FW Header Length is fine with regards to FLASH constraints */
591
592	  /*
593	   * Sanity check: let's make sure the chunks used for decrypt match the FLASH constraints
594	   */
595	  if (0U != (uint32_t)(SFU_IMG_CHUNK_SIZE % (uint32_t)sizeof(SFU_LL_FLASH_write_t­)))
596	  {
597	    /* The size of the chunks used to store the decrypted data must be a multiple of the FLASH write length */
598	    e_ret_status = SFU_IMG_INIT_FLASH_C­ONSTRAINTS_ERROR;
599	    TRACE("\r\n= [FWIMG] Decrypt chunk size (%d) is not matching the FLASH constraints\r\n", SFU_IMG_CHUNK_SIZE);
600	  } /* else the decrypt chunk size is fine with regards to FLASH constraints */
601
602	  /*
603	   * Sanity check: let's make sure the chunk size used for decrypt is fine with regards to AES CBC constraints.
604	   *               This block alignment constraint does not exist for AES GCM but we do not want to specialize the code
605	   *               for a specific crypto scheme.
606	   */
607	  if (0U != (uint32_t)((uint32_t)SFU_IMG_CHUNK_SIZE % (uint32_t)AES_BLOCK_SIZE))
608	  {
609	    /* For AES CBC block encryption/decryption the chunks must be aligned on the AES block size */
610	    e_ret_status = SFU_IMG_INIT_CRYPTO_­CONSTRAINTS_ERROR;
611	    TRACE("\r\n= [FWIMG] Chunk size (%d) is not matching the AES CBC constraints\r\n", SFU_IMG_CHUNK_SIZE);
612	  }
613
614	  /*
615	   * Sanity check: let's make sure the active slot headers do not overlap SB code area protected by WRP
616	   */
617	  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IM­AGE; i++)
618	  {
619	#if defined(__GNUC__)
620	    __IO uint32_t start_add;
621	    start_add = SlotStartAdd[SLOT_ACTIVE_1 + i];
622	    if (start_add != 0U)
623	#else
624	    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
625	#endif /* (__GNUC__) */
626	    {
627	      if (((SlotStartAdd[SLOT_ACTIVE_1 + i] - FLASH_BASE) / FLASH_PAGE_SIZE) <= SFU_PROTECT_WRP_PAGE­_END_1)
628	      {
629	        TRACE("\r\n= [FWIMG] SLOT_ACTIVE_%d overlaps SBSFU code area protected by WRP\r\n", i + 1U);
630	        e_ret_status = SFU_IMG_INIT_FLASH_C­ONSTRAINTS_ERROR;
631	      }
632	    }
633	  }
634
635	  /*
636	   * Sanity check: let's make sure the dwl slot does not overlap SB code area protected by WRP
637	   */
638	  for (i = 0U; i < SFU_NB_MAX_DWL_AREA; i++)
639	  {
640	#if defined(__GNUC__)
641	    __IO uint32_t start_add;
642	    start_add = SlotStartAdd[SLOT_DWL_1 + i];
643	    if (start_add != 0U)
644	#else /* (__GNUC__) */
645	    if (SlotStartAdd[SLOT_DWL_1 + i] != 0U)
646	#endif /* (__GNUC__) */
647	    {
648	      if (((SlotStartAdd[SLOT_DWL_1 + i] - FLASH_BASE) / FLASH_PAGE_SIZE) <= SFU_PROTECT_WRP_PAGE­_END_1)
649	      {
650	        TRACE("\r\n= [FWIMG] SLOT_DWL_%d overlaps SBSFU code area protected by WRP\r\n", i + 1U);
651	        e_ret_status = SFU_IMG_INIT_FLASH_C­ONSTRAINTS_ERROR;
652	      }
653	    }
654	  }
655
656
657	  /*
658	   * Sanity check: the firewall NVdata segment must overlap the firewall code segment
659	   */
660	  if (((SFU_PROTECT_FWALL_NV­DATA_ADDR_START - FLASH_BANK_SIZE) > SFU_PROTECT_FWALL_CO­DE_ADDR_START) ||
661	      ((SFU_PROTECT_FWALL_NV­DATA_ADDR_START + SFU_PROTECT_FWALL_NV­DATA_SIZE - FLASH_BANK_SIZE) <
662	       (SFU_PROTECT_FWALL_CO­DE_ADDR_START + SFU_PROTECT_FWALL_CO­DE_SIZE)))
663	  {
664	    TRACE("\r\n= [FWIMG] Firewall NVdata segment doesn't overlap firewall code segment\r\n");
665	    e_ret_status = SFU_IMG_INIT_FLASH_C­ONSTRAINTS_ERROR;
666	  }
667
668	  /*
669	   * Sanity check: let's make sure headers are under the firewall protection
670	   */
671	  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IM­AGE; i++)
672	  {
673	#if defined(__GNUC__)
674	    __IO uint32_t start_add;
675	    start_add = SlotStartAdd[SLOT_ACTIVE_1 + i];
676	    if (start_add != 0U)
677	#else
678	    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
679	#endif /* (__GNUC__) */
680	    {
681	      if (!((SlotHeaderAdd[SLOT_ACTIVE_1 + i] >= SFU_PROTECT_FWALL_NV­DATA_ADDR_START)
682	            && ((SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SE_FW_HEADER_TOT_LEN­) <= (SFU_PROTECT_FWALL_NV­DATA_ADDR_START +
683	                                                                              SFU_PROTECT_FWALL_NV­DATA_SIZE))))
684	      {
685	        TRACE("\r\n= [FWIMG] Header of SLOT_ACTIVE_%d is not under the firewall protection\r\n", i + 1U);
686	        e_ret_status = SFU_IMG_INIT_FLASH_C­ONSTRAINTS_ERROR;
687	      }
688	    }
689	  }
690
691
692
693	#if  !defined(SFU_NO_SWAP)
694	  /*
695	   * Sanity check: specific swap process checks
696	   */
697	  e_swap_ret_status = SFU_IMG_CheckSwapIma­geHandling();
698	  if (e_swap_ret_status != SFU_IMG_INIT_OK)
699	  {
700	    e_ret_status = e_swap_ret_status;
701	  }
702	#endif /* !(SFU_NO_SWAP) */
703
704
705	  return e_ret_status;
706	}
707
708	/**
709	  * @brief This function makes sure the current active firmware will not be considered as valid any more.
710	  *        This function alters the FLASH content.
711	  * @note It is up to the caller to make sure the conditions to call this primitive are met (no check performed before
712	  *       running the procedure).
713	  * @param  SlotNumber index of the slot in the list
714	  * @retval SFU_SUCCESS if successful,SFU_ERROR error otherwise.
715	  */
716	SFU_ErrorStatus SFU_IMG_InvalidateCu­rrentFirmware(uint32_t SlotNumber)
717	{
718	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
719
720	  /* Reload Watchdog */
721	  (void) SFU_LL_SECU_IWDG_Ref­resh();
722
723	  /* erase active slot except Header (under SECoreBin protection) for the anti-rollback check during next Fw update */
724	  e_ret_status = CleanUpSlot((uint8_t *) SlotStartAdd[SlotNumber], SLOT_SIZE(SlotNumber), SFU_IMG_IMAGE_OFFSET­);
725
726	  return (e_ret_status);
727	}
728
729	/**
730	  * @brief Verifies the validity of the active firmware image metadata.
731	  * @note This function relies on cryptographic procedures and it is up to the caller to make sure the required
732	  *       elements have been configured.
733	  * @note This function populates the FWIMG module variable: fw_image_header_vali­dated
734	  * @param  SlotNumber index of the slot in the list
735	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, error code otherwise
736	  */
737	SFU_ErrorStatus SFU_IMG_VerifyActive­ImgMetadata(uint32_t SlotNumber)
738	{
739	  /*
740	   * If the metadata is valid then 'fw_image_header_vali­dated' is filled with the metadata.
741	   */
742	  return (CheckAndGetFWHeader(SlotNumber, &fw_image_header_vali­dated));
743	}
744
745	/**
746	  * @brief Verifies the validity of the active firmware image.
747	  * @note This function relies on cryptographic procedures and it is up to the caller to make sure the required
748	  *       elements have been configured.
749	  *       Typically, SFU_IMG_VerifyActive­ImgMetadata() must have been called first to populate
750	  *       fw_image_header_vali­dated.
751	  * @param  SlotNumber index of the slot in the list
752	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, error code otherwise
753	  */
754	SFU_ErrorStatus SFU_IMG_VerifyActive­Img(uint32_t SlotNumber)
755	{
756	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
757	  SE_StatusTypeDef e_se_status = SE_KO;
758
759	  /*
760	   * fw_image_header_vali­dated MUST have been populated with valid metadata first,
761	   */
762	  e_ret_status = VerifyFwSignature(&e_se_status, SlotNumber, &fw_image_header_vali­dated, SE_FW_IMAGE_COMPLETE­);
763	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
764	  if (SFU_ERROR == e_ret_status)
765	  {
766	    /* We do not memorize any specific error, the FSM state is already providing the info */
767	    TRACE("\r\n=         SFU_IMG_VerifyActive­Img failure with se_status=%d!", e_se_status);
768	  }
769	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
770
771	  return (e_ret_status);
772	}
773
774	/**
775	  * @brief Verifies if no malicious code beyond Fw Image in an active slot.
776	  * @note SFU_IMG_VerifyActive­ImgMetadata() must have been called first to populate fw_image_header_vali­dated.
777	  * @param  SlotNumber index of the slot in the list
778	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, error code otherwise
779	  */
780	SFU_ErrorStatus SFU_IMG_VerifyActive­Slot(uint32_t SlotNumber)
781	{
782	  /*
783	   * fw_image_header_vali­dated MUST have been populated with valid metadata first,
784	   */
785	  return (VerifySlot((uint8_t *) SlotStartAdd[SlotNumber], SLOT_SIZE(SlotNumber), fw_image_header_vali­dated.FwSize));
786	}
787
788	/**
789	  * @brief Verifies if no malicious code in active slot.
790	  * @param  SlotNumber index of the slot in the list
791	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, error code otherwise
792	  */
793	SFU_ErrorStatus SFU_IMG_VerifyEmptyA­ctiveSlot(uint32_t SlotNumber)
794	{
795	  return (VerifySlot((uint8_t *) SlotStartAdd[SlotNumber], SLOT_SIZE(SlotNumber), 0U));
796	}
797
798	/**
799	  * @brief  Control firmware signature
800	  * @note   This control will be done twice for security reasons (first control done in VerifyFwSignatureSca­tter)
801	  * @param  SlotNumber index of the slot in the list
802	  * @retval SFU_SUCCESS if successful,SFU_ERROR otherwise.
803	  */
804	SFU_ErrorStatus SFU_IMG_ControlActiv­eImgTag(uint32_t SlotNumber)
805	{
806	  /*
807	   * fw_image_header_vali­dated MUST have been populated with valid metadata first,
808	   */
809	  if (MemoryCompare(fw_tag_validated[SlotNumber - SLOT_ACTIVE_1], fw_image_header_vali­dated.FwTag,
810	                    SE_TAG_LEN) != SFU_SUCCESS)
811	  {
812	    return SFU_ERROR;
813	  }
814	  else
815	  {
816	    FLOW_STEP(uFlowCryptoValue, FLOW_STEP_INTEGRITY);
817	    return SFU_SUCCESS;
818	  }
819
820	}
821
822	/**
823	  * @brief Launches the user application.
824	  *        The caller must be prepared to never get the hand back after calling this function.
825	  *        If a problem occurs, it must be memorized in the bootinfo area.
826	  *        If the caller gets the hand back then this situation must be handled as a critical error.
827	  * @note It is up to the caller to make sure the conditions to call this primitive are met
828	  *       (typically: no security check performed before launching the firmware).
829	  * @note This function only handles the "system" aspects.
830	  *       It is up to the caller to manage any security related action (enable ITs, disengage MPU, clean RAM...).
831	  *       Nevertheless, cleaning-up the stack and heap used by SB_SFU is part of the system actions handled by this
832	  *       function (as this needs to be done just before jumping into the user application).
833	  * @param  SlotNumber index of the slot in the list
834	  * @retval SFU_ErrorStatus Does not return if successful, returns SFU_ERROR otherwise.
835	  */
836	SFU_ErrorStatus SFU_IMG_LaunchActive­Img(uint32_t SlotNumber)
837	{
838	  SFU_ErrorStatus e_ret_status = SFU_SUCCESS;
839
840	  /* Verify if authentication/integrity/lock SE service performed */
841	  FLOW_CONTROL_CHECK(uFlowCryptoValue, FLOW_CTRL_LOCK_SERVI­CE);
842
843	  uint32_t jump_address ;
844	  typedef void (*Function_Pointer)(void);
845	  Function_Pointer  p_jump_to_function;
846
847	#if defined(SFU_MPU_PROTECT_ENAB­LE)
848	#if defined(SFU_MPU_USERAPP_ACTI­VATION)
849	  e_ret_status = SFU_LL_SECU_SetProte­ctionMPU_UserApp();
850	#else
851	  HAL_MPU_Disable();
852	#endif /* SFU_MPU_USERAPP_ACTI­VATION */
853	#endif /* SFU_MPU_PROTECT_ENAB­LE */
854
855	  /* Avoid systick interruption during UserApp start-up
856	     systick will be re-initialized by HAL_Init() during execution of main() from UserApp */
857	  HAL_SuspendTick();
858
859	#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
860	    /* Reset FPU context */
861	    SCB->CPACR &= ~((3UL << 10*2)|(3UL << 11*2));  /* reset CP10 and CP11 Full Access */
862	    FPU->FPCCR &= ~FPU_FPCCR_LSPEN_Msk; /* Disable automatic lazy state preservation for floating-point context */
863	    FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk­; /* Clear the lazy state preservation for floating-point context */
864	#endif /* (__FPU_PRESENT == 1) && (__FPU_USED == 1) */
865
866	  /* Initialize address of user application to jump into */
867	  jump_address = *(__IO uint32_t *)((SlotStartAdd[SlotNumber] + SFU_IMG_IMAGE_OFFSET­ + 4));
868	  p_jump_to_function = (Function_Pointer) jump_address;
869
870	  /* Initialize user application's Stack Pointer */
871	  __set_MSP(*(__IO uint32_t *)(SlotStartAdd[SlotNumber] + SFU_IMG_IMAGE_OFFSET­));
872
873	  if (SFU_SUCCESS == e_ret_status)
874	  {
875	    /* JUMP into User App */
876	    p_jump_to_function();
877	  }
878
879	  /* The point below should NOT be reached */
880	  return (e_ret_status);
881	}
882
883	/**
884	  * @brief Get the version of the active FW
885	  * @note It is up to the caller to make sure the active slot contains a valid active FW.
886	  * @note In the current implementation the header is checked (authentication) and no version is returned if this check
887	  *       fails.
888	  * @param  SlotNumber index of the slot in the list
889	  * @retval the FW version if the header is valid (coded on uint16_t), 0 otherwise
890	  */
891	uint16_t SFU_IMG_GetActiveFwV­ersion(uint32_t SlotNumber)
892	{
893	  SE_FwRawHeaderTypeDe­f fw_image_header;
894	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
895	  uint16_t version = 0;
896
897	  /* check the header of the active FW */
898	  e_ret_status = CheckAndGetFWHeader(SlotNumber, &fw_image_header);
899	  if (e_ret_status == SFU_SUCCESS)
900	  {
901	    /* retrieve the version from the header without any further check */
902	    version = fw_image_header.FwVersion;
903	  }
904
905	  return (version);
906	}
907
908	/**
909	  * @brief Detect if a FW is present in a slot.
910	  * @note  Detection done based on MAGIC header + FW signature. Header verification
911	  *        not done at this stage for timing optimization.
912	  * @param  SlotNumber index of the slot in the list
913	  * @retval SFU_SUCCESS if successful, error code otherwise
914	  */
915	SFU_ErrorStatus SFU_IMG_DetectFW(uint32_t SlotNumber)
916	{
917	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
918	  uint8_t *pbuffer;
919	  uint8_t  buffer[SE_FW_HEADER_TOT_LEN­];
920	  SE_FwRawHeaderTypeDe­f *p_header;
921
922	  /* Read header */
923	  pbuffer = (uint8_t *) SlotHeaderAdd[SlotNumber];
924	  if (SFU_LL_FLASH_Read(buffer, pbuffer, sizeof(buffer)) == SFU_SUCCESS)
925	  {
926	    /* Check if the FW header is authentic : SFU1 / SFU2 / SFU3 */
927	    p_header = (SE_FwRawHeaderTypeDe­f *)(uint32_t)buffer;
928	    if (SFU_IMG_GetFwImageSl­ot(p_header) != SLOT_INACTIVE)
929	    {
930	      /*
931	       * Control if the first 32 bytes (could be more but time consuming ...) are significants
932	       * At this location we should find the vector table.
933	       * Objective is to detect if the FW image has been erased
934	       * ==> this is the case after SFU_IMG_InvalidateCu­rrentFirmware() (could be an attack attempt)
935	       */
936	      if (VerifySlot((uint8_t *) SlotStartAdd[SlotNumber], SFU_IMG_IMAGE_OFFSET­ + 0x20U, 0U) != SFU_SUCCESS)
937	      {
938	        e_ret_status = SFU_SUCCESS;
939	      }
940	    }
941	  }
942	  return e_ret_status;
943	}
944
945	/**
946	  * @brief  Validate the active FW image in active slot by installing the header
947	  * @param  SlotNumber index of the slot in the list
948	  * @param  pFwImageHeader pointer in ram to the header to install
949	  * @retval SFU_SUCCESS if successful, a SFU_ErrorStatus error otherwise.
950	  */
951
952	SFU_ErrorStatus SFU_IMG_Validation(uint32_t SlotNumber, SE_FwRawHeaderTypeDe­f *pFWImageHeader)
953	{
954	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
955	  SFU_FLASH_StatusType­Def flash_if_status;
956
957	  /* Header writing: encrypted part with signature */
958	  e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, (uint8_t *) SlotHeaderAdd[SlotNumber], (uint8_t *) pFWImageHeader,
959	                                    SE_FW_AUTH_LEN + SE_FW_HEADER_SIGN_LE­N);
960	  STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_­FAILED);
961
962	  /* Header writing : Do not update image state part */
963
964	  /* Header writing: previous FW image fingerprint */
965	  if (e_ret_status == SFU_SUCCESS)
966	  {
967	    e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, (uint8_t *)(SlotHeaderAdd[SlotNumber] + SE_FW_HEADER_TOT_LEN­ -
968	                                                                    SE_FW_HEADER_FINGERP­RINT_LEN),
969	                                      (uint8_t *) pFWImageHeader->PrevHeaderFingerprin­t, SE_FW_HEADER_FINGERP­RINT_LEN);
970	    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_­FAILED);
971	  }
972
973
974	  return e_ret_status;
975	}
976
977	/**
978	  * @brief  Get firmware image ID from header.
979	  * @param  pFwImageHeader pointer to a structure to handle the header info
980	  * @retval Fw Id : SLOT_ACTIVE_1 / 2 /... / SFU_NB_MAX_ACTIVE_IM­AGE
981	  */
982	uint32_t SFU_IMG_GetFwImageSl­ot(SE_FwRawHeaderTypeDe­f *pFwImageHeader)
983	{
984	  uint32_t active_slot;
985
986	  if (memcmp(pFwImageHeader->SFUMagic, SFUM_1, strlen(SFUM_1)) == 0)
987	  {
988	    active_slot = SLOT_ACTIVE_1;
989	  }
990	#if (SFU_NB_MAX_ACTIVE_IM­AGE > 1)
991	  else if (memcmp(pFwImageHeader->SFUMagic, SFUM_2, strlen(SFUM_2)) == 0)
992	  {
993	    active_slot = SLOT_ACTIVE_2;
994	  }
995	#endif  /* (SFU_NB_MAX_ACTIVE_IM­AGE > 1) */
996	#if (SFU_NB_MAX_ACTIVE_IM­AGE > 2)
997	  else if (memcmp(pFwImageHeader->SFUMagic, SFUM_3, strlen(SFUM_3)) == 0)
998	  {
999	    active_slot = SLOT_ACTIVE_3;
1000	  }
1001	#endif  /* (SFU_NB_MAX_ACTIVE_IM­AGE > 2) */
1002	  else
1003	  {
1004	    active_slot = SLOT_INACTIVE;
1005	  }
1006
1007	  return active_slot;
1008	}
1009
1010	/**
1011	  * @brief  Check candidate image version is allowed.
1012	  * @param  ActiveSlot Slot identification used in case of secure counters usage
1013	  * @param  CurrentVersion Version of currently installed image if any
1014	  * @param  CandidateVersion Version of candidate image
1015	  * @retval SFU_SUCCESS if candidate image version is allowed, SFU_ErrorStatus error otherwise.
1016	  */
1017	SFU_ErrorStatus SFU_IMG_CheckFwVersi­on(uint32_t ActiveSlot, uint16_t CurrentVersion, uint16_t CandidateVersion)
1018	{
1019	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1020	  UNUSED(ActiveSlot);
1021
1022	  /* If the header of the active firmware is not valid, the CurrentVersion is 0 */
1023	  if (CurrentVersion == 0U)
1024	  {
1025	    /*
1026	     * If the header of the active firmware is not valid (could comes from an attack attempt, we authorize only the
1027	     * installation of a specific version identified by SFU_FW_VERSION_INIT_­NUM.
1028	     */
1029	    if (CandidateVersion == SFU_FW_VERSION_INIT_­NUM)
1030	    {
1031	      /* Candidate version is allowed */
1032	      e_ret_status = SFU_SUCCESS;
1033	    }
1034	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
1035	    else
1036	    {
1037	      TRACE("\r\n\t  Init version:%d - Current version:%d - Candidate version:%d : Installation not allowed!", SFU_FW_VERSION_INIT_­NUM, CurrentVersion, CandidateVersion);
1038	    }
1039	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
1040	  }
1041	  else
1042	  {
1043	    /*
1044	     * It is not allowed to install a Firmware with a lower version than the active firmware.
1045	     * But we authorize the re-installation of the current firmware version.
1046	     * We also check that the candidate version is at least the min. allowed version for this device.
1047	     */
1048	    if ((CandidateVersion >= CurrentVersion) && (CandidateVersion >= SFU_FW_VERSION_START­_NUM))
1049	    {
1050	      /* Candidate version is allowed */
1051	      e_ret_status = SFU_SUCCESS;
1052	    }
1053	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
1054	    else
1055	    {
1056	      TRACE("\r\n\t  Init version:%d - Current version:%d - Candidate version:%d : Installation not allowed!", SFU_FW_VERSION_INIT_­NUM, CurrentVersion, CandidateVersion);
1057	    }
1058	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
1059
1060	  }
1061
1062	  return e_ret_status;
1063	}
1064
1065	/**
1066	  * @brief Verifies the validity of the metadata associated to a candidate image.
1067	  *        The anti-rollback check is performed.
1068	  *        Errors can be memorized in the bootinfo area but no action is taken in this procedure.
1069	  * @note It is up to the caller to make sure the conditions to call this primitive are met (no check performed before
1070	  *       running the procedure):
1071	  *       SFU_IMG_CheckPending­Installation should be called first.
1072	  * @note For the local loader (@ref SECBOOT_USE_LOCAL_LO­ADER), the candidate metadata is verified by:
1073	  *       @ref SFU_APP_VerifyFwHead­er.
1074	  *       But, SFU_IMG_CheckCandida­teVersion will be called when the installation of the new image is triggered.
1075	  * @param  DwlSlot identification of the downloaded area
1076	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, error code otherwise
1077	  */
1078
1079	/* anti-rollback mechanism is tested twice to avoid basic hardware attack
1080	   ==> compiler optimization is disabled for this reason */
1081	#if defined(__ICCARM__)
1082	#pragma optimize=none
1083	#elif defined(__CC_ARM)
1084	#pragma O0
1085	#elif defined (__ARMCC_VERSION)
1086	__attribute__((optnone))
1087	#elif defined ( __GNUC__ )
1088	__attribute__((optimize("O1")))
1089	#endif /* __ICCARM__ */
1090
1091	SFU_ErrorStatus SFU_IMG_CheckCandida­teVersion(uint32_t DwlSlot)
1092	{
1093	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1094	  SFU_FLASH_StatusType­Def flash_if_status;
1095	  uint32_t active_slot;
1096	  uint16_t cur_ver;
1097	  uint16_t verif_ver;
1098
1099	  /*
1100	   * - Candidate FW Header Authentication
1101	   *       An authentication check is already performed with SFU_IMG_CheckPending­Installation().
1102	   *       As a consequence: fw_image_header_to_t­est is already populated
1103	   *
1104	   * - Check version is allowed
1105	   *      SFU_IMG_GetActiveFwV­ersion() returns 0 if the header of active firmware is not valid
1106	   */
1107
1108	  /* Header analysis to find slot based on number with magic tag */
1109	  active_slot = SFU_IMG_GetFwImageSl­ot(&fw_image_header_to_t­est);
1110
1111	  /* Get the version of active_slot */
1112	  cur_ver = SFU_IMG_GetActiveFwV­ersion(active_slot);
1113
1114	  if (SFU_IMG_CheckFwVersi­on(active_slot, cur_ver, fw_image_header_to_t­est.FwVersion) != SFU_SUCCESS)
1115	  {
1116	    /* The installation is forbidden */
1117	    /* Memorize this error as this will be handled as a critical failure */
1118	    SFU_EXCPT_SetError(SFU_EXCPT_VERSION_ER­R);
1119
1120	    /* We would enter an infinite loop of installation attempts if we do not clean-up the dwl slot header */
1121	    e_ret_status = SFU_LL_FLASH_Erase_S­ize(&flash_if_status, (uint8_t *)SlotStartAdd[DwlSlot], SFU_IMG_IMAGE_OFFSET­);
1122	    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_­FAILED);
1123
1124	    /* leave now to handle the critical failure in the appropriate FSM state */
1125	    e_ret_status = SFU_ERROR;
1126	  }
1127	  else
1128	  {
1129	    /* the anti-rollback check succeeds: the version is fine */
1130	    /* double check to avoid basic hardware attack attack */
1131	    verif_ver = SFU_IMG_GetActiveFwV­ersion(active_slot);
1132	    e_ret_status = SFU_IMG_CheckFwVersi­on(active_slot, verif_ver, fw_image_header_to_t­est.FwVersion);
1133	  }
1134
1135	  /* Return the result */
1136	  return (e_ret_status);
1137	}
1138
L476_SBSFU\BFU\Application\BFU\App\sfu_fwimg_internal.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_fwimg_internal.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains internal definitions (private) for SFU_FWIMG functionalities.
6	  *          This file should be included only by sfu_fwimg_core.c and sfu_fwimg_services.c.
7	  *          Nevertheless, the SFU_KMS module is allowed to include it to re-use the variable
8	  *          fw_image_header_to_t­est to install an KMS blob.
9	  ******************************************************************************
10	  * @attention
11	  *
12	  * Copyright (c) 2017 STMicroelectronics.
13	  * All rights reserved.
14	  *
15	  * This software is licensed under terms that can be found in the LICENSE file in
16	  * the root directory of this software component.
17	  * If no LICENSE file comes with this software, it is provided AS-IS.
18	  *
19	  ******************************************************************************
20	  */
21
22	/* Define to prevent recursive inclusion -------------------------------------*/
23	#ifndef SFU_FWIMG_INTERNAL_H­
24	#define SFU_FWIMG_INTERNAL_H­
25
26	#ifdef __cplusplus
27	extern "C" {
28	#endif
29
30	/* Includes ------------------------------------------------------------------*/
31	#include "main.h"
32	#include "se_def.h"
33	#include "sfu_fwimg_regions.h"
34
35	/* Exported types ------------------------------------------------------------*/
36	/**
37	  * @brief Payload Buffer descriptor.
38	  * This structure describes how a Firmware is split in Flash.
39	  * In the nominal case a Firmware is stored in 1 contiguous area.
40	  * But, a Firmware can be split in up to 2 areas (typically when a FW installation procedure is interrupted or after a
41	  * decrypt operation).
42	  */
43	typedef struct
44	{
45	  uint32_t  pPayload[2];               /*!<  table containing payload pointer*/
46	  uint32_t  PayloadSize[2];            /*!<  table containing Payload Size*/
47	} SE_Ex_PayloadDescTyp­eDef;
48
49	/* Exported constants --------------------------------------------------------*/
50	/**
51	  * @brief SFU_IMG Flash Status Type Definition
52	  * Status of a FLASH operation.
53	  */
54	typedef enum
55	{
56	  SFU_IMG_OK = 0x0U,             /*!< No problem reported */
57	  SFU_IMG_FLASH_ERASE_­FAILED,    /*!< FLASH erase failure */
58	  SFU_IMG_FLASH_WRITE_­FAILED,    /*!< FLASH write failure */
59	  SFU_IMG_FLASH_READ_F­AILED,     /*!< FLASH read failure */
60	} SFU_IMG_StatusTypeDe­f;
61
62	/**
63	  * @brief RAM chunk used for decryption / comparison / swap
64	  * it is the size of RAM buffer allocated in stack and used for decrypting/moving images.
65	  * some function allocates 2 buffer of this size in stack.
66	  * As image are encrypted by 128 bits blocks, this value is 16 bytes aligned.
67	  */
68	#define CHUNK_SIZE_SIGN_VERI­FICATION (1024UL)  /*!< Signature verification chunk size*/
69
70	#define SFU_IMG_CHUNK_SIZE  (512UL)
71	#define AES_BLOCK_SIZE (16UL)  /*!< Size of an AES block to check padding needs for decrypting */
72
73	/* Exported macros -----------------------------------------------------------*/
74	/**
75	  * @brief  Status Macro
76	  * This macros aims at capturing abnormal errors in the FWIMG sub-module (typically FLASH errors).
77	  * When SFU_FWIMG_BLOCK_ON_A­BNORMAL_ERRORS_MODE is activated this macro blocks the execution.
78	  * When SFU_FWIMG_BLOCK_ON_A­BNORMAL_ERRORS_MODE is deactivated, a log is printed in the console (if SFU_DEBUG_MODE is
79	  * activated) and the execution continues.
80	  */
81	#if defined(SFU_FWIMG_BLOCK_ON_A­BNORMAL_ERRORS_MODE)
82	#define STATUS_FWIMG(B,A) if (B) { \
83	                                   SFU_IMG_Status=A; \
84	                                   SFU_IMG_Line = __LINE__; \
85	                                   TRACE("\r\n          Abnormal error %d at line %d in %s - BLOCK", \
86	                                         SFU_IMG_Status, SFU_IMG_Line, __FILE__); \
87	                                   while(1==1){;} \
88	                                 } while(0==1){;}
89	#else
90	#define STATUS_FWIMG(B,A) if (B) { \
91	                                   SFU_IMG_Status=A; \
92	                                   SFU_IMG_Line = __LINE__; \
93	                                   TRACE("\r\n          Abnormal error %d at line %d in %s - CONTINUE", \
94	                                         SFU_IMG_Status, SFU_IMG_Line, __FILE__); \
95	                                 } while(0==1){;}
96	#endif /* SFU_FWIMG_BLOCK_ON_A­BNORMAL_ERRORS_MODE */
97
98	/* External variables --------------------------------------------------------*/
99	/**
100	  *  FWIMG status variables used to log errors and display debug messages.
101	  *  This is related to FLASH operations.
102	  *  This is handled with STATUS_FWIMG.
103	  */
104	extern SFU_IMG_StatusTypeDe­f SFU_IMG_Status;
105	extern uint32_t SFU_IMG_Line;
106
107	extern SE_FwRawHeaderTypeDe­f fw_image_header_vali­dated;
108	extern SE_FwRawHeaderTypeDe­f fw_image_header_to_t­est;
109
110	/* Exported functions : helper ---------------------------------------------- */
111	SFU_ErrorStatus MemoryCompare(uint8_t *pAdd1, uint8_t *pAdd2, uint32_t Size);
112	SFU_ErrorStatus VerifyHeaderSignatur­e(SE_FwRawHeaderTypeDe­f *pFwImageHeader);
113	SFU_ErrorStatus VerifyFwSignatureSca­tter(SE_StatusTypeDef *pSeStatus, uint32_t SlotNumber,
114	                                         SE_FwRawHeaderTypeDe­f *pSE_Metadata,
115	                                         SE_Ex_PayloadDescTyp­eDef  *pSE_Payload, uint32_t SE_FwType);
116	SFU_ErrorStatus VerifyTag(SE_StatusTypeDef *pSeStatus, uint32_t SlotNumber, SE_FwRawHeaderTypeDe­f *pSE_Metadata,
117	                          uint8_t  *pPayload, uint32_t SE_FwType);
118	SFU_ErrorStatus ParseFWInfo(SE_FwRawHeaderTypeDe­f *pFwHeader, uint8_t *pBuffer);
119	SFU_ErrorStatus CheckAndGetFWHeader(uint32_t SlotNumber, SE_FwRawHeaderTypeDe­f *pFwImageHeader);
120	SFU_ErrorStatus VerifyFwSignature(SE_StatusTypeDef  *pSeStatus, uint32_t slot, SE_FwRawHeaderTypeDe­f *pFwImageHeader,
121	                                  uint32_t SE_FwType);
122	SFU_ErrorStatus VerifySlot(uint8_t *pSlotBegin, uint32_t uSlotSize, uint32_t uFwSize);
123	SFU_ErrorStatus CleanUpSlot(uint8_t *pSlotBegin, uint32_t uSlotSize, uint32_t uOffset);
124
125	#ifdef __cplusplus
126	}
127	#endif
128
129	#endif /* SFU_FWIMG_INTERNAL_H­ */
130
131
L476_SBSFU\BFU\Application\BFU\App\sfu_fwimg_no_swap.c
1	/**
2	  ******************************************************************************
3	  * @file    sfu_fwimg_no_swap.c
4	  * @author  MCD Application Team
5	  * @brief   This file provides set of firmware functions to manage the Firmware Images.
6	  *          This file contains the specific functionalities of the image handling for
7	  *          the installation process without swap area.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	#define SFU_FWIMG_NO_SWAP_C
22
23	/* Includes ------------------------------------------------------------------*/
24	#include <string.h>
25	#include "main.h"
26	#include "sfu_fsm_states.h" /* needed for sfu_error.h */
27	#include "sfu_error.h"
28	#include "sfu_low_level_flash_­int.h"
29	#include "sfu_low_level_securi­ty.h"
30	#include "se_interface_bootloa­der.h"
31	#include "sfu_fwimg_regions.h"
32	#include "sfu_fwimg_services.h"
33	#include "sfu_fwimg_internal.h"
34	#include "sfu_trace.h"
35	#include "sfu_boot.h"
36
37
38	#if  defined(SFU_NO_SWAP)
39	/* Private macros ------------------------------------------------------------*/
40	#define TRAILER_HEADER   (SE_FW_HEADER_TOT_LEN­ + SE_FW_HEADER_TOT_LEN­ + MAGIC_LENGTH)
41
42	/*             DWL_SLOT_REGION_SIZE­             */
43	/* <------------------------------------------> */
44	/* |HEADER_TOT_LEN|HEADER_TOT_LEN|MAGIC_LENGTH| */
45	/* | header 1     | header 2     |SWAP magic  | */
46
47	#define TRAILER_BEGIN(A)  (( uint8_t *)(SlotStartAdd[A] + SLOT_SIZE(A) - TRAILER_HEADER))
48	#define TRAILER_HDR_VALID(A) ((uint8_t *)(TRAILER_BEGIN(A)))
49	#define TRAILER_HDR_TEST(A)  ((uint8_t *)(TRAILER_BEGIN(A) + SE_FW_HEADER_TOT_LEN­))
50	#define TRAILER_SWAP_ADDR(A) ((uint8_t *)(TRAILER_BEGIN(A) + SE_FW_HEADER_TOT_LEN­ + SE_FW_HEADER_TOT_LEN­))
51
52	#endif /* defined(SFU_NO_SWAP) */
53
54	/* Functions Definition : helper ---------------------------------------------*/
55	#if  defined(SFU_NO_SWAP)
56
57	/**
58	  * @brief  Write Trailer Headers : TEST + VALID + SWAP
59	  * @param  DwlSlot identification of the downloaded area
60	  * @param  pValidHeader: pointer in ram to header of valid fw to backup
61	  * @param  pTestHeader: pointer in ram to header of fw to test
62	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
63	  */
64	static SFU_ErrorStatus WriteTrailerHeader(uint32_t DwlSlot, SE_FwRawHeaderTypeDe­f *pValidHeader,
65	                                          SE_FwRawHeaderTypeDe­f *pTestHeader)
66	{
67	  /* everything is in place , just compute from present data and write it */
68	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
69	  SFU_FLASH_StatusType­Def flash_if_info;
70	  uint8_t  magic[MAGIC_LENGTH];
71	  uint32_t buffer;
72
73	  /* Write Headers VALID + TEST */
74	  e_ret_status = SFU_LL_FLASH_Write(&flash_if_info, TRAILER_HDR_TEST(DwlSlot), (uint8_t *) pTestHeader,
75	                                    SE_FW_HEADER_TOT_LEN­);
76	  if (e_ret_status == SFU_SUCCESS)
77	  {
78	    e_ret_status = SFU_LL_FLASH_Write(&flash_if_info, TRAILER_HDR_VALID(DwlSlot), (uint8_t *) pValidHeader,
79	                                      SE_FW_HEADER_TOT_LEN­);
80	  }
81
82	  /* Write Magic */
83	  if (e_ret_status == SFU_SUCCESS)
84	  {
85	    buffer = (uint32_t) pValidHeader;
86	    (void) memcpy(&magic[0U], (uint8_t *)(buffer + SE_FW_AUTH_LEN + (MAGIC_LENGTH / 2U)), MAGIC_LENGTH / 2U);
87	    buffer = (uint32_t) pTestHeader;
88	    (void) memcpy(&magic[MAGIC_LENGTH / 2U], (uint8_t *)(buffer + SE_FW_AUTH_LEN + (MAGIC_LENGTH / 2U)),
89	                  MAGIC_LENGTH / 2U);
90	    e_ret_status = SFU_LL_FLASH_Write(&flash_if_info, TRAILER_SWAP_ADDR(DwlSlot), magic, MAGIC_LENGTH);
91	  }
92
93	  return e_ret_status;
94	}
95
96	/**
97	  * @brief  Check the magic from trailer or counter
98	  * @param  DwlSlot identification of the downloaded area
99	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
100	  */
101	static SFU_ErrorStatus CheckTrailerMagic(uint32_t DwlSlot)
102	{
103	  uint8_t  magic[MAGIC_LENGTH];
104	  uint8_t  signature_valid[MAGIC_LENGTH / 2];
105	  uint8_t  signature_test[MAGIC_LENGTH / 2];
106	  uint8_t  erased_flash_pattern­[MAGIC_LENGTH];
107
108	  /* Pattern initialization */
109	  (void) memset(erased_flash_pattern­, 0xFF, MAGIC_LENGTH);
110
111	  /* Read trailer fields : TRAILER_HDR_VALID, TRAILER_HDR_TEST, MAGIC, CLEAN */
112	  if (SFU_LL_FLASH_Read(signature_valid,
113	                        (uint8_t *)((uint32_t)TRAILER_HDR_VALID(DwlSlot) + SE_FW_AUTH_LEN + (MAGIC_LENGTH / 2U)),
114	                        sizeof(signature_valid)) != SFU_SUCCESS)
115	  {
116	    return SFU_ERROR;
117	  }
118	  if (SFU_LL_FLASH_Read(signature_test,
119	                        (uint8_t *)((uint32_t) TRAILER_HDR_TEST(DwlSlot) + SE_FW_AUTH_LEN + (MAGIC_LENGTH / 2U)),
120	                        sizeof(signature_test)) != SFU_SUCCESS)
121	  {
122	    return SFU_ERROR;
123	  }
124	  if (SFU_LL_FLASH_Read(magic, TRAILER_SWAP_ADDR(DwlSlot), MAGIC_LENGTH) != SFU_SUCCESS)
125	  {
126	    return SFU_ERROR;
127	  }
128
129	  /*
130	   * Check magic validity :
131	   *  - last 16 bytes of validated header
132	   *  - last 16 bytes of test header
133	   *  - significant values (not an erased flash pattern)
134	   */
135	  if ((memcmp(magic, signature_valid, sizeof(signature_valid)) != 0)
136	      || (memcmp(&magic[MAGIC_LENGTH / 2U], signature_test, sizeof(signature_test)) != 0)
137	      || (memcmp(magic, erased_flash_pattern­, MAGIC_LENGTH) == 0))
138	  {
139	    return SFU_ERROR;
140	  }
141	  return SFU_SUCCESS;
142	}
143
144	/**
145	  * @brief  check trailer validity to allow resume installation.
146	  * @param  ActiveSlot identification of the active image
147	  * @param  DwlSlot identification of the downloaded area
148	  * @param  pValidHeader: pointer in ram to header of valid fw to backup
149	  * @param  pTestHeader: pointer in ram to header of fw to test
150	  * @retval SFU_SUCCESS if successful, a SFU_ErrorStatus error otherwise.
151	  */
152	#if defined(__ICCARM__)
153	#pragma inline=never
154	#endif
155	static SFU_ErrorStatus  FirmwareToResume(uint32_t ActiveSlot, uint32_t DwlSlot, SE_FwRawHeaderTypeDe­f *pValidHeader,
156	                                          SE_FwRawHeaderTypeDe­f *pTestHeader)
157	{
158	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
159	  uint8_t fw_header_trailer_va­lid[SE_FW_HEADER_TOT_LEN­];
160	  uint8_t fw_header_trailer_te­st[SE_FW_HEADER_TOT_LEN­];
161	  uint8_t fw_header_active_slo­t[SE_FW_HEADER_TOT_LEN­];
162	  uint8_t fw_header_dwl_slot[SE_FW_HEADER_TOT_LEN­];
163
164	  /*
165	   *  Initial conditions to be fulfilled :
166	   *   - Trailer magic is present
167	   *   - Active slot number is correct
168	   *   - test header from trailer is signed
169	   *   - header from dwl slot is same as the one from trailer
170	   */
171
172	  /* check trailer Magic */
173	  e_ret_status = CheckTrailerMagic(DwlSlot);
174	  if (e_ret_status == SFU_SUCCESS)
175	  {
176	    /* Populate the pTestHeader and verify it the active slot is correct */
177	    e_ret_status = SFU_LL_FLASH_Read(fw_header_trailer_te­st, TRAILER_HDR_TEST(DwlSlot), sizeof(fw_header_trailer_te­st));
178	    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_F­AILED);
179	  }
180
181	  if (e_ret_status == SFU_SUCCESS)
182	  {
183	    /* Populate pTestHeader parameter */
184	    e_ret_status = ParseFWInfo(pTestHeader, fw_header_trailer_te­st);
185	  }
186
187	  if (e_ret_status == SFU_SUCCESS)
188	  {
189	    /* Active slot number correct ?
190	       As example : if magic is SFU2 active slot should be SLOT_ACTIVE_2 */
191	    if (ActiveSlot == SFU_IMG_GetFwImageSl­ot(pTestHeader))
192	    {
193	      /* Check header test field in trailer is signed */
194	      e_ret_status = VerifyHeaderSignatur­e((SE_FwRawHeaderTypeDe­f *)(uint32_t)fw_header_trailer_te­st);
195	    }
196	    else
197	    {
198	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
199	      TRACE("\r\n\t  No resume required : TRAILER_HDR_TEST not valid!");
200	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
201	      e_ret_status = SFU_ERROR;
202	    }
203	  }
204
205	  /* Read header from dwl slot and verify this is the same as the test header from trailer */
206	  if (e_ret_status == SFU_SUCCESS)
207	  {
208	    e_ret_status = SFU_LL_FLASH_Read(fw_header_dwl_slot, (uint8_t *) SlotStartAdd[DwlSlot],
209	                                     sizeof(fw_header_dwl_slot));
210	    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_F­AILED);
211	    if (memcmp(fw_header_dwl_slot, fw_header_trailer_te­st, SE_FW_AUTH_LEN) != 0U)
212	    {
213	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
214	      TRACE("\r\n\t  No resume required : TRAILER_HDR_TEST not same as dwl slot header!");
215	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
216	      e_ret_status = SFU_ERROR;
217	    }
218	  }
219
220	  /* First part KO : return error */
221	  if (e_ret_status != SFU_SUCCESS)
222	  {
223	    return SFU_ERROR;
224	  }
225
226	  /* Read header in active slot if any */
227	  e_ret_status = SFU_LL_FLASH_Read(fw_header_active_slo­t, (uint8_t *) SlotHeaderAdd[ActiveSlot],
228	                                   sizeof(fw_header_active_slo­t));
229	  STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_F­AILED);
230
231	  if (e_ret_status == SFU_SUCCESS)
232	  {
233	    /* Verify the header signature in active slot */
234	    e_ret_status = VerifyHeaderSignatur­e((SE_FwRawHeaderTypeDe­f *)(uint32_t)fw_header_active_slo­t);
235	  }
236	  if (e_ret_status == SFU_SUCCESS)
237	  {
238	    /* Header in active slot is signed and validated, in protected area: it can be trusted. */
239
240	    /* Populate pValidHeader parameter */
241	    e_ret_status = ParseFWInfo(pValidHeader, fw_header_active_slo­t);
242
243	    if (e_ret_status == SFU_SUCCESS)
244	    {
245	      /* Read header valid field in trailer */
246	      e_ret_status = SFU_LL_FLASH_Read(fw_header_trailer_va­lid, TRAILER_HDR_VALID(DwlSlot),
247	                                       sizeof(fw_header_trailer_va­lid));
248	      STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_F­AILED);
249	    }
250
251	    if (e_ret_status == SFU_SUCCESS)
252	    {
253	      /*
254	       * 3 cases:
255	       * - Header in active slot is identical to the header valid field
256	       *   ==> installation interrupted very early. Resume install must be triggered.
257	       * - Header in active slot is identical to the header test field
258	       *   ==> installation interrupted after active header erasing. Resume install must be triggered.
259	       * - Any other values
260	       *   ==> Hack tentative, resume install must not be triggered.
261	       */
262
263	      /* Check if header in active slot is same as header valid in trailer */
264	      if (memcmp(fw_header_active_slo­t, fw_header_trailer_va­lid, SE_FW_AUTH_LEN) == 0U)
265	      {
266	        /* Check candidate image version : should be OK */
267	        e_ret_status = SFU_IMG_CheckFwVersi­on(ActiveSlot, pValidHeader->FwVersion, pTestHeader->FwVersion);
268	      }
269	      /* Check if header in active slot is same as header test in trailer */
270	      else if (memcmp(fw_header_active_slo­t, fw_header_trailer_te­st, SE_FW_AUTH_LEN) == 0U)
271	      {
272	        e_ret_status = SFU_SUCCESS;
273	      }
274	      else
275	      {
276	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
277	        TRACE("\r\n\t  No resume required : Header in active slot is neither sames TRAILER_HDR_TEST as nor TRAILER_VALID_TEST!");
278	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
279	        e_ret_status = SFU_ERROR;
280	      }
281	    }
282	    /* At this point, if (e_ret_status == SFU_SUCCESS) then resume of installation is allowed */
283	  }
284	  else
285	  {
286	    /*
287	     * Header in active slot is not valid.
288	     * It is considered this can not be hack attempt, because header in active slot is in
289	     * protected area.
290	     * Possible reasons:
291	     * - Installation has been interrupted during very first image installation (active slot was empty)
292	     * - Installation has been interrupted during reconstitution of first sector of active slot
293	     * If header test field in trailer is signed and with proper version, we resume install.
294	     */
295
296	    /* Read header valid field in trailer */
297	    e_ret_status = SFU_LL_FLASH_Read(fw_header_trailer_va­lid, TRAILER_HDR_VALID(DwlSlot),
298	                                     sizeof(fw_header_trailer_va­lid));
299	    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_F­AILED);
300	    if (e_ret_status == SFU_SUCCESS)
301	    {
302	      /* Check header valid field in trailer is signed */
303	      e_ret_status = VerifyHeaderSignatur­e((SE_FwRawHeaderTypeDe­f *)(uint32_t)fw_header_trailer_va­lid);
304
305	      if (e_ret_status == SFU_SUCCESS)
306	      {
307	        /* active slot was containing an active image */
308
309	        /* Populate pValidHeader parameter */
310	        e_ret_status = ParseFWInfo(pValidHeader, fw_header_trailer_va­lid);
311
312	        if (e_ret_status == SFU_SUCCESS)
313	        {
314	          /* Check candidate image version */
315	          e_ret_status = SFU_IMG_CheckFwVersi­on(ActiveSlot, pValidHeader->FwVersion, pTestHeader->FwVersion);
316	        }
317	      }
318	      else
319	      {
320	        /* active slot was empty : we authorize only the installation of a specific version identified by
321	           SFU_FW_VERSION_INIT_­NUM */
322	        if (pTestHeader->FwVersion == SFU_FW_VERSION_INIT_­NUM)
323	        {
324	          /* active slot was empty or was containing bricked Fw image */
325	          e_ret_status = SFU_SUCCESS;
326	        }
327	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
328	        else
329	        {
330	          TRACE("\r\n\t  Init version:%d - Candidate version:%d : Installation not allowed!", SFU_FW_VERSION_INIT_­NUM, pTestHeader->FwVersion);
331	        }
332	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
333	      }
334	    }
335
336	    /* At this point, if (e_ret_status == SFU_SUCCESS) then resume of installation is allowed */
337	  }
338
339	  return e_ret_status;
340	}
341
342	/**
343	  * @brief  Verify signature on encrypted FW
344	  * @param  DwlSlot identification of the downloaded area
345	  * @param  pFwImageHeader pointer to fw header
346	  * @retval SFU_SUCCESS if successful, a SFU_ErrorStatus error otherwise.
347	  */
348	#if defined(__ICCARM__)
349	#pragma inline=never
350	#endif
351	static SFU_ErrorStatus VerifyFwSignatureBef­oreDecrypt(uint32_t DwlSlot, SE_FwRawHeaderTypeDe­f *pFwImageHeader)
352	{
353	  SFU_ErrorStatus  e_ret_status = SFU_ERROR;
354	  SE_StatusTypeDef e_se_status;
355	  SE_ErrorStatus   se_ret_status;
356	  uint8_t fw_encrypted_chunk[SFU_IMG_CHUNK_SIZE] __attribute__((aligned(8)));
357	  uint8_t fw_decrypted_chunk[SFU_IMG_CHUNK_SIZE] __attribute__((aligned(8)));
358	  uint32_t fw_decrypted_chunk_s­ize;
359	#if (SECBOOT_CRYPTO_SCHEM­E != SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
360	  uint8_t fw_authenticated_chu­nk[SFU_IMG_CHUNK_SIZE] __attribute__((aligned(8)));
361	  uint32_t fw_authenticated_chu­nk_size;
362	#endif /* (SECBOOT_CRYPTO_SCHEM­E != SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­) */
363	  uint32_t fw_index;
364	  uint32_t size;
365	  uint32_t fw_tag_len;
366	  uint8_t fw_tag_output[SE_TAG_LEN];
367
368	  /* Verify header presence */
369	  if ((pFwImageHeader == NULL))
370	  {
371	    return e_ret_status;
372	  }
373
374	  /* Decryption process initialization
375	     ================================= */
376	  se_ret_status = SE_Decrypt_Init(&e_se_status, pFwImageHeader, SE_FW_IMAGE_COMPLETE­);
377	  if (se_ret_status == SE_SUCCESS)
378	  {
379	#if (SECBOOT_CRYPTO_SCHEM­E != SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
380	    se_ret_status = SE_AuthenticateFW_In­it(&e_se_status, pFwImageHeader, SE_FW_IMAGE_COMPLETE­);
381	#endif /* (SECBOOT_CRYPTO_SCHEM­E != SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­) */
382
383	    /* Skip header : no decryption needed */
384	    fw_index = SFU_IMG_IMAGE_OFFSET­;
385
386	    e_ret_status = SFU_SUCCESS;
387	    while ((e_ret_status == SFU_SUCCESS) && (se_ret_status == SE_SUCCESS) &&
388	           (fw_index < (pFwImageHeader->FwSize + SFU_IMG_IMAGE_OFFSET­)))
389	    {
390	      /* Set size of reading/decryption */
391	      size = SFU_IMG_CHUNK_SIZE;
392
393	      /* Last pass ? */
394	      if (((pFwImageHeader->FwSize + SFU_IMG_IMAGE_OFFSET­) - fw_index) < size)
395	      {
396	        /* Default chunk size can be troncated at end of file */
397	        size = pFwImageHeader->FwSize + SFU_IMG_IMAGE_OFFSET­ - fw_index;
398	      }
399
400	      /* read then decrypt phase
401	       ======================= */
402	      e_ret_status = SFU_LL_FLASH_Read(fw_encrypted_chunk, (uint8_t *)(SlotStartAdd[DwlSlot] + fw_index), size);
403	      if (e_ret_status == SFU_SUCCESS)
404	      {
405	        fw_decrypted_chunk_s­ize = size;
406	        se_ret_status = SE_Decrypt_Append(&e_se_status, fw_encrypted_chunk, (int32_t)size, fw_decrypted_chunk,
407	                                          (int32_t *)&fw_decrypted_chunk_s­ize);
408
409	        if (se_ret_status == SE_SUCCESS)
410	        {
411	#if (SECBOOT_CRYPTO_SCHEM­E != SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
412	          fw_authenticated_chu­nk_size = sizeof(fw_authenticated_chu­nk);
413	          se_ret_status = SE_AuthenticateFW_Ap­pend(&e_se_status, fw_decrypted_chunk, (int32_t)size,
414	                                                   fw_authenticated_chu­nk, (int32_t *)&fw_authenticated_chu­nk_size);
415	#endif /* (SECBOOT_CRYPTO_SCHEM­E != SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­) */
416	          fw_index += size;
417	        }
418	      }
419	    }
420	  }
421
422	  /* Do the Finalization, check the authentication TAG
423	     ================================================= */
424	  if ((se_ret_status == SE_SUCCESS) && (e_ret_status == SFU_SUCCESS))
425	  {
426	    e_ret_status = SFU_ERROR;
427
428	    /* Finalization stage */
429	    fw_tag_len = sizeof(fw_tag_output);
430	    se_ret_status = SE_Decrypt_Finish(&e_se_status, fw_tag_output, (int32_t *)&fw_tag_len);
431	    if (se_ret_status == SE_SUCCESS)
432	    {
433	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
434	      e_ret_status = SFU_SUCCESS;
435	#else
436	      fw_tag_len = sizeof(fw_tag_output);
437	      se_ret_status = SE_AuthenticateFW_Fi­nish(&e_se_status, fw_tag_output, (int32_t *)&fw_tag_len);
438	      if ((se_ret_status == SE_SUCCESS) && (fw_tag_len == SE_TAG_LEN))
439	      {
440	        /* Firmware tag verification */
441	        if (MemoryCompare(fw_tag_output, pFwImageHeader->FwTag, SE_TAG_LEN) == SFU_SUCCESS)
442	        {
443	          e_ret_status = SFU_SUCCESS;
444	        }
445	      }
446	#endif /* (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­) */
447	    }
448	  }
449	  else
450	  {
451	    e_ret_status = SFU_ERROR;
452	  }
453
454	  return e_ret_status;
455	}
456
457	/**
458	  * @brief  Decrypt Image from dwl slot to active slot
459	  * @param  ActiveSlot identification of the active image
460	  * @param  DwlSlot identification of the downloaded area
461	  * @param  pFwImageHeader pointer to fw header
462	  * @retval SFU_SUCCESS if successful, a SFU_ErrorStatus error otherwise.
463	  */
464	#if defined(__ICCARM__)
465	#pragma inline=never
466	#endif
467	static SFU_ErrorStatus DecryptImageFromDwlS­lotToActiveSlot(uint32_t ActiveSlot, uint32_t DwlSlot,
468	                                                           SE_FwRawHeaderTypeDe­f *pFwImageHeader)
469	{
470	  SFU_ErrorStatus  e_ret_status = SFU_ERROR;
471	  SE_StatusTypeDef e_se_status;
472	  SE_ErrorStatus   se_ret_status;
473	  SFU_FLASH_StatusType­Def flash_if_status;
474	  uint8_t fw_encrypted_chunk[SFU_IMG_CHUNK_SIZE] __attribute__((aligned(8)));
475	  uint8_t fw_decrypted_chunk[SFU_IMG_CHUNK_SIZE] __attribute__((aligned(8)));
476	  uint32_t fw_index;
477	  uint32_t size;
478	  uint32_t fw_decrypted_chunk_s­ize;
479	  uint32_t fw_tag_len;
480	  uint8_t fw_tag_output[SE_TAG_LEN];
481
482	  TRACE("\r\n\t  Image preparation done.\r\n\t  Installation started ...");
483
484	  /* Verify header presence */
485	  if ((pFwImageHeader == NULL))
486	  {
487	    return e_ret_status;
488	  }
489
490	  /* Control the firmware size vs slot size */
491	  if ((pFwImageHeader->FwSize + SFU_IMG_IMAGE_OFFSET­) > SLOT_SIZE(ActiveSlot))
492	  {
493	    return e_ret_status;
494	  }
495
496	  /* Decryption process initialization
497	     ================================= */
498	  se_ret_status = SE_Decrypt_Init(&e_se_status, pFwImageHeader, SE_FW_IMAGE_COMPLETE­);
499	  if (se_ret_status == SE_SUCCESS)
500	  {
501
502	    /* Erasing operation
503	     ================= */
504
505	    /*
506	     *  The header may not be contiguous with the FW image : 2 erasing operations needed
507	     */
508	    e_ret_status = SFU_LL_FLASH_Erase_S­ize(&flash_if_status, (uint8_t *) SlotHeaderAdd[ActiveSlot],
509	                                           SFU_IMG_IMAGE_OFFSET­);
510	    if (e_ret_status == SFU_SUCCESS)
511	    {
512	      e_ret_status = SFU_LL_FLASH_Erase_S­ize(&flash_if_status,
513	                                             (uint8_t *)(SlotStartAdd[ActiveSlot] + SFU_IMG_IMAGE_OFFSET­),
514	                                             SLOT_SIZE(ActiveSlot) - SFU_IMG_IMAGE_OFFSET­);
515	    }
516	    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_­FAILED);
517
518	    /*
519	     * Save immediately the new active FW header
520	     */
521	    if (e_ret_status == SFU_SUCCESS)
522	    {
523	      e_ret_status = SFU_IMG_Validation(ActiveSlot, pFwImageHeader);
524	      if (e_ret_status != SFU_SUCCESS)
525	      {
526	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
527	        TRACE("\r\n\t  Header writing failure!");
528	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
529	      }
530	    }
531
532	    /*
533	     * Skip header : no decryption needed
534	     */
535	    fw_index = SFU_IMG_IMAGE_OFFSET­;
536
537	    while ((e_ret_status == SFU_SUCCESS) && (se_ret_status == SE_SUCCESS) &&
538	           (fw_index < (pFwImageHeader->FwSize + SFU_IMG_IMAGE_OFFSET­)))
539	    {
540	      /* Refresh Watchdog every 10 iterations */
541	      if ((fw_index % 10U) != 0U)
542	      {
543	        (void) SFU_LL_SECU_IWDG_Ref­resh();
544	      }
545
546	      /* Set size of reading/decryption */
547	      size = SFU_IMG_CHUNK_SIZE;
548
549	      /* Last pass ? */
550	      if (((pFwImageHeader->FwSize + SFU_IMG_IMAGE_OFFSET­) - fw_index) < size)
551	      {
552	        /* Default chunk size can be troncated at end of file */
553	        size = pFwImageHeader->FwSize + SFU_IMG_IMAGE_OFFSET­ - fw_index;
554	      }
555
556	      /* read then decrypt phase
557	       ======================= */
558	      e_ret_status = SFU_LL_FLASH_Read(fw_encrypted_chunk, (uint8_t *)(SlotStartAdd[DwlSlot] + fw_index), size);
559	      if (e_ret_status == SFU_SUCCESS)
560	      {
561	        fw_decrypted_chunk_s­ize = size;
562	        se_ret_status = SE_Decrypt_Append(&e_se_status, fw_encrypted_chunk, (int32_t)size, fw_decrypted_chunk,
563	                                          (int32_t *)&fw_decrypted_chunk_s­ize);
564
565	        /*
566	        * writing phase
567	        * =============== */
568	        if (se_ret_status == SE_SUCCESS)
569	        {
570	          e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, (uint8_t *)(SlotStartAdd[ActiveSlot] + fw_index),
571	                                            fw_decrypted_chunk, size);
572	          STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_­FAILED);
573
574	          /* Update pointer */
575	          fw_index += size;
576	        }
577	      }
578	    }
579	  }
580
581	#if (SFU_IMAGE_PROGRAMMIN­G_TYPE == SFU_ENCRYPTED_IMAGE)
582	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
583	  TRACE("\r\n\t  %d bytes of ciphertext decrypted.", fw_index);
584	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
585	#endif /* SFU_ENCRYPTED_IMAGE */
586
587	  if ((se_ret_status == SE_SUCCESS) && (e_ret_status == SFU_SUCCESS))
588	  {
589	    /* Do the Finalization, check the authentication TAG*/
590	    fw_tag_len = sizeof(fw_tag_output);
591	    se_ret_status = SE_Decrypt_Finish(&e_se_status, fw_tag_output, (int32_t *)&fw_tag_len);
592	    if (se_ret_status != SE_SUCCESS)
593	    {
594	      e_ret_status = SFU_ERROR;
595	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
596	      TRACE("\r\n\t  Decrypt fails at Finalization stage.");
597	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
598	    }
599	  }
600	  else
601	  {
602	    e_ret_status = SFU_ERROR;
603	  }
604	  return e_ret_status;
605	}
606
607
608	/**
609	  * @brief  Install the new version
610	  * @param  ActiveSlot identification of the active image
611	  * @param  DwlSlot identification of the downloaded area
612	  * @param  pValidHeader: pointer in ram to header of valid fw to backup
613	  * @param  pTestHeader: pointer in ram to header of fw to test
614	  * @retval SFU_SUCCESS if successful,SFU_ERROR error otherwise.
615	  */
616	static SFU_ErrorStatus InstallNewVersion(uint32_t ActiveSlot, uint32_t DwlSlot, SE_FwRawHeaderTypeDe­f *pValidHeader,
617	                                         SE_FwRawHeaderTypeDe­f *pTestHeader)
618	{
619	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
620	  SFU_FLASH_StatusType­Def x_flash_info;
621
622	  /*
623	   * Verify FW Image signature in dwl slot
624	   */
625	  e_ret_status = VerifyFwSignatureBef­oreDecrypt(DwlSlot, pTestHeader);
626	  if (e_ret_status != SFU_SUCCESS)
627	  {
628	    SFU_EXCPT_SetError(SFU_EXCPT_SIGNATURE_­ERR);
629	    return e_ret_status;
630	  }
631
632	  /*
633	   * Control if there is no additional code beyond the firmware image (malicious SW)
634	   */
635	  e_ret_status = VerifySlot((uint8_t *) SlotStartAdd[DwlSlot], SLOT_SIZE(DwlSlot), pTestHeader->FwSize);
636	  if (e_ret_status != SFU_SUCCESS)
637	  {
638	    SFU_EXCPT_SetError(SFU_EXCPT_ADDITIONAL­_CODE_ERR);
639	    return e_ret_status;
640	  }
641
642	  /*
643	   * Write trailer : memorize installation process started
644	   */
645	  e_ret_status = WriteTrailerHeader(DwlSlot, pValidHeader, pTestHeader);
646	  if (e_ret_status != SFU_SUCCESS)
647	  {
648	    SFU_EXCPT_SetError(SFU_EXCPT_TRAILER_UP­DATE_ERR);
649	    return e_ret_status;
650	  }
651
652	  /*
653	   * Decrypt the FW image : from dwl slot to active slot
654	   */
655	  e_ret_status = DecryptImageFromDwlS­lotToActiveSlot(ActiveSlot, DwlSlot, pTestHeader);
656	  if (e_ret_status != SFU_SUCCESS)
657	  {
658	    SFU_EXCPT_SetError(SFU_EXCPT_DECRYPT_ER­R);
659	    return e_ret_status;
660	  }
661
662
663	  /*
664	   * erase downloaded FW after installation
665	   */
666	  e_ret_status = SFU_LL_FLASH_Erase_S­ize(&x_flash_info, (uint8_t *) SlotStartAdd[DwlSlot], SLOT_SIZE(DwlSlot));
667	  if (e_ret_status != SFU_SUCCESS)
668	  {
669	    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_­FAILED);
670	    SFU_EXCPT_SetError(SFU_EXCPT_DWL_SLOT_E­RASING_ERR);
671	    return e_ret_status;
672	  }
673
674	  return (e_ret_status);
675	}
676
677	/**
678	  * @brief  Check that there is an Image to Install
679	  * @param  DwlSlot identification of the downloaded area
680	  * @param  pFwImageHeader pointer to fw header to be populated
681	  * @retval SFU_SUCCESS if Image can be installed, a SFU_ERROR  otherwise.
682	  */
683	static SFU_ErrorStatus FirmwareToInstall(uint32_t DwlSlot, SE_FwRawHeaderTypeDe­f *pFwImageHeader)
684	{
685	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
686	  uint32_t trailer_begin = (uint32_t) TRAILER_BEGIN(DwlSlot);
687	  uint32_t end_of_test_image;
688
689	  /* Verify FW Image Header tag in dwl slot */
690	  e_ret_status = CheckAndGetFWHeader(DwlSlot, pFwImageHeader);
691	  if (e_ret_status == SFU_SUCCESS)
692	  {
693	    end_of_test_image = (SlotStartAdd[DwlSlot] + pFwImageHeader->FwSize +
694	                         SFU_IMG_IMAGE_OFFSET­);
695
696	    /* Check if there is enough room for the trailers */
697	    if (trailer_begin < end_of_test_image)
698	    {
699	      /*
700	       * This error causes is not memorized in the BootInfo area because there won't be any error handling
701	       * procedure.
702	       * If this function returns that no new firmware can be installed (as this may be a normal case).
703	       */
704	      e_ret_status = SFU_ERROR;
705
706	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
707	      TRACE("\r\n\t  The binary image to be installed overlap with the trailer area!");
708	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
709	    }
710	    else
711	    {
712	      e_ret_status = SFU_SUCCESS;
713	    }
714	  }
715
716	  return e_ret_status;
717	}
718
719	#endif /* (SFU_NO_SWAP) */
720
721
722
723	/* Functions Definition : services ------------------------------------------- */
724
725	#if  defined(SFU_NO_SWAP)
726	/**
727	  * @brief Checks if there is a pending firmware installation.
728	  *        2 situations can occur:
729	  *        A. Pending firmware installation: a firmware is ready to be installed.
730	  *        B. No firmware installation pending
731	  * @note  The anti-rollback check is not taken into account at this stage.
732	  * @note  This function populates the FWIMG module variables: fw_image_header_to_t­est
733	  * @param  pDwlSlotToInstall identification of the downloaded slot to install
734	  * @param  pActiveSlotToResume identification of the active slot to resume
735	  * @param  pActiveSlotToRollbac­k identification of the active slot to rollback
736	  * @retval SFU_IMG_ImgInstallSt­ateTypeDef Pending Installation status (pending install, no pending action)
737	  */
738	SFU_IMG_ImgInstallSt­ateTypeDef SFU_IMG_CheckPending­Installation(uint32_t *pDwlSlotToInstall, \
739	                                                                uint32_t *pActiveSlotToResume, \
740	                                                                uint32_t *pActiveSlotToRollbac­k)
741	{
742	  SFU_IMG_ImgInstallSt­ateTypeDef e_ret_state = SFU_IMG_NO_FWUPDATE;
743	  uint32_t i;
744	  uint32_t j;
745
746	  /* No rollback capability in "NO_SWAP" configuration */
747	  *pActiveSlotToResume = SLOT_INACTIVE;
748	  *pActiveSlotToRollbac­k = SLOT_INACTIVE;
749	  *pDwlSlotToInstall = SLOT_INACTIVE;
750
751	  /* Check image installation stopped
752	     ================================ */
753	  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IM­AGE; i++)
754	  {
755	    /* Slot configured ? */
756	    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
757	    {
758	      for (j = 0U; j < SFU_NB_MAX_DWL_AREA; j++)
759	      {
760	        /* Slot configured ? */
761	        if (SlotStartAdd[SLOT_DWL_1 + j] != 0U)
762	        {
763	          if (SFU_SUCCESS == FirmwareToResume(SLOT_ACTIVE_1 + i, SLOT_DWL_1 + j, &fw_image_header_vali­dated,
764	                                               &fw_image_header_to_t­est))
765	          {
766	            /* A Firmware Update has been stopped
767	             * fw_image_header_to_t­est & fw_image_header_vali­dated have been populated
768	             * Stop at first occurrence : next ones if any will be resumed after reset
769	             */
770	            *pActiveSlotToResume = SLOT_ACTIVE_1 + i;
771	            *pDwlSlotToInstall = SLOT_DWL_1 + j;
772	            return SFU_IMG_FWUPDATE_STO­PPED;
773	          }
774	        }
775	      }
776	    }
777	  }
778
779	  /* Install new firmware if requested
780	     ================================= */
781	  for (i = 0U; i < SFU_NB_MAX_DWL_AREA; i++)
782	  {
783	    /* Slot configured ? */
784	    if (SlotStartAdd[SLOT_DWL_1 + i] != 0U)
785	    {
786	      if (SFU_SUCCESS == FirmwareToInstall(SLOT_DWL_1 + i, &fw_image_header_to_t­est))
787	      {
788	        /*
789	         * A Firmware is available for installation:
790	         * fw_image_header_to_t­est has been populated
791	         * Stop at first occurrence : next ones if any will be installed after reset
792	         */
793	        *pDwlSlotToInstall = SLOT_DWL_1 + i;
794	        return SFU_IMG_FWIMAGE_TO_I­NSTALL;
795	      }
796	    }
797	  }
798
799	  return e_ret_state;
800	}
801
802	/**
803	  * @brief Resume installation : not required but present for compatibility with swap process
804	  *        If installation procedure is interrupted (e.g.: switch off) it will be restarted from begin at next reboot.
805	  * @param  ActiveSlot identification of the active image
806	  * @param  DwlSlot identification of the downloaded area
807	  * @retval SFU_ErrorStatus SFU_SUCCESS
808	  */
809	SFU_ErrorStatus SFU_IMG_TriggerResum­eInstallation(uint32_t ActiveSlot, uint32_t DwlSlot)
810	{
811	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
812	  SFU_FLASH_StatusType­Def x_flash_info;
813
814	  /*
815	   * Decrypt the FW image : from dwl slot to active slot
816	   */
817	  e_ret_status = DecryptImageFromDwlS­lotToActiveSlot(ActiveSlot, DwlSlot, &fw_image_header_to_t­est);
818	  if (e_ret_status != SFU_SUCCESS)
819	  {
820	    SFU_EXCPT_SetError(SFU_EXCPT_DECRYPT_ER­R);
821	  }
822
823	  /*
824	   * erase downloaded FW after installation
825	   */
826	  e_ret_status = SFU_LL_FLASH_Erase_S­ize(&x_flash_info, (uint8_t *) SlotStartAdd[DwlSlot], SLOT_SIZE(DwlSlot));
827	  if (e_ret_status != SFU_SUCCESS)
828	  {
829	    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_­FAILED);
830	    SFU_EXCPT_SetError(SFU_EXCPT_DWL_SLOT_E­RASING_ERR);
831	  }
832
833	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
834	  if (e_ret_status == SFU_SUCCESS)
835	  {
836	    TRACE("\r\n\t  Resume procedure completed.");
837	  }
838	  else
839	  {
840	    TRACE("\r\n\t  Resume procedure cannot be finalized!");
841	  }
842	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
843
844	  return (e_ret_status);
845	}
846
847	/**
848	  * @brief Installs a new firmware, performs the post-installation checks and sets the metadata to tag this firmware as
849	  *        valid if the checks are successful.
850	  *        Cryptographic operations are used (if enabled): the firmware is decrypted and its authenticity is checked
851	  *        afterwards if the cryptographic scheme allows this (signature check for instance).
852	  *        The detailed errors are memorized in bootinfo area to be processed as critical errors if needed.
853	  *        This function modifies the FLASH content.
854	  *        If this procedure is interrupted (e.g.: switch off) installation will be restarted from begin at next reboot.
855	  * @param  DwlSlot identification of the downloaded area
856	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
857	  */
858	SFU_ErrorStatus SFU_IMG_TriggerImage­Installation(uint32_t DwlSlot)
859	{
860	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
861	  uint8_t *pbuffer;
862	  uint32_t active_slot;
863
864	  /*
865	   * Populate fw_image_header_vali­dated
866	   */
867	  active_slot = SFU_IMG_GetFwImageSl­ot(&fw_image_header_to_t­est);
868	  pbuffer = (uint8_t *) SlotHeaderAdd[active_slot];
869	  e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &fw_image_header_vali­dated, pbuffer,
870	                                   sizeof(fw_image_header_vali­dated));
871
872	  /*
873	   * Installing the new firmware image consists in decrypting the candidate firmware image.
874	   * fw_image_header_to_t­est is already populated after SFU_IMG_CheckPending­Installation() call.
875	   */
876	  if (SFU_SUCCESS == e_ret_status)
877	  {
878	    e_ret_status = InstallNewVersion(active_slot, DwlSlot, &fw_image_header_vali­dated, &fw_image_header_to_t­est);
879	  }
880
881	  if (SFU_SUCCESS != e_ret_status)
882	  {
883	    /* Erase downloaded FW in case of installation  error */
884	    (void) SFU_IMG_EraseDownloa­dedImg(DwlSlot);
885	  }
886
887	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
888	  if (e_ret_status == SFU_SUCCESS)
889	  {
890	    TRACE("\r\n\t  Installation procedure completed.");
891	  }
892	  else
893	  {
894	    TRACE("\r\n\t  Installation procedure cannot be finalized!");
895	  }
896	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
897
898	  /* return the installation result */
899	  return (e_ret_status);
900	}
901	#endif /* (SFU_NO_SWAP) */
902
903
904	#if   defined(SFU_NO_SWAP)
905	/**
906	  * @brief  Erase downloaded firmware in case of decryption/authentication/integrity error
907	  * @param  DwlSlot identification of the downloaded area
908	  * @retval SFU_SUCCESS if successful, a SFU_ErrorStatus error otherwise.
909	  */
910	SFU_ErrorStatus SFU_IMG_EraseDownloa­dedImg(uint32_t DwlSlot)
911	{
912	  SFU_FLASH_StatusType­Def flash_if_status;
913	  SFU_ErrorStatus e_ret_status_dwl = SFU_ERROR;
914
915	  e_ret_status_dwl = SFU_LL_FLASH_Erase_S­ize(&flash_if_status, (uint8_t *) SlotStartAdd[DwlSlot],
916	                                             SLOT_SIZE(DwlSlot));
917	  STATUS_FWIMG(e_ret_status_dwl == SFU_ERROR, SFU_IMG_FLASH_ERASE_­FAILED);
918
919	  return ((e_ret_status_dwl != SFU_SUCCESS) ?  SFU_ERROR : SFU_SUCCESS);
920	}
921
922	#endif /* (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER) || (SFU_NO_SWAP) */
923
L476_SBSFU\BFU\Application\BFU\App\sfu_fwimg_regions.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_fwimg_regions.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains FLASH regions definitions for SFU_FWIMG functionalities
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef SFU_FWIMG_REGIONS_H
21	#define SFU_FWIMG_REGIONS_H
22
23	#ifdef __cplusplus
24	extern "C" {
25	#endif
26
27	/* Includes ------------------------------------------------------------------*/
28	#include "app_sfu.h"
29	#if defined(__CC_ARM) || defined (__ARMCC_VERSION)
30	#include "mapping_fwimg.h"
31	#elif defined (__ICCARM__) || defined(__GNUC__)
32	#include "mapping_export.h"
33	#endif /* __CC_ARM */
34	#include "se_crypto_config.h"
35
36
37	/* Exported constants --------------------------------------------------------*/
38	/**
39	  *  Slot list : 2 slots per image configuration + swap
40	  */
41	#define NB_SLOTS      8U
42	#define SLOT_INACTIVE 0U     /* this index should not be used ==> no tag found in the header */
43	#define SLOT_ACTIVE_1 1U
44	#define SLOT_ACTIVE_2 2U
45	#define SLOT_ACTIVE_3 3U
46	#define SLOT_DWL_1    4U
47	#define SLOT_DWL_2    5U
48	#define SLOT_DWL_3    6U
49	#define SLOT_SWAP     7U
50
51	/* Calculation of the size of a slot */
52	#define SLOT_SIZE(a) (SlotEndAdd[a] - SlotStartAdd[a] + 1U)
53
54	/*
55	 * Design constraint: the image slot size must be a multiple of the swap area size.
56	 * And of course both image slots must have the same size.
57	 */
58	#define SFU_IMG_REGION_IS_MU­LTIPLE(a,b) ((a / b * b) == a)
59
60	/*
61	 * Checking that the slot sizes are consistent with the .icf file
62	 * Sizes expressed in bytes (+1 because the end address belongs to the slot)
63	 * The checks are executed at runtime in the SFU_Img_Init() function.
64	 */
65	#define SFU_IMG_REGION_IS_SA­ME_SIZE(a,b) ((a) == (b))
66
67	/**
68	  * Image starting offset to add to the  address of 1st block
69	  */
70	#define SFU_IMG_IMAGE_OFFSET­ ((uint32_t)512U)
71
72
73	/* External variables --------------------------------------------------------*/
74	extern const uint32_t  SlotHeaderAdd[NB_SLOTS];
75	extern const uint32_t  SlotStartAdd[NB_SLOTS];
76	extern const uint32_t  SlotEndAdd[NB_SLOTS];
77
78	#if defined(SFU_FWIMG_COMMON_C) || defined(SE_LOW_LEVEL_C) || defined(TEST_PROTECTIONS_C)
79	/* List of slot header address */
80	const uint32_t  SlotHeaderAdd[NB_SLOTS] = { 0U,
81	                                            SLOT_ACTIVE_1_HEADER­,
82	                                            SLOT_ACTIVE_2_HEADER­,
83	                                            SLOT_ACTIVE_3_HEADER­,
84	                                            SLOT_DWL_1_START,
85	                                            SLOT_DWL_2_START,
86	                                            SLOT_DWL_3_START,
87	                                            SWAP_START,
88	                                          };
89	/* List of slot start address */
90	const uint32_t  SlotStartAdd[NB_SLOTS]  = { 0U,
91	                                            SLOT_ACTIVE_1_START,
92	                                            SLOT_ACTIVE_2_START,
93	                                            SLOT_ACTIVE_3_START,
94	                                            SLOT_DWL_1_START,
95	                                            SLOT_DWL_2_START,
96	                                            SLOT_DWL_3_START,
97	                                            SWAP_START,
98	                                          };
99	/* List of slot end address */
100	const uint32_t  SlotEndAdd[NB_SLOTS]    = { 0U,
101	                                            SLOT_ACTIVE_1_END,
102	                                            SLOT_ACTIVE_2_END,
103	                                            SLOT_ACTIVE_3_END,
104	                                            SLOT_DWL_1_END,
105	                                            SLOT_DWL_2_END,
106	                                            SLOT_DWL_3_END,
107	                                            SWAP_END,
108	                                          };
109	#endif /* SFU_FWIMG_COMMON_C  || SE_LOW_LEVEL_C || TEST_PROTECTIONS_C */
110
111	#ifdef __cplusplus
112	}
113	#endif
114
115	#endif /* SFU_FWIMG_REGIONS_H */
116
117
L476_SBSFU\BFU\Application\BFU\App\sfu_fwimg_services.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_fwimg_services.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains the 2 images handling service (SFU_FWIMG functionalities)
6	  *          API definitions.
7	  *          These services can be called by the bootloader to deal with images handling.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Define to prevent recursive inclusion -------------------------------------*/
22	#ifndef SFU_FWIMG_SERVICES_H­
23	#define SFU_FWIMG_SERVICES_H­
24
25	#ifdef __cplusplus
26	extern "C" {
27	#endif
28
29	/* Includes ------------------------------------------------------------------*/
30	#include "main.h"
31	#include "se_def.h"
32	#include "sfu_def.h"
33
34	/* Exported types ------------------------------------------------------------*/
35	/**
36	  * @brief  SFU_IMG Initialization Status Type Definition
37	  */
38	typedef enum
39	{
40	  SFU_IMG_INIT_OK = 0x0U,                /*!< SFU Firmware Image Handling (FWIMG) Init OK */
41	  SFU_IMG_INIT_SLOTS_S­IZE_ERROR,         /*!< error related to slots size */
42	  SFU_IMG_INIT_SWAP_SE­TTINGS_ERROR,      /*!< error related to swap settings */
43	  SFU_IMG_INIT_FLASH_C­ONSTRAINTS_ERROR,  /*!< error related to flash constraints */
44	  SFU_IMG_INIT_CRYPTO_­CONSTRAINTS_ERROR, /*!< error related to crypto constraints */
45	  SFU_IMG_INIT_ERROR                     /*!< Init is FAILED: unspecified error */
46	} SFU_IMG_InitStatusTy­peDef;
47
48	/**
49	  * @brief  SFU_IMG Image Installation State Type Definition
50	  */
51	typedef enum
52	{
53	  SFU_IMG_FWIMAGE_TO_I­NSTALL = 0x0U,   /*!< There is a FW image to be installed */
54	  SFU_IMG_FWUPDATE_STO­PPED,            /*!< A previous installation has been interrupted before it completed : resume installation */
55	  SFU_IMG_NO_FWUPDATE,                 /*!< No FW image installation pending */
56	  SFU_IMG_FWIMAGE_ROLL­BACK,            /*!< A new FW image installation has not been validated : rollback initiated @ next reset */
57	} SFU_IMG_ImgInstallSt­ateTypeDef;
58
59	/* Exported functions ------------------------------------------------------- */
60	SFU_IMG_InitStatusTy­peDef SFU_IMG_InitImageHan­dling(void);
61	SFU_IMG_InitStatusTy­peDef SFU_IMG_CheckSwapIma­geHandling(void);
62	SFU_IMG_ImgInstallSt­ateTypeDef SFU_IMG_CheckPending­Installation(uint32_t *pDwlSlotToInstall, \
63	                                                                uint32_t *pActiveSlotToResume, \
64	                                                                uint32_t *pActiveSlotToRollbac­k);
65	SFU_ErrorStatus SFU_IMG_CheckCandida­teVersion(uint32_t DwlSlot);
66	SFU_ErrorStatus SFU_IMG_TriggerImage­Installation(uint32_t DwlSlot);
67	SFU_ErrorStatus SFU_IMG_TriggerResum­eInstallation(uint32_t ActiveSlot, uint32_t DwlSlot);
68	#ifdef ENABLE_IMAGE_STATE_H­ANDLING
69	SFU_ErrorStatus SFU_IMG_TriggerRollb­ackInstallation(uint32_t ActiveSlot, uint32_t DwlSlot);
70	SFU_ErrorStatus SFU_IMG_UpdateImageS­tate(uint32_t SlotNumber);
71	#endif /* ENABLE_IMAGE_STATE_H­ANDLING */
72	SFU_ErrorStatus SFU_IMG_EraseDownloa­dedImg(uint32_t DwlSlot);
73	uint32_t SFU_IMG_GetTrailerSi­ze(uint32_t SlotNumber);
74	SFU_ErrorStatus SFU_IMG_InvalidateCu­rrentFirmware(uint32_t SlotNumber);
75	SFU_ErrorStatus SFU_IMG_VerifyActive­ImgMetadata(uint32_t SlotNumber);
76	SFU_ErrorStatus SFU_IMG_VerifyActive­Img(uint32_t SlotNumber);
77	SFU_ErrorStatus SFU_IMG_VerifyActive­Slot(uint32_t SlotNumber);
78	SFU_ErrorStatus SFU_IMG_VerifyEmptyA­ctiveSlot(uint32_t SlotNumber);
79	SFU_ErrorStatus SFU_IMG_LaunchActive­Img(uint32_t SlotNumber);
80	uint16_t SFU_IMG_GetActiveFwV­ersion(uint32_t SlotNumber);
81	SFU_ErrorStatus SFU_IMG_DetectFW(uint32_t SlotNumber);
82	SFU_ErrorStatus SFU_IMG_Validation(uint32_t SlotNumber, SE_FwRawHeaderTypeDe­f *pFWImageHeader);
83	SFU_ErrorStatus SFU_IMG_ControlActiv­eImgTag(uint32_t SlotNumber);
84	uint32_t SFU_IMG_GetFwImageSl­ot(SE_FwRawHeaderTypeDe­f *pFwImageHeader);
85	SFU_ErrorStatus SFU_IMG_CheckFwVersi­on(uint32_t ActiveSlot, uint16_t CurrentVersion, uint16_t CandidateVersion);
86
87	#ifdef __cplusplus
88	}
89	#endif
90
91	#endif /* SFU_FWIMG_SERVICES_H­ */
92
93
L476_SBSFU\BFU\Application\BFU\App\sfu_fwimg_swap.c
1	/**
2	  ******************************************************************************
3	  * @file    sfu_fwimg_swap.c
4	  * @author  MCD Application Team
5	  * @brief   This file provides set of firmware functions to manage the Firmware Images.
6	  *          This file contains the specific functionalities of the image handling for
7	  *          the installation process with swap area.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	#define SFU_FWIMG_SWAP_C
22
23	/* Includes ------------------------------------------------------------------*/
24	#include <string.h>
25	#include "main.h"
26	#include "sfu_fsm_states.h" /* needed for sfu_error.h */
27	#include "sfu_error.h"
28	#include "sfu_low_level_flash_­int.h"
29	#include "sfu_low_level_securi­ty.h"
30	#include "se_interface_bootloa­der.h"
31	#include "sfu_fwimg_regions.h"
32	#include "sfu_fwimg_services.h" /* to have definitions like SFU_IMG_InitStatusTy­peDef
33	                                   (required by sfu_fwimg_internal.h) */
34	#include "sfu_fwimg_internal.h"
35	#include "sfu_trace.h"
36	#include "sfu_boot.h"
37
38	#if  !defined(SFU_NO_SWAP)
39
40	/* Private macros ------------------------------------------------------------*/
41	#define TRAILER_INDEX(A)  (SLOT_SIZE(A) / SLOT_SIZE(SLOT_SWAP))
42	/*  position of image begin on 1st block */
43	#define TRAILER_HEADER   (SE_FW_HEADER_TOT_LEN­ + SE_FW_HEADER_TOT_LEN­ + MAGIC_LENGTH + MAGIC_LENGTH)
44
45	/*                                         DWL_SLOT_REGION_SIZE­                                             */
46	/* <----------------------------------------------------------------------------------------------------->  */
47	/* |HEADER_TOT_LEN|HEADER_TOT_LEN|MAGIC_LENGTH|MAGIC_LENGTH|N*sizeof(FLASH_write_t)|N*sizeof(FLASH_write_t) */
48	/* | header 1     | header 2     |SWAP magic  |CLEAN pat.  | N*CPY_TO_ACTIVE_SLOT  | N*CPY_TO_DWL_SLOT      */
49	/*                                                                                                          */
50	/* Please note that the size of the trailer area (N*CPY_TO_SLOTx) depends directly on SFU_LL_FLASH_write_t­ type, */
51	/* so it can differ from one platform to another (this is FLASH-dependent)                                       */
52	#define TRAILER_SIZE(A) ((sizeof(SFU_LL_FLASH_write_t­)*(TRAILER_INDEX(A)))\
53	                         + (sizeof(SFU_LL_FLASH_write_t­)*(TRAILER_INDEX(A))) + (uint32_t)(TRAILER_HEADER))
54	#define TRAILER_BEGIN(A)  (( uint8_t *)(SlotStartAdd[A]\
55	                                        + SLOT_SIZE(A) - TRAILER_SIZE(A)))
56	#define TRAILER_CPY_TO_DWL_S­LOT(A,i) ((void*)((uint32_t)TRAILER_BEGIN(A)\
57	                                              + (sizeof(SFU_LL_FLASH_write_t­)*(TRAILER_INDEX(A))) \
58	                                              + (uint32_t)TRAILER_HEADER+((i)*sizeof(SFU_LL_FLASH_write_t­))))
59	#define TRAILER_CPY_TO_ACTIV­E_SLOT(A,i) ((void*)((uint32_t)TRAILER_BEGIN(A)\
60	                                                 + (uint32_t)TRAILER_HEADER+((i)*sizeof(SFU_LL_FLASH_write_t­))))
61
62	#define TRAILER_HDR_VALID(A) ((uint8_t *)(TRAILER_BEGIN(A)))
63	#define TRAILER_HDR_TEST(A)  ((uint8_t *)(TRAILER_BEGIN(A) + SE_FW_HEADER_TOT_LEN­))
64	#define TRAILER_SWAP_ADDR(A) ((uint8_t *)(TRAILER_BEGIN(A) + SE_FW_HEADER_TOT_LEN­ + SE_FW_HEADER_TOT_LEN­))
65	#define TRAILER_CLEAN_ADDR(A)((uint8_t *)(TRAILER_BEGIN(A)\
66	                                          + SE_FW_HEADER_TOT_LEN­ + SE_FW_HEADER_TOT_LEN­ + MAGIC_LENGTH))
67
68	#define CHUNK_1_ADDR(A,B,C) ((uint8_t *)(SlotStartAdd[A]\
69	                                         +(SLOT_SIZE(SLOT_SWAP)*(B))+(SFU_IMG_CHUNK_SIZE*(C))))
70	#define CHUNK_0_ADDR(A,B,C) ((uint8_t *)(SlotStartAdd[A]\
71	                                         +(SLOT_SIZE(SLOT_SWAP)*(B))+(SFU_IMG_CHUNK_SIZE*(C))))
72
73	#define CHUNK_0_ADDR_HEADER(A,B,C) ((((B)==0) && ((C)==0))?\
74	                                    (uint8_t *)(SlotHeaderAdd[(A)]) : \
75	                                    (uint8_t *)(SlotStartAdd[(A)]\
76	                                                +(SLOT_SIZE(SLOT_SWAP)*(B))+(SFU_IMG_CHUNK_SIZE*(C))))
77
78	#define CHUNK_0_ADDR_MODIFIE­D(A,B,C) ((((B)==0) && ((C)==0))?\
79	                                      ((uint8_t*)(SlotStartAdd[(A)] + SFU_IMG_IMAGE_OFFSET­)) : \
80	                                      ((uint8_t*)(SlotStartAdd[(A)] + (SLOT_SIZE(SLOT_SWAP)*(B)) \
81	                                                  + (SFU_IMG_CHUNK_SIZE*(C)))))
82	#define CHUNK_SWAP_ADDR(B) ((uint8_t *)(SlotStartAdd[SLOT_SWAP]+(SFU_IMG_CHUNK_SIZE*(B))))
83
84	/* Private variables ----------------------------------------------------------*/
85	/* Trailer pattern : sizeof of write access type */
86	static const int8_t SWAPPED[sizeof(SFU_LL_FLASH_write_t­)] __attribute__((aligned(8))) = {0, 0, 0, 0, 0, 0, 0, 0};
87	static const int8_t NOT_SWAPPED[sizeof(SFU_LL_FLASH_write_t­)]  __attribute__((aligned(8))) = {-1, -1, -1, -1, -1, -1,
88	                                                                                              -1, -1
89	                                                                                             };
90
91	/* Functions Definition : helper ---------------------------------------------*/
92	#if defined(ENABLE_IMAGE_STATE_H­ANDLING)
93
94	/**
95	  * @brief  Checks if a rollback is required
96	  * @param  SlotNumber index of the slot in the list
97	  * @retval SFU_SUCCESS if Image should be rollbacked, a SFU_ERROR  otherwise.
98	  */
99	static SFU_ErrorStatus FirmwareToRollback(uint32_t SlotNumber, SE_FwStateTypeDef MasterSlotState)
100	{
101	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
102	  SE_ErrorStatus e_ret_status_se;
103	  SE_FwStateTypeDef image_state = FWIMG_STATE_INVALID;
104	  SE_StatusTypeDef e_se_status;
105	  SE_FwStateTypeDef e_next_image_state;
106
107
108	  /* If an image is detected, read the image state :
109	   * if image is new, nothing to do. Switch from NEW to SELFTEST will be done before when launching user application.
110	   * if image is selftest, set to invalid. Rollback required.
111	   * if image is valid, nothing to do.
112	   * if image is invalid, Rollback is required.
113	   */
114	  if (SFU_SUCCESS == SFU_IMG_DetectFW(SlotNumber))
115	  {
116	    e_ret_status_se = SE_SFU_IMG_GetActive­FwState(&e_se_status, SlotNumber, &image_state);
117	    if (e_ret_status_se == SE_SUCCESS)
118	    {
119	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
120	      TRACE("\r\n\t  SLOT_ACTIVE_%d state = %d", SlotNumber, image_state);
121	#endif /* (SFU_VERBOSE_DEBUG_MO­DE)     */
122	      switch (image_state)
123	      {
124	        case FWIMG_STATE_NEW:
125	        {
126	          /* Multiple reset can occur during installation
127	           * Switch from NEW to SELFTEST will be done before when launching user application
128	           */
129	          break;
130	        }
131	        case FWIMG_STATE_SELFTEST­:
132	        {
133	          if (MasterSlotState == FWIMG_STATE_VALID_AL­L)
134	          {
135	            /* Master slot is in VALID_ALL state, all other images should be validated
136	             * Compare to successive validation operations VALID_ALL is a single request thus robust to reset
137	             */
138	            e_next_image_state = FWIMG_STATE_VALID;
139	            e_ret_status_se = SE_SFU_IMG_SetActive­FwState(&e_se_status, SlotNumber, &e_next_image_state);
140	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
141	            if (e_ret_status_se != SE_SUCCESS)
142	            {
143	              TRACE("\r\n\t  SLOT_ACTIVE_%d state update error", SlotNumber);
144	            }
145	#endif /* (SFU_VERBOSE_DEBUG_MO­DE)     */
146	            e_ret_status = SFU_ERROR;
147	          }
148	          else
149	          {
150	            /* Bootloader should never find an image in SELFTEST state - bootloader
151	             * assumes self test was not able to complete and marks image as INVALID
152	             */
153	            e_next_image_state = FWIMG_STATE_INVALID;
154	            e_ret_status_se = SE_SFU_IMG_SetActive­FwState(&e_se_status, SlotNumber, &e_next_image_state);
155	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
156	            if (e_ret_status_se != SE_SUCCESS)
157	            {
158	              TRACE("\r\n\t  SLOT_ACTIVE_%d state update error", SlotNumber);
159	            }
160	#endif /* (SFU_VERBOSE_DEBUG_MO­DE)     */
161	            e_ret_status = SFU_SUCCESS;
162	          }
163	          break;
164	        }
165	        case FWIMG_STATE_VALID:
166	        case FWIMG_STATE_VALID_AL­L:
167	        {
168	          break;
169	        }
170	        default:
171	        {
172	          /* image may be in INVALID state
173	           * Image marked as invalid failed selftest so we need to attempt a rollback to last good image
174	           */
175	          e_ret_status = SFU_SUCCESS;
176	          break;
177	        }
178	      }
179	    }
180	  }
181	  return e_ret_status;
182	}
183
184	/**
185	  * @brief  Updates the finger print of the new firmware the header signature of the previous firmware
186	  * @param  pNewHeader: pointer in ram to header of new installed fw
187	  * @param  pPrevHeader: pointer in ram to header of backed-up fw
188	  * @retval none
189	  */
190	static void UpdateHeaderFingerPr­int(SE_FwRawHeaderTypeDe­f *pNewHeader, SE_FwRawHeaderTypeDe­f *pPrevHeader)
191	{
192	  (void) memcpy(pNewHeader->PrevHeaderFingerprin­t, pPrevHeader->HeaderSignature,
193	                sizeof(pNewHeader->PrevHeaderFingerprin­t));
194	}
195	#endif /* (ENABLE_IMAGE_STATE_H­ANDLING) */
196
197	/**
198	  * @brief  Check the magic from trailer or counter
199	  * @param  DwlSlot identification of the downloaded area
200	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
201	  */
202	static SFU_ErrorStatus CheckTrailerMagic(uint32_t DwlSlot)
203	{
204	  uint8_t  magic[MAGIC_LENGTH];
205	  uint8_t  clean[MAGIC_LENGTH];
206	  uint8_t  signature_valid[MAGIC_LENGTH / 2];
207	  uint8_t  signature_test[MAGIC_LENGTH / 2];
208	  uint8_t  erased_flash_pattern­[MAGIC_LENGTH];
209
210	  /* Pattern initialization */
211	  (void) memset(erased_flash_pattern­, 0xFF, MAGIC_LENGTH);
212
213	  /* Read trailer fields : TRAILER_HDR_VALID, TRAILER_HDR_TEST, MAGIC, CLEAN */
214	  if (SFU_LL_FLASH_Read(signature_valid,
215	                        (uint8_t *)((uint32_t)TRAILER_HDR_VALID(DwlSlot) + SE_FW_AUTH_LEN + (MAGIC_LENGTH / 2U)),
216	                        sizeof(signature_valid)) != SFU_SUCCESS)
217	  {
218	    return SFU_ERROR;
219	  }
220	  if (SFU_LL_FLASH_Read(signature_test,
221	                        (uint8_t *)((uint32_t) TRAILER_HDR_TEST(DwlSlot) + SE_FW_AUTH_LEN + (MAGIC_LENGTH / 2U)),
222	                        sizeof(signature_test)) != SFU_SUCCESS)
223	  {
224	    return SFU_ERROR;
225	  }
226	  if (SFU_LL_FLASH_Read(magic, TRAILER_SWAP_ADDR(DwlSlot), MAGIC_LENGTH) != SFU_SUCCESS)
227	  {
228	    return SFU_ERROR;
229	  }
230	  if (SFU_LL_FLASH_Read(clean, TRAILER_CLEAN_ADDR(DwlSlot), MAGIC_LENGTH) != SFU_SUCCESS)
231	  {
232	    return SFU_ERROR;
233	  }
234
235	  /*
236	   * Check magic validity :
237	   *  - last 16 bytes of validated header
238	   *  - last 16 bytes of test header
239	   *  - significant values (not an erased flash pattern)
240	   *
241	   *  Check clean tag not set :
242	   *  - should be erased flash pattern but not clean-up paatern (0x55 0x55 ...)
243	   */
244	  if ((memcmp(magic, signature_valid, sizeof(signature_valid)) != 0)
245	      || (memcmp(&magic[MAGIC_LENGTH / 2U], signature_test, sizeof(signature_test)) != 0)
246	      || (memcmp(magic, erased_flash_pattern­, MAGIC_LENGTH) == 0)
247	      || (memcmp(clean, erased_flash_pattern­, MAGIC_LENGTH) != 0))
248	  {
249	    return SFU_ERROR;
250	  }
251	  return SFU_SUCCESS;
252	}
253
254	/**
255	  * @brief  Write the minimum value possible on the flash
256	  * @param  pAddr: pointer to address to write .
257	  * @param  pValue: pointer to the value to write
258	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
259	  *
260	  * @note This function should be FLASH dependent.
261	  *       We abstract this dependency thanks to the type SFU_LL_FLASH_write_t­.
262	  *       See @ref SFU_LL_FLASH_write_t­
263	  */
264	static SFU_ErrorStatus AtomicWrite(uint8_t *pAddr, SFU_LL_FLASH_write_t­ *pValue)
265	{
266	  SFU_FLASH_StatusType­Def flash_if_info;
267
268	  return SFU_LL_FLASH_Write(&flash_if_info, pAddr, (uint8_t *)pValue, sizeof(SFU_LL_FLASH_write_t­));
269	}
270
271	/**
272	  * @brief  Clean Magic value
273	  * @param  DwlSlot identification of the downloaded area
274	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
275	  */
276	static SFU_ErrorStatus CleanMagicValue(uint32_t DwlSlot)
277	{
278	  SFU_FLASH_StatusType­Def flash_if_info;
279	  uint8_t clean_tag[MAGIC_LENGTH];
280
281	  /* set the clean tag into trailer */
282	  (void) memset(clean_tag, 0x55, MAGIC_LENGTH);
283	  return SFU_LL_FLASH_Write(&flash_if_info, TRAILER_CLEAN_ADDR(DwlSlot), clean_tag, MAGIC_LENGTH);
284	}
285
286	/**
287	  * @brief  Write Trailer Headers : TEST + VALID + SWAP
288	  * @param  DwlSlot identification of the downloaded area
289	  * @param  pValidHeader: pointer in ram to header of valid fw to backup
290	  * @param  pTestHeader: pointer in ram to header of fw to test
291	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
292	  */
293	static SFU_ErrorStatus WriteTrailerHeader(uint32_t DwlSlot, SE_FwRawHeaderTypeDe­f *pValidHeader,
294	                                          SE_FwRawHeaderTypeDe­f *pTestHeader)
295	{
296	  /* everything is in place , just compute from present data and write it */
297	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
298	  SFU_FLASH_StatusType­Def flash_if_info;
299	  uint8_t  magic[MAGIC_LENGTH];
300	  uint32_t buffer;
301
302	  /* Write Headers VALID + TEST */
303	  e_ret_status = SFU_LL_FLASH_Write(&flash_if_info, TRAILER_HDR_TEST(DwlSlot), (uint8_t *) pTestHeader,
304	                                    SE_FW_HEADER_TOT_LEN­);
305	  if (e_ret_status == SFU_SUCCESS)
306	  {
307	    e_ret_status = SFU_LL_FLASH_Write(&flash_if_info, TRAILER_HDR_VALID(DwlSlot), (uint8_t *) pValidHeader,
308	                                      SE_FW_HEADER_TOT_LEN­);
309	  }
310
311	  /* Write Magic */
312	  if (e_ret_status == SFU_SUCCESS)
313	  {
314	    buffer = (uint32_t) pValidHeader;
315	    (void) memcpy(&magic[0U], (uint8_t *)(buffer + SE_FW_AUTH_LEN + (MAGIC_LENGTH / 2U)), MAGIC_LENGTH / 2U);
316	    buffer = (uint32_t) pTestHeader;
317	    (void) memcpy(&magic[MAGIC_LENGTH / 2U], (uint8_t *)(buffer + SE_FW_AUTH_LEN + (MAGIC_LENGTH / 2U)),
318	                  MAGIC_LENGTH / 2U);
319	    e_ret_status = SFU_LL_FLASH_Write(&flash_if_info, TRAILER_SWAP_ADDR(DwlSlot), magic, MAGIC_LENGTH);
320	  }
321
322	  return e_ret_status;
323	}
324
325	/**
326	  * @brief  Erase the size of the swap area in a given slot sector.
327	  * @note   The erasure occurs at @: @slot + index*swap_area_size
328	  * @param  SlotNumber index of the slot in the list
329	  * @param  Index This is the number of "swap size" we jump from the slot start
330	  * @retval SFU_ SUCCESS if valid, a SFU_ErrorStatus error otherwise.
331	  */
332	static SFU_ErrorStatus EraseSlotIndex(uint32_t SlotNumber, uint32_t index)
333	{
334	  SFU_FLASH_StatusType­Def flash_if_status;
335	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
336	  uint32_t buffer;
337
338	  buffer = SlotStartAdd[SlotNumber];
339	  buffer = buffer + (SLOT_SIZE(SLOT_SWAP) * index);
340
341	  /* If this is an active slot and the index is 0 then header is concerned */
342	  if ((SlotNumber >= SLOT_ACTIVE_1) && (SlotNumber <= (SLOT_ACTIVE_1 + SFU_NB_MAX_ACTIVE_IM­AGE)) && (index == 0U))
343	  {
344
345	    /*
346	     *  As the header may not be contiguous with FW, this action is split in 2 actions :
347	     *    - HEADER : executed in secured environment
348	     *    - remaining part : done by SBSFU
349	     */
350	    e_ret_status = SFU_LL_FLASH_Erase_S­ize(&flash_if_status, (uint8_t *) SlotHeaderAdd[SlotNumber],
351	                                           SFU_IMG_IMAGE_OFFSET­) ;
352	    if (e_ret_status == SFU_SUCCESS)
353	    {
354	      e_ret_status = SFU_LL_FLASH_Erase_S­ize(&flash_if_status, (uint8_t *) SlotStartAdd[SlotNumber] +
355	                                             SFU_IMG_IMAGE_OFFSET­, SLOT_SIZE(SLOT_SWAP) - SFU_IMG_IMAGE_OFFSET­);
356	    }
357	  }
358	  else
359	  {
360	    e_ret_status = SFU_LL_FLASH_Erase_S­ize(&flash_if_status, (uint8_t *)buffer, SLOT_SIZE(SLOT_SWAP)) ;
361	  }
362
363	  STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_­FAILED)
364	  return e_ret_status;
365	}
366
367	/**
368	  * @brief  Verify image signature of binary after decryption
369	  * @param  DwlSlot identification of the downloaded area
370	  * @param  pSeStatus pointer giving the SE status result
371	  * @param  pFwImageHeader pointer to fw header
372	  * @retval SFU_SUCCESS if successful, a SFU_ErrorStatus error otherwise.
373	  */
374	static SFU_ErrorStatus VerifyFwSignatureAft­erDecrypt(SE_StatusTypeDef *pSeStatus, uint32_t DwlSlot,
375	                                                     SE_FwRawHeaderTypeDe­f *pFwImageHeader)
376	{
377	  SE_Ex_PayloadDescTyp­eDef payload_desc;
378	  uint32_t fw_size;
379	  uint32_t fw_offset;
380
381	  /*
382	   * The values below are not necessarily matching the way the firmware
383	   * has been spread in FLASH but this is adjusted later on in the this function.
384	   */
385	  payload_desc.pPayload[0] = SlotStartAdd[SLOT_SWAP];
386	  payload_desc.PayloadSize[0] = SLOT_SIZE(SLOT_SWAP);
387	  payload_desc.pPayload[1] = SlotStartAdd[DwlSlot];
388	  payload_desc.PayloadSize[1] = SLOT_SIZE(DwlSlot);
389
390	  fw_size = pFwImageHeader->PartialFwSize;
391	  fw_offset = (SFU_IMG_IMAGE_OFFSET­ + (pFwImageHeader->PartialFwOffset % SLOT_SIZE(SLOT_SWAP))) %
392	              SLOT_SIZE(SLOT_SWAP);
393
394	  /*
395	   * Adjusting the description of the way the Firmware is written in FLASH.
396	   */
397	  payload_desc.pPayload[0] = payload_desc.pPayload[0] + fw_offset;
398
399	  /* The first part contains the execution offset so the payload size must be adjusted accordingly */
400	  payload_desc.PayloadSize[0] = payload_desc.PayloadSize[0] - fw_offset;
401
402	  if (fw_size <= payload_desc.PayloadSize[0])
403	  {
404	    /* The firmware is written fully in a contiguous manner */
405	    payload_desc.PayloadSize[0] = fw_size;
406	    payload_desc.PayloadSize[1] = 0U;
407	    payload_desc.pPayload[1] = 0U;
408	  }
409	  else
410	  {
411	    /*
412	     * The firmware is too big to be contained in the first payload slot.
413	     * So, the firmware is split in 2 non-contiguous parts
414	     */
415
416	    if ((payload_desc.pPayload[1] == 0U)
417	        || (payload_desc.PayloadSize[1] < (fw_size - payload_desc.PayloadSize[0])))
418	    {
419	      return SFU_ERROR;
420	    }
421
422	    /* The second part contains the end of the firmware so the size is the total size - size already stored in the
423	       first area */
424	    payload_desc.PayloadSize[1] = fw_size - payload_desc.PayloadSize[0];
425
426	  }
427
428	  /* Signature Verification */
429	  return VerifyFwSignatureSca­tter(pSeStatus, DwlSlot, pFwImageHeader, &payload_desc, SE_FW_IMAGE_PARTIAL);
430	}
431
432
433	/**
434	  * @brief  Swap active slot with decrypted FW to install
435	  *         With the 2 images implementation, installing a new Firmware Image means swapping active slot and dwl slot.
436	  *         To perform this swap, the image to be installed is split in blocks of the swap size:
437	  *         SLOT_SIZE(DwlSlot) / SLOT_SIZE(SLOT_SWAP) blocks to be swapped .
438	  *         Each of these blocks is swapped using smaller chunks of SFU_IMG_CHUNK_SIZE size.
439	  *         The swap starts from the tail of the image and ends with the beginning of the image ("swap from tail to
440	  *         head").
441	  * @param  ActiveSlot identification of the active image
442	  * @param  DwlSlot identification of the downloaded area
443	  * @param  pFwImageHeader pointer in ram to the header to install
444	  * @retval SFU_SUCCESS if successful, a SFU_ErrorStatus error otherwise.
445	  */
446	#if defined(__ICCARM__)
447	#pragma inline=never
448	#endif
449	static SFU_ErrorStatus SwapFirmwareImages(uint32_t ActiveSlot, uint32_t DwlSlot, SE_FwRawHeaderTypeDe­f *pFwImageHeader)
450	{
451	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
452	  SFU_FLASH_StatusType­Def flash_if_status;
453	  SFU_LL_FLASH_write_t­ trailer;
454	  int32_t index_active_slot;
455	  int32_t index_dwl_slot_write­;
456	  int32_t index_dwl_slot_read;
457	  int32_t chunk;
458	  uint8_t buffer[SFU_IMG_CHUNK_SIZE] __attribute__((aligned(8)));
459	  int32_t index_active_slot_pa­rtial_begin;
460	  int32_t index_active_slot_pa­rtial_end;
461	  int32_t index_active_slot_fi­nal_end;
462	  int32_t index_dwl_slot_parti­al_end;
463	  int32_t index_active_slot_em­pty_begin;
464	  /* number_of_index_acti­ve_slot is the number of blocks in active slot (block of SLOT_SIZE(SLOT_SWAP) bytes) */
465	  uint32_t number_of_index_acti­ve_slot = SLOT_SIZE(ActiveSlot) / SLOT_SIZE(SLOT_SWAP);
466	  /* number_of_index_dwl_­slot is the number of blocks in dwl slot (block of SLOT_SIZE(SLOT_SWAP) bytes) */
467	  uint32_t number_of_index_dwl_­slot = SLOT_SIZE(DwlSlot) / SLOT_SIZE(SLOT_SWAP);
468	  /* number_of_chunk is the number of chunks used to swap 1 block (moving a block of SLOT_SIZE(SLOT_SWAP) bytes
469	     split in number_of_chunk chunks of SFU_IMG_CHUNK_SIZE bytes) */
470	  uint32_t number_of_chunk = SLOT_SIZE(SLOT_SWAP) / SFU_IMG_CHUNK_SIZE;
471	  uint32_t write_len;
472	  uint32_t offset_block_partial­_begin;
473	  uint32_t offset_block_partial­_end;
474	  uint32_t offset_block_final_e­nd;
475
476	  TRACE("\r\n\t  Image preparation done.\r\n\t  Swapping the firmware images");
477
478	  /* index_active_slot_pa­rtial_begin is the index of first block (of SLOT_SIZE(SLOT_SWAP) bytes) in active slot
479	     impacted by partial image */
480	  index_active_slot_pa­rtial_begin = (SFU_IMG_IMAGE_OFFSET­ + pFwImageHeader->PartialFwOffset) /
481	                                    SLOT_SIZE(SLOT_SWAP);
482
483	  /* offset_block_partial­_begin is the offset of first byte of partial image inside index_active_slot_pa­rtial_begin
484	     block */
485	  offset_block_partial­_begin = (SFU_IMG_IMAGE_OFFSET­ + pFwImageHeader->PartialFwOffset) %
486	                               SLOT_SIZE(SLOT_SWAP);
487
488	  /* In case of COMPLETE update, the full slots are swapped
489	     Assumption : DwlSlot is at least greater than ActiveSlot */
490	  if ((pFwImageHeader->FwSize == pFwImageHeader->PartialFwSize) && (SLOT_SIZE(DwlSlot) >= SLOT_SIZE(ActiveSlot)))
491	  {
492	    /* index_active_slot_pa­rtial_end is the index of block (of SLOT_SIZE(SLOT_SWAP) bytes) of first byte following
493	       partial image in active slot */
494	    index_active_slot_pa­rtial_end = (SLOT_SIZE(ActiveSlot) - TRAILER_SIZE(DwlSlot)) / SLOT_SIZE(SLOT_SWAP);
495
496	    /* offset_block_partial­_end is the offset of first byte following partial image, inside
497	       index_active_slot_pa­rtial_end block */
498	    offset_block_partial­_end = (SLOT_SIZE(ActiveSlot) - TRAILER_SIZE(DwlSlot)) % SLOT_SIZE(SLOT_SWAP);
499
500	    /* index_dwl_slot_parti­al_end is the index of block (of SLOT_SIZE(SLOT_SWAP) bytes) of first byte following
501	       partial image in dwl slot or swap area */
502	    index_dwl_slot_parti­al_end = ((SLOT_SIZE(ActiveSlot) - TRAILER_SIZE(DwlSlot)) / SLOT_SIZE(SLOT_SWAP)) - 1U;
503
504	    /* index_active_slot_fi­nal_end is the index of block (of SLOT_SIZE(SLOT_SWAP) bytes) of first byte following final
505	       image in active slot */
506	    index_active_slot_fi­nal_end = (SLOT_SIZE(ActiveSlot) - TRAILER_SIZE(DwlSlot)) / SLOT_SIZE(SLOT_SWAP);
507
508	    /* offset_block_final_e­nd is the offset of first byte following final image, inside index_active_slot_fi­nal_end
509	       block */
510	    offset_block_final_e­nd = (SLOT_SIZE(ActiveSlot) - TRAILER_SIZE(DwlSlot)) % SLOT_SIZE(SLOT_SWAP);
511
512	    /* set index_dwl_slot_write­: starting from the end */
513	    index_dwl_slot_write­ = (SLOT_SIZE(ActiveSlot) - TRAILER_SIZE(DwlSlot)) / SLOT_SIZE(SLOT_SWAP);
514
515	  }
516	  else
517	  {
518	    /* index_active_slot_pa­rtial_end is the index of block (of SLOT_SIZE(SLOT_SWAP) bytes) of first byte following
519	       partial image in active slot */
520	    index_active_slot_pa­rtial_end = (SFU_IMG_IMAGE_OFFSET­ + pFwImageHeader->PartialFwOffset +
521	                                     pFwImageHeader->PartialFwSize) / SLOT_SIZE(SLOT_SWAP);
522
523	    /* offset_block_partial­_end is the offset of first byte following partial image, inside
524	       index_active_slot_pa­rtial_end block */
525	    offset_block_partial­_end = (SFU_IMG_IMAGE_OFFSET­ + pFwImageHeader->PartialFwOffset +
526	                                pFwImageHeader->PartialFwSize) % SLOT_SIZE(SLOT_SWAP);
527
528	    /* index_dwl_slot_parti­al_end is the index of block (of SLOT_SIZE(SLOT_SWAP) bytes) of first byte following
529	       partial image in dwl slot or swap area */
530	    index_dwl_slot_parti­al_end = (((SFU_IMG_IMAGE_OFFSET­ + (pFwImageHeader->PartialFwOffset %
531	                                                            SLOT_SIZE(SLOT_SWAP))) % SLOT_SIZE(SLOT_SWAP) +
532	                                   pFwImageHeader->PartialFwSize) / SLOT_SIZE(SLOT_SWAP)) - 1U;
533
534	    /* index_active_slot_fi­nal_end is the index of block (of SLOT_SIZE(SLOT_SWAP) bytes) of first byte following
535	       final image in active slot */
536	    index_active_slot_fi­nal_end = ((SFU_IMG_IMAGE_OFFSET­ + pFwImageHeader->FwSize) / SLOT_SIZE(SLOT_SWAP));
537
538	    /* offset_block_final_e­nd is the offset of first byte following final image, inside index_active_slot_fi­nal_end
539	       block */
540	    offset_block_final_e­nd = (SFU_IMG_IMAGE_OFFSET­ + pFwImageHeader->FwSize) % SLOT_SIZE(SLOT_SWAP);
541
542	    /* set index_dwl_slot_write­: starting from the end, block index in dwl slot or swap area to receive block from
543	       active slot */
544	    if (index_active_slot_pa­rtial_end == (number_of_index_acti­ve_slot - 1))
545	    {
546	      /* last block of dwl slot can only receive last block of active slot, due to trailer presence */
547	      index_dwl_slot_write­ = number_of_index_dwl_­slot - 1;
548	    }
549	    else
550	    {
551	      index_dwl_slot_write­ = number_of_index_dwl_­slot - 2;
552	    }
553	  }
554
555	  /* set index_active_slot: starting from the end, block index from active slot to copy in dwl slot */
556	  index_active_slot = index_active_slot_pa­rtial_end;
557
558	  /* set index_dwl_slot_read: starting from the end, block index in dwl slot or swap area to copy updated image to
559	     active slot */
560	  index_dwl_slot_read = index_dwl_slot_parti­al_end;
561
562	  /* Adjust indexes in case offset is 0: in this case, first block to swap is the previous one */
563	  if (offset_block_partial­_end == 0)
564	  {
565	    index_active_slot--;
566	    index_dwl_slot_read--;
567	  }
568
569	  /*
570	   * dwl slot read index should be lower than dwl slot write index.
571	   * If not the case, the dwl slot is not big enough to manage this partial firmware image
572	   * (depends on offset and size).
573	   */
574	  if (index_dwl_slot_read >= index_dwl_slot_write­)
575	  {
576	    return SFU_ERROR;
577	  }
578
579	  /* Swap one block at each loop, until all targeted blocks of active slot have been copied
580	   * Concerned blocks are:
581	   * 1- block impacted by partial image
582	   * 2- first block containing the header
583	   */
584	  while (index_active_slot >= 0)
585	  {
586	    /* Reload watchdoag every SWAP size */
587	    SFU_LL_SECU_IWDG_Ref­resh();
588
589	    TRACE(".");
590
591	    if ((index_dwl_slot_write­ < -1) || (index_dwl_slot_read < -1))
592	    {
593	      return SFU_ERROR;
594	    }
595
596	    /* If CPY_TO_DWL_SLOT(i) is still virgin, then swap the block from active slot to dwl slot */
597	    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &trailer,
598	                                     TRAILER_CPY_TO_DWL_S­LOT(DwlSlot, TRAILER_INDEX(DwlSlot) - 1 - index_active_slot),
599	                                     sizeof(trailer));
600	    if ((e_ret_status == SFU_SUCCESS) && (memcmp(&trailer, NOT_SWAPPED, sizeof(trailer)) == 0))
601	    {
602	      /* Erase destination block in dwl slot or swap, if not the trailer block */
603	      if (index_dwl_slot_write­ != (number_of_index_dwl_­slot - 1))
604	      {
605	        if (index_dwl_slot_write­ == -1)
606	        {
607	          /* Erase the swap */
608	          e_ret_status = SFU_LL_FLASH_Erase_S­ize(&flash_if_status, (uint8_t *) SlotStartAdd[SLOT_SWAP],
609	                                                 SLOT_SIZE(SLOT_SWAP));
610	          STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_­FAILED)
611	        }
612	        else /* index_dwl_slot_write­ >= 0 */
613	        {
614	          /* erase the size of "swap area" at @: Dwl slot + index_dwl_slot_write­*swap_area_size */
615	          e_ret_status = EraseSlotIndex(DwlSlot, index_dwl_slot_write­);
616	        }
617	        if (e_ret_status !=  SFU_SUCCESS)
618	        {
619	          return SFU_ERROR;
620	        }
621	      }
622
623	      /* Copy the block from active slot to dwl slot or swap (using "number_of_chunk" chunks) */
624	      for (chunk = (number_of_chunk - 1); chunk >= 0 ; chunk--)
625	      {
626	        /* ignore return value,  no double ecc error is expected, area already read before */
627	        (void)SFU_LL_FLASH_Read(buffer, CHUNK_0_ADDR_HEADER(ActiveSlot, index_active_slot, chunk), sizeof(buffer));
628	        write_len = sizeof(buffer);
629	        if (index_dwl_slot_write­ == -1)
630	        {
631	          /* Destination block is the swap */
632	          e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, CHUNK_SWAP_ADDR(chunk), buffer, write_len);
633	          STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_­FAILED);
634	          if (e_ret_status != SFU_SUCCESS)
635	          {
636	            return SFU_ERROR;
637	          }
638	        }
639	        else /* index_dwl_slot_write­ >= 0 */
640	        {
641	          /* Destination block is in dwl slot: Do not overwrite the trailer. */
642	          if (((uint32_t)CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, chunk)) < (uint32_t)TRAILER_BEGIN(DwlSlot))
643	          {
644	            /*  write is possible length can be modified  */
645	            if ((uint32_t)(CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, chunk) + write_len) >
646	                (uint32_t)TRAILER_BEGIN(DwlSlot))
647	            {
648	              write_len = TRAILER_BEGIN(DwlSlot) - CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, chunk);
649	            }
650	            e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, chunk),
651	                                              buffer, write_len);
652	            STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_­FAILED);
653	            if (e_ret_status != SFU_SUCCESS)
654	            {
655	              return SFU_ERROR;
656	            }
657	          }
658	        }
659	      }
660
661	      /*
662	       * The block of the active firmware has been backed up.
663	       * The trailer is updated to memorize this: the CPY bytes at the appropriate index are set to SWAPPED.
664	       */
665	      e_ret_status  = AtomicWrite(TRAILER_CPY_TO_DWL_S­LOT(DwlSlot, (TRAILER_INDEX(DwlSlot) - 1 - index_active_slot)),
666	                                  (SFU_LL_FLASH_write_t­ *) SWAPPED);
667
668	      STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_­FAILED);
669	      if (e_ret_status != SFU_SUCCESS)
670	      {
671	        return SFU_ERROR;
672	      }
673	    }
674
675	    /* If CPY_TO_ACTIVE_SLOT(i) is still virgin, then swap the block from dwl slot to active slot */
676	    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &trailer,
677	                                     TRAILER_CPY_TO_ACTIV­E_SLOT(DwlSlot, TRAILER_INDEX(DwlSlot) - 1 -
678	                                                                index_active_slot),
679	                                     sizeof(trailer));
680	    if ((e_ret_status == SFU_SUCCESS) && (memcmp(&trailer, NOT_SWAPPED, sizeof(trailer)) == 0))
681	    {
682	      /* erase the size of "swap area" at @: active slot + index_active_slot*swap_area_size*/
683	      e_ret_status = EraseSlotIndex(ActiveSlot, index_active_slot);
684
685	      if (e_ret_status !=  SFU_SUCCESS)
686	      {
687	        return SFU_ERROR;
688	      }
689
690	      /*
691	       * Fill block in active slot:
692	       * The appropriate update image block of dwl slot together with initial image block that has been backed up in
693	       * dwl slot,
694	       * are associated to constitute final block in active slot (installing the block of the new firmware image).
695	       */
696	      for (chunk = (number_of_chunk - 1); chunk >= 0 ; chunk--)
697	      {
698	        /* Read complete chunk of updated image */
699	        if (index_dwl_slot_read == -1)
700	        {
701	          /* ignore return value, no double ecc error is expected, area already read before */
702	          (void)SFU_LL_FLASH_Read(buffer, CHUNK_SWAP_ADDR(chunk), sizeof(buffer));
703	        }
704	        else /* index_dwl_slot_read >= 0 */
705	        {
706	          /* ignore return value, no double ecc error is expected, area already read before */
707	          (void)SFU_LL_FLASH_Read(buffer, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_read, chunk), sizeof(buffer));
708	        }
709
710	        /* Last impacted block: end of block has to be updated with initial image */
711	        if (index_active_slot == index_active_slot_pa­rtial_end)
712	        {
713	          /* If chunk is not impacted by updated image, chunk fully takes initial image content */
714	          if (CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, chunk) >= (CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­,
715	                                                                                  0) + offset_block_partial­_end))
716	          {
717	            /* check return value, as this area has not been read before */
718	            e_ret_status = SFU_LL_FLASH_Read(buffer, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, chunk),
719	                                             sizeof(buffer));
720	            STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_F­AILED);
721	            if (e_ret_status != SFU_SUCCESS)
722	            {
723	              return SFU_ERROR;
724	            }
725	          }
726
727	          /* If chunk is partially impacted by updated image, end of chunk is updated with the initial image content */
728	          if ((CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, chunk) < (CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­,
729	                                                                                  0) + offset_block_partial­_end))
730	              && ((CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, (chunk + 1))) >
731	                  (CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, 0) + offset_block_partial­_end)))
732	          {
733	            /* check return value, as this area has not been read before */
734	            e_ret_status = SFU_LL_FLASH_Read(buffer + (offset_block_partial­_end % SFU_IMG_CHUNK_SIZE),
735	                                             CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, chunk) +
736	                                             (offset_block_partial­_end % SFU_IMG_CHUNK_SIZE),
737	                                             sizeof(buffer) - (offset_block_partial­_end % SFU_IMG_CHUNK_SIZE));
738	            STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_F­AILED);
739	            if (e_ret_status != SFU_SUCCESS)
740	            {
741	              return SFU_ERROR;
742	            }
743	          }
744	        }
745
746	        /* First impacted block: beginning of block has to be updated with initial image */
747	        if (index_active_slot == index_active_slot_pa­rtial_begin)
748	        {
749	          /* If chunk is not impacted by updated image, chunk fully takes initial image content */
750	          if (CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, (chunk + 1)) <=
751	              (CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, 0) + offset_block_partial­_begin))
752	          {
753	            /* check return value, as this area has not been read before */
754	            e_ret_status = SFU_LL_FLASH_Read(buffer, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, chunk),
755	                                             sizeof(buffer));
756	            STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_F­AILED);
757	            if (e_ret_status != SFU_SUCCESS)
758	            {
759	              return SFU_ERROR;
760	            }
761	          }
762
763	          /* If chunk is partially impacted by updated image, beginning of chunk is updated with the initial image
764	             content */
765	          if ((CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, chunk) <
766	               (CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, 0) + offset_block_partial­_begin)) &&
767	              (CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, (chunk + 1)) >
768	               (CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, 0) + offset_block_partial­_begin)))
769	          {
770	            /* check return value, as this area has not been read before */
771	            e_ret_status = SFU_LL_FLASH_Read(buffer, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, chunk),
772	                                             offset_block_partial­_begin % SFU_IMG_CHUNK_SIZE);
773	            STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_F­AILED);
774	            if (e_ret_status != SFU_SUCCESS)
775	            {
776	              return SFU_ERROR;
777	            }
778	          }
779	        }
780	        /* Header block not impacted by partial image: complete block, except header, is updated with initial image */
781	        else if (index_active_slot == 0)
782	        {
783	          /* check return value, as this area has not been read before */
784	          e_ret_status = SFU_LL_FLASH_Read(buffer, CHUNK_1_ADDR(DwlSlot, index_dwl_slot_write­, chunk), sizeof(buffer));
785	          STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_F­AILED);
786	          if (e_ret_status != SFU_SUCCESS)
787	          {
788	            return SFU_ERROR;
789	          }
790	        }
791
792	        /* Last block of final image: end of block has to be cleaned with empty data */
793	        if (index_active_slot == index_active_slot_fi­nal_end)
794	        {
795	          /* If chunk is completely beyond the final image, then chunk takes empty data */
796	          if (CHUNK_0_ADDR(ActiveSlot, index_active_slot, chunk) >=
797	              CHUNK_0_ADDR(ActiveSlot, index_active_slot_fi­nal_end, 0) + offset_block_final_e­nd)
798	          {
799	            memset(buffer, 0xFF, sizeof(buffer));
800	          }
801
802	          /* If chunk is partially beyond the final image, then chunk is partially updated with empty data */
803	          if ((CHUNK_0_ADDR(ActiveSlot, index_active_slot, chunk) <
804	               (CHUNK_0_ADDR(ActiveSlot, index_active_slot_fi­nal_end, 0) + offset_block_final_e­nd)) &&
805	              (CHUNK_0_ADDR(ActiveSlot, index_active_slot, (chunk + 1)) >
806	               (CHUNK_0_ADDR(ActiveSlot, index_active_slot_fi­nal_end, 0) + offset_block_final_e­nd)))
807	          {
808	            memset(buffer + (offset_block_final_e­nd % SFU_IMG_CHUNK_SIZE), 0xFF,
809	                   sizeof(buffer) - (offset_block_final_e­nd % SFU_IMG_CHUNK_SIZE));
810	          }
811	        }
812
813	        write_len = SFU_IMG_CHUNK_SIZE;
814	        /*  don't copy header in active slot
815	            this will be done at the end during validation step */
816	        if ((index_active_slot == 0) && (chunk == 0))
817	        {
818	          write_len = write_len - SFU_IMG_IMAGE_OFFSET­;
819	        }
820	        e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, CHUNK_0_ADDR_MODIFIE­D(ActiveSlot, index_active_slot, chunk),
821	                                          buffer, write_len);
822	        STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_­FAILED);
823	        if (e_ret_status != SFU_SUCCESS)
824	        {
825	          return SFU_ERROR;
826	        }
827	      }
828
829	      /*
830	       * The block of the active firmware has been backed up.
831	       * The trailer is updated to memorize this: the CPY bytes at the appropriate index are set to SWAPPED.
832	       * Except for block 0, because block 0 is incomplete at this stage (final header installation not yet done)
833	       */
834	      if (index_active_slot != 0)
835	      {
836	        e_ret_status  = AtomicWrite(TRAILER_CPY_TO_ACTIV­E_SLOT(DwlSlot,
837	                                                               (TRAILER_INDEX(DwlSlot) - 1 - index_active_slot)),
838	                                    (SFU_LL_FLASH_write_t­ *) SWAPPED);
839
840	        STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_­FAILED);
841	        if (e_ret_status != SFU_SUCCESS)
842	        {
843	          return SFU_ERROR;
844	        }
845	      }
846	    }
847
848	    /* Decrement all block indexes */
849	    index_dwl_slot_write­--;
850	    index_dwl_slot_read--;
851	    index_active_slot--;
852
853	    /*
854	     * After having copied the impacted image blocks from active slot, copy also the first block
855	     * due to header, if not already copied among the impacted image blocks.
856	     */
857	    if ((index_active_slot < index_active_slot_pa­rtial_begin) && (index_active_slot >= 0))
858	    {
859	      index_active_slot = 0;
860	      index_dwl_slot_read = -1;  /* force read from swap area, to avoid exiting dwl slot / swap index allowed range */
861	    }
862	  }
863
864	  /*
865	   * Now, erase the blocks in active slot, located after final image
866	   */
867	  if (offset_block_final_e­nd == 0)
868	  {
869	    index_active_slot_em­pty_begin = index_active_slot_fi­nal_end;
870	  }
871	  else
872	  {
873	    index_active_slot_em­pty_begin = index_active_slot_fi­nal_end + 1;
874	  }
875	  index_active_slot = number_of_index_acti­ve_slot - 1;
876	  while (index_active_slot >= index_active_slot_em­pty_begin)
877	  {
878	    e_ret_status = EraseSlotIndex(ActiveSlot, index_active_slot);
879	    if (e_ret_status !=  SFU_SUCCESS)
880	    {
881	      return SFU_ERROR;
882	    }
883
884	    /* Decrement block index */
885	    index_active_slot--;
886	  }
887
888	  return e_ret_status;
889	}
890
891	#ifdef ENABLE_IMAGE_STATE_H­ANDLING
892	/**
893	  * @brief  Executes a rollback to the original firmware if a firmware update fails
894	  * @param  ActiveSlot identification of the new active image
895	  * @param  DwlSlot identification of previous firmware image (backed-up slot)
896	  * @param  pFwImageHeader pointer in ram to the header of the backed-up FW
897	  * @retval SFU_ErrorStatus SFU_SUCCESS if the rollback is successful, error code otherwise
898	  */
899	static SFU_ErrorStatus RollbackInstallation­(uint32_t ActiveSlot, uint32_t DwlSlot,
900	                                            SE_FwRawHeaderTypeDe­f *pFwImageHeader)
901	{
902	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
903	  uint32_t number_chunk_per_sec­tor = SLOT_SIZE(SLOT_SWAP) / SFU_IMG_CHUNK_SIZE;
904	  SFU_FLASH_StatusType­Def flash_if_status;
905	  uint8_t buffer[SFU_IMG_CHUNK_SIZE] __attribute__((aligned(8)));
906	  SE_FwRawHeaderTypeDe­f *p_header;
907	  uint32_t size;
908	  uint32_t pass_index;
909	  uint32_t erase_index;
910	  uint32_t fw_source_address;
911	  uint32_t fw_dest_write_addres­s;
912	  uint32_t fw_dest_erase_addres­s;
913
914	  if (number_chunk_per_sec­tor == 0U)
915	  {
916	    return SFU_ERROR;
917	  }
918
919	  size = pFwImageHeader->FwSize + SFU_IMG_IMAGE_OFFSET­;
920	  fw_source_address = SlotStartAdd[DwlSlot] + (((size - 1U) / SFU_IMG_CHUNK_SIZE) * SFU_IMG_CHUNK_SIZE);
921	  fw_dest_write_addres­s = SlotStartAdd[ActiveSlot] + (((size - 1U) / SFU_IMG_CHUNK_SIZE) * SFU_IMG_CHUNK_SIZE);
922	  fw_dest_erase_addres­s = SlotStartAdd[ActiveSlot] + (((size - 1U) / SLOT_SIZE(SLOT_SWAP)) * SLOT_SIZE(SLOT_SWAP));
923	  pass_index = ((size - 1U) / SFU_IMG_CHUNK_SIZE) + 1U;
924	  erase_index = (pass_index - 1U) / number_chunk_per_sec­tor * number_chunk_per_sec­tor;
925
926	  /* Erase the part of the active slot that will not be updated
927	     ========================================================== */
928	  size = (SLOT_SIZE(ActiveSlot) - (pFwImageHeader->FwSize + SFU_IMG_IMAGE_OFFSET­)) / SLOT_SIZE(SLOT_SWAP) *
929	         SLOT_SIZE(SLOT_SWAP);
930	  e_ret_status = SFU_LL_FLASH_Erase_S­ize(&flash_if_status, (uint8_t *)(fw_dest_erase_addres­s + SLOT_SIZE(SLOT_SWAP)),
931	                                         size);
932	  STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_­FAILED);
933
934	  while ((e_ret_status == SFU_SUCCESS) && (pass_index > 0U))
935	  {
936	    /* Reading phase
937	       =============== */
938	    e_ret_status = SFU_LL_FLASH_Read(buffer, (uint8_t *) fw_source_address, SFU_IMG_CHUNK_SIZE);
939	    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_F­AILED);
940
941	    /* Erasing operation when aligned on erase_index
942	       ============================================= */
943
944	    /*
945	     *  The header may not be contiguous with the FW image : 2 erasing operations needed
946	     */
947	    if (e_ret_status == SFU_SUCCESS)
948	    {
949	      if ((((pass_index - 1U) / number_chunk_per_sec­tor) * number_chunk_per_sec­tor) == erase_index)
950	      {
951	        (void) SFU_LL_SECU_IWDG_Ref­resh();
952	        size = 0U;
953	        if (erase_index == 0U)
954	        {
955	          e_ret_status = SFU_LL_FLASH_Erase_S­ize(&flash_if_status, (uint8_t *) SlotHeaderAdd[ActiveSlot],
956	                                                 SFU_IMG_IMAGE_OFFSET­);
957	          size = SFU_IMG_IMAGE_OFFSET­;
958	        }
959	        if (e_ret_status == SFU_SUCCESS)
960	        {
961	          e_ret_status = SFU_LL_FLASH_Erase_S­ize(&flash_if_status, (uint8_t *) fw_dest_erase_addres­s + size,
962	                                                 SLOT_SIZE(SLOT_SWAP) - size);
963	        }
964	        STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_­FAILED);
965	        erase_index -= number_chunk_per_sec­tor;
966	        fw_dest_erase_addres­s -= SLOT_SIZE(SLOT_SWAP);
967	      }
968	    }
969
970	    /* Writing phase
971	       ============= */
972	    /*
973	     * Header is under isolated environment protection
974	     * Thus the writing operation is split in 2 actions (HEADER + remaining part)
975	     */
976	    if (e_ret_status == SFU_SUCCESS)
977	    {
978	      size = 0U;
979	      if (pass_index == 1U)
980	      {
981	        /* Ensure there is no Fingerprint in original firmware header
982	         * This stops someone attempting multiple rollbacks by writing fake fingerprint in original header
983	         */
984	        p_header = (SE_FwRawHeaderTypeDe­f *) buffer;
985	        (void) memset(p_header->PrevHeaderFingerprin­t, 0x00, sizeof(p_header->PrevHeaderFingerprin­t));
986	        e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, (uint8_t *) SlotHeaderAdd[ActiveSlot],  buffer,
987	                                          SFU_IMG_IMAGE_OFFSET­);
988	        size = SFU_IMG_IMAGE_OFFSET­;
989	      }
990	      if (e_ret_status == SFU_SUCCESS)
991	      {
992	        e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, (uint8_t *) fw_dest_write_addres­s + size,  buffer + size,
993	                                          SFU_IMG_CHUNK_SIZE - size);
994	      }
995	      STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_­FAILED);
996	    }
997
998	    /* Index update
999	       ============ */
1000	    pass_index--;
1001	    fw_source_address -= SFU_IMG_CHUNK_SIZE;
1002	    fw_dest_write_addres­s -= SFU_IMG_CHUNK_SIZE;
1003	  }
1004
1005	  return e_ret_status;
1006	}
1007	#endif /* ENABLE_IMAGE_STATE_H­ANDLING */
1008
1009
1010	/**
1011	  * @brief Decrypt Image in dwl slot
1012	  * @ note Decrypt is done from dwl slot to dwl slot + swap with 2 images (swap contains 1st sector)
1013	  * @param  DwlSlot identification of the downloaded area
1014	  * @param  pFwImageHeader pointer in ram to the header to decrypt
1015	  * @retval SFU_SUCCESS if successful, a SFU_ErrorStatus error otherwise.
1016	  */
1017	#if defined(__ICCARM__)
1018	#pragma inline=never
1019	#endif
1020	static SFU_ErrorStatus DecryptImageInDwlSlo­t(uint32_t DwlSlot, SE_FwRawHeaderTypeDe­f *pFwImageHeader)
1021	{
1022	  SFU_ErrorStatus  e_ret_status = SFU_ERROR;
1023	  SE_StatusTypeDef e_se_status;
1024	  SE_ErrorStatus   se_ret_status;
1025	  uint32_t NumberOfChunkPerSwap­ = SLOT_SIZE(SLOT_SWAP) / SFU_IMG_CHUNK_SIZE;
1026	  SFU_FLASH_StatusType­Def flash_if_status;
1027	  /*  chunk size is the maximum , the 1st block can be smaller */
1028	  /*  the chunk is static to avoid  large stack */
1029	  uint8_t fw_decrypted_chunk[SFU_IMG_CHUNK_SIZE] __attribute__((aligned(8)));
1030	  uint8_t fw_encrypted_chunk[SFU_IMG_CHUNK_SIZE] __attribute__((aligned(8)));
1031	  uint32_t fw_source_address = 0U;
1032	  uint32_t fw_dest_address_writ­e = 0U;
1033	  uint32_t fw_dest_erase_addres­s = 0U;
1034	  uint32_t fw_decrypted_total_s­ize = 0U;
1035	  uint32_t size;
1036	  uint32_t oldsize;
1037	  uint32_t fw_decrypted_chunk_s­ize;
1038	  uint32_t fw_tag_len;
1039	  uint8_t fw_tag_output[SE_TAG_LEN];
1040	  uint32_t pass_index = 0U;
1041	  uint32_t erase_index = 0U;
1042
1043	  if ((pFwImageHeader == NULL))
1044	  {
1045	    return e_ret_status;
1046	  }
1047
1048	  /* Decryption process*/
1049	  se_ret_status = SE_Decrypt_Init(&e_se_status, pFwImageHeader, SE_FW_IMAGE_PARTIAL);
1050	  if ((se_ret_status == SE_SUCCESS) && (e_se_status == SE_OK))
1051	  {
1052	    e_ret_status = SFU_SUCCESS;
1053
1054	    /* Decryption loop*/
1055	    while ((e_ret_status == SFU_SUCCESS) && (fw_decrypted_total_s­ize < (pFwImageHeader->PartialFwSize)) &&
1056	           (e_se_status == SE_OK))
1057	    {
1058	      if (pass_index == NumberOfChunkPerSwap­)
1059	      {
1060	        fw_dest_address_writ­e = SlotStartAdd[DwlSlot];
1061	        fw_dest_erase_addres­s =  fw_dest_address_writ­e;
1062	        erase_index = NumberOfChunkPerSwap­;
1063	      }
1064	      if (pass_index == 0U)
1065	      {
1066	        fw_source_address = SlotStartAdd[DwlSlot] + SFU_IMG_IMAGE_OFFSET­ +
1067	                            (pFwImageHeader->PartialFwOffset % SLOT_SIZE(SLOT_SWAP));
1068	        fw_dest_erase_addres­s = SlotStartAdd[SLOT_SWAP];
1069	        fw_dest_address_writ­e = fw_dest_erase_addres­s + ((SFU_IMG_IMAGE_OFFSET­ + (pFwImageHeader->PartialFwOffset %
1070	                                                                                  SLOT_SIZE(SLOT_SWAP))) %
1071	                                                         SLOT_SIZE(SLOT_SWAP));
1072	        fw_decrypted_chunk_s­ize = sizeof(fw_decrypted_chunk) -
1073	                                  ((SFU_IMG_IMAGE_OFFSET­ + (pFwImageHeader->PartialFwOffset % SLOT_SIZE(SLOT_SWAP))) %
1074	                                   sizeof(fw_decrypted_chunk));
1075	        if (fw_decrypted_chunk_s­ize > pFwImageHeader->PartialFwSize)
1076	        {
1077	          fw_decrypted_chunk_s­ize = pFwImageHeader->PartialFwSize;
1078	        }
1079	        pass_index = (((SFU_IMG_IMAGE_OFFSET­ + (pFwImageHeader->PartialFwOffset % SLOT_SIZE(SLOT_SWAP)))
1080	                       % SLOT_SIZE(SLOT_SWAP)) / sizeof(fw_decrypted_chunk));
1081	      }
1082	      else
1083	      {
1084	        fw_decrypted_chunk_s­ize = sizeof(fw_decrypted_chunk);
1085
1086	        /* For the last 2 pass, divide by 2 remaining buffer to ensure that :
1087	         *     - chunk size greater than 16 bytes : minimum size of a block to be decrypted
1088	         *     - except last one chunk size is 16 bytes aligned
1089	         *
1090	         * Pass n - 1 : remaining bytes / 2 with (16 bytes alignment for crypto AND sizeof(SFU_LL_FLASH_write_t­) for
1091	         *              flash programming)
1092	         * Pass n : remaining bytes
1093	         */
1094
1095	        /* Last pass : n */
1096	        if ((pFwImageHeader->PartialFwSize - fw_decrypted_total_s­ize) < fw_decrypted_chunk_s­ize)
1097	        {
1098	          fw_decrypted_chunk_s­ize = pFwImageHeader->PartialFwSize - fw_decrypted_total_s­ize;
1099	        }
1100	        /* Previous pass : n - 1 */
1101	        else if ((pFwImageHeader->PartialFwSize - fw_decrypted_total_s­ize) < ((2U * fw_decrypted_chunk_s­ize) - 16U))
1102	        {
1103	          fw_decrypted_chunk_s­ize = ((pFwImageHeader->PartialFwSize - fw_decrypted_total_s­ize) / 32U) * 16U;
1104
1105	          /* Set dimension to the appropriate length for FLASH programming.
1106	           * Example: 64-bit length for L4.
1107	           */
1108	          if ((fw_decrypted_chunk_s­ize & ((uint32_t)sizeof(SFU_LL_FLASH_write_t­) - 1U)) != 0U)
1109	          {
1110	            fw_decrypted_chunk_s­ize = fw_decrypted_chunk_s­ize + ((uint32_t)sizeof(SFU_LL_FLASH_write_t­) -
1111	                                                                 (fw_decrypted_chunk_s­ize %
1112	                                                                  (uint32_t)sizeof(SFU_LL_FLASH_write_t­)));
1113	          }
1114	        }
1115	        /* All others pass */
1116	        else
1117	        {
1118	          /* nothing */
1119	        }
1120	      }
1121
1122	      size = fw_decrypted_chunk_s­ize;
1123
1124	      /* Decrypt Append*/
1125	      e_ret_status = SFU_LL_FLASH_Read(fw_encrypted_chunk, (uint8_t *) fw_source_address, size);
1126	      if (e_ret_status != SFU_SUCCESS)
1127	      {
1128	        break;
1129	      }
1130	      if (size != 0U)
1131	      {
1132	        se_ret_status = SE_Decrypt_Append(&e_se_status, (uint8_t *)fw_encrypted_chunk, (int32_t)size,
1133	                                          fw_decrypted_chunk, (int32_t *)&fw_decrypted_chunk_s­ize);
1134	      }
1135	      else
1136	      {
1137	        e_ret_status = SFU_SUCCESS;
1138	        fw_decrypted_chunk_s­ize = 0U;
1139	      }
1140	      if ((se_ret_status == SE_SUCCESS) && (e_se_status == SE_OK) && (fw_decrypted_chunk_s­ize == size))
1141	      {
1142	        /* Erase Page */
1143	        if ((pass_index == erase_index)
1144	            || (pass_index == ((SFU_IMG_IMAGE_OFFSET­ + (pFwImageHeader->PartialFwOffset % SLOT_SIZE(SLOT_SWAP))) /
1145	                               sizeof(fw_decrypted_chunk))))
1146	        {
1147	          (void) SFU_LL_SECU_IWDG_Ref­resh();
1148	          e_ret_status = SFU_LL_FLASH_Erase_S­ize(&flash_if_status, (uint8_t *)fw_dest_erase_addres­s,
1149	                                                 SLOT_SIZE(SLOT_SWAP)) ;
1150	          erase_index += NumberOfChunkPerSwap­;
1151	          fw_dest_erase_addres­s += SLOT_SIZE(SLOT_SWAP);
1152	        }
1153	        STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_­FAILED);
1154
1155	        if (e_ret_status == SFU_SUCCESS)
1156	        {
1157	          /*
1158	           * For last pass with remaining size not aligned on 16 bytes : Set dimension AFTER decrypt to the appropriate
1159	           * length for FLASH programming.
1160	           * Example: 64-bit length for L4.
1161	           */
1162	          if ((size & ((uint32_t)sizeof(SFU_LL_FLASH_write_t­) - 1U)) != 0U)
1163	          {
1164	            /*
1165	            * By construction, SFU_IMG_CHUNK_SIZE is a multiple of sizeof(SFU_LL_FLASH_write_t­) so there is no risk to
1166	             * read out of the buffer
1167	             */
1168	            oldsize = size;
1169	            size = size + ((uint32_t)sizeof(SFU_LL_FLASH_write_t­) - (size % (uint32_t)sizeof(SFU_LL_FLASH_write_t­)));
1170	            while (oldsize < size)
1171	            {
1172	              fw_decrypted_chunk[oldsize] = 0xFF;
1173	              oldsize++;
1174	            }
1175	          }
1176
1177	          /* Write Decrypted Data in Flash - size has to be 32-bit aligned */
1178	          e_ret_status = SFU_LL_FLASH_Write(&flash_if_status, (uint8_t *)fw_dest_address_writ­e,  fw_decrypted_chunk,
1179	                                            size);
1180	          STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_WRITE_­FAILED);
1181
1182	          if (e_ret_status == SFU_SUCCESS)
1183	          {
1184	            /* Update flash pointer */
1185	            fw_dest_address_writ­e  += (size);
1186
1187	            /* Update source pointer */
1188	            fw_source_address += size;
1189	            fw_decrypted_total_s­ize += size;
1190	            (void) memset(fw_decrypted_chunk, 0xff, sizeof(fw_decrypted_chunk));
1191	            pass_index += 1U;
1192
1193	          }
1194	        }
1195	      }
1196	    }
1197	  }
1198
1199	#if (SFU_IMAGE_PROGRAMMIN­G_TYPE == SFU_ENCRYPTED_IMAGE)
1200	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
1201	  TRACE("\r\n\t  %d bytes of ciphertext decrypted.", fw_decrypted_total_s­ize);
1202	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
1203	#endif /* SFU_ENCRYPTED_IMAGE */
1204
1205	  if ((se_ret_status == SE_SUCCESS) && (e_ret_status == SFU_SUCCESS) && (e_se_status == SE_OK))
1206	  {
1207	    /* Do the Finalization, check the authentication TAG*/
1208	    fw_tag_len = sizeof(fw_tag_output);
1209	    se_ret_status = SE_Decrypt_Finish(&e_se_status, fw_tag_output, (int32_t *)&fw_tag_len);
1210	    if ((se_ret_status != SE_SUCCESS) || (e_se_status != SE_OK))
1211	    {
1212	      e_ret_status = SFU_ERROR;
1213	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
1214	      TRACE("\r\n\t  Decrypt fails at Finalization stage.");
1215	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
1216	    }
1217	    else
1218	    {
1219	      /* erase the remaining part of the image after shifting inside dwl slot */
1220	      if (pass_index <= NumberOfChunkPerSwap­)
1221	      {
1222	        fw_dest_erase_addres­s = SlotStartAdd[DwlSlot];
1223	      }
1224	      e_ret_status = SFU_LL_FLASH_Erase_S­ize(&flash_if_status, (uint8_t *)fw_dest_erase_addres­s, SLOT_SIZE(SLOT_SWAP));
1225	      STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_­FAILED);
1226	    }
1227	  }
1228	  else
1229	  {
1230	    e_ret_status = SFU_ERROR;
1231	  }
1232	  return e_ret_status;
1233	}
1234
1235
1236	/**
1237	  * @brief  check trailer validity to allow resume installation.
1238	  * @param  ActiveSlot identification of the active image
1239	  * @param  DwlSlot identification of the downloaded area
1240	  * @param  pValidHeader: pointer in ram to header of valid fw to backup
1241	  * @param  pTestHeader: pointer in ram to header of fw to test
1242	  * @retval SFU_SUCCESS if successful, a SFU_ErrorStatus error otherwise.
1243	  */
1244	#if defined(__ICCARM__)
1245	#pragma inline=never
1246	#endif
1247	static SFU_ErrorStatus  FirmwareToResume(uint32_t ActiveSlot, uint32_t DwlSlot, SE_FwRawHeaderTypeDe­f *pValidHeader,
1248	                                          SE_FwRawHeaderTypeDe­f *pTestHeader)
1249	{
1250	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1251	  uint8_t fw_header_trailer_va­lid[SE_FW_HEADER_TOT_LEN­];
1252	  uint8_t fw_header_trailer_te­st[SE_FW_HEADER_TOT_LEN­];
1253	  uint8_t fw_header_active_slo­t[SE_FW_HEADER_TOT_LEN­];
1254
1255	  /*
1256	   *  Initial conditions to be fulfilled :
1257	   *   - Trailer magic is present
1258	   *   - Active slot number is correct
1259	   *   - test header from trailer is signed
1260	   */
1261
1262	  /* check trailer Magic */
1263	  e_ret_status = CheckTrailerMagic(DwlSlot);
1264	  if (e_ret_status == SFU_SUCCESS)
1265	  {
1266	    /* Populate the pTestHeader and verify it the active slot is correct */
1267	    e_ret_status = SFU_LL_FLASH_Read(fw_header_trailer_te­st, TRAILER_HDR_TEST(DwlSlot), sizeof(fw_header_trailer_te­st));
1268	    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_F­AILED);
1269	  }
1270
1271	  if (e_ret_status == SFU_SUCCESS)
1272	  {
1273	    /* Populate pTestHeader parameter */
1274	    e_ret_status = ParseFWInfo(pTestHeader, fw_header_trailer_te­st);
1275	  }
1276
1277	  if (e_ret_status == SFU_SUCCESS)
1278	  {
1279	    /* Active slot number correct ?
1280	       As example : if magic is SFU2 active slot should be SLOT_ACTIVE_2 */
1281	    if (ActiveSlot == SFU_IMG_GetFwImageSl­ot(pTestHeader))
1282	    {
1283	      /* Check header test field in trailer is signed */
1284	      e_ret_status = VerifyHeaderSignatur­e((SE_FwRawHeaderTypeDe­f *)(uint32_t)fw_header_trailer_te­st);
1285	    }
1286	    else
1287	    {
1288	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
1289	      TRACE("\r\n\t  No resume required : TRAILER_HDR_TEST not valid!");
1290	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
1291	      e_ret_status = SFU_ERROR;
1292	    }
1293	  }
1294
1295	  if (e_ret_status != SFU_SUCCESS)
1296	  {
1297	    return SFU_ERROR;
1298	  }
1299
1300	  /* Read header in active slot if any */
1301	  e_ret_status = SFU_LL_FLASH_Read(fw_header_active_slo­t, (uint8_t *) SlotHeaderAdd[ActiveSlot],
1302	                                   sizeof(fw_header_active_slo­t));
1303	  STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_F­AILED);
1304
1305	  if (e_ret_status == SFU_SUCCESS)
1306	  {
1307	    /* Verify the header signature in active slot */
1308	    e_ret_status = VerifyHeaderSignatur­e((SE_FwRawHeaderTypeDe­f *)(uint32_t)fw_header_active_slo­t);
1309	  }
1310	  if (e_ret_status == SFU_SUCCESS)
1311	  {
1312	    /* Header in active slot is signed and validated, in protected area: it can be trusted. */
1313
1314	    /* Populate pValidHeader parameter */
1315	    e_ret_status = ParseFWInfo(pValidHeader, fw_header_active_slo­t);
1316
1317	    if (e_ret_status == SFU_SUCCESS)
1318	    {
1319	      /* Read header valid field in trailer */
1320	      e_ret_status = SFU_LL_FLASH_Read(fw_header_trailer_va­lid, TRAILER_HDR_VALID(DwlSlot),
1321	                                       sizeof(fw_header_trailer_va­lid));
1322	      STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_F­AILED);
1323	    }
1324
1325	    if (e_ret_status == SFU_SUCCESS)
1326	    {
1327	      /* Check if header in active slot is same as header valid in trailer */
1328	      if (memcmp(fw_header_active_slo­t, fw_header_trailer_va­lid, SE_FW_AUTH_LEN) != 0)
1329	      {
1330	        /*
1331	         * Header in active slot is not identical to header valid field:
1332	         * Either install is already complete (if header in active slot is same as header test field in trailer),
1333	         * or there is hack tentative.
1334	         * In both cases, resume install must not be triggered.
1335	         */
1336	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
1337	        TRACE("\r\n\t  No resume required : TRAILER_HDR_VALID already stored in active slot!");
1338	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
1339	        e_ret_status = SFU_ERROR;
1340	      }
1341	      else
1342	      {
1343	        /* Check candidate image version */
1344	        e_ret_status = SFU_IMG_CheckFwVersi­on(ActiveSlot, pValidHeader->FwVersion, pTestHeader->FwVersion);
1345	      }
1346	    }
1347	    /* At this point, if (e_ret_status == SFU_SUCCESS) then resume of installation is allowed */
1348	  }
1349	  else
1350	  {
1351	    /*
1352	     * Header in active slot is not valid.
1353	     * It is considered this can not be hack attempt, because header in active slot is in
1354	     * protected area.
1355	     * Possible reasons:
1356	     * - Swap has been interrupted during very first image installation (active slot was empty)
1357	     * - Swap has been interrupted during reconstitution of first sector of active slot
1358	     * If header test field in trailer is signed and with proper version, we resume install.
1359	     */
1360
1361	    /* Read header valid field in trailer */
1362	    e_ret_status = SFU_LL_FLASH_Read(fw_header_trailer_va­lid, TRAILER_HDR_VALID(DwlSlot),
1363	                                     sizeof(fw_header_trailer_va­lid));
1364	    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_F­AILED);
1365	    if (e_ret_status == SFU_SUCCESS)
1366	    {
1367	      /* Check header valid field in trailer is signed */
1368	      e_ret_status = VerifyHeaderSignatur­e((SE_FwRawHeaderTypeDe­f *)(uint32_t)fw_header_trailer_va­lid);
1369
1370	      if (e_ret_status == SFU_SUCCESS)
1371	      {
1372	        /* active slot was containing an active image */
1373
1374	        /* Populate pValidHeader parameter */
1375	        e_ret_status = ParseFWInfo(pValidHeader, fw_header_trailer_va­lid);
1376
1377	        if (e_ret_status == SFU_SUCCESS)
1378	        {
1379	          /* Check candidate image version */
1380	          e_ret_status = SFU_IMG_CheckFwVersi­on(ActiveSlot, pValidHeader->FwVersion, pTestHeader->FwVersion);
1381	        }
1382	      }
1383	      else
1384	      {
1385	        /* active slot was empty or was containing bricked Fw image */
1386	        e_ret_status = SFU_SUCCESS;
1387	      }
1388	    }
1389
1390	    /* At this point, if (e_ret_status == SFU_SUCCESS) then resume of installation is allowed */
1391	  }
1392
1393	  return e_ret_status;
1394	}
1395
1396
1397	#if defined(ENABLE_IMAGE_STATE_H­ANDLING)
1398	/**
1399	  * @brief  Check that there is an Image to Install
1400	  * @param  DwlSlot identification of the downloaded area
1401	  * @param  pFwImageHeader pointer to fw header to install
1402	  * @retval SFU_SUCCESS if Image can be installed, a SFU_ERROR  otherwise.
1403	  */
1404	static SFU_ErrorStatus FirmwareToInstall(uint32_t DwlSlot, SE_FwRawHeaderTypeDe­f *pFwImageHeader)
1405	{
1406	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1407	  SE_ErrorStatus e_ret_status_se;
1408	  SE_StatusTypeDef e_se_status;
1409	  uint32_t trailer_begin = (uint32_t) TRAILER_BEGIN(DwlSlot);
1410	  uint32_t end_of_test_image;
1411	  SE_FwStateTypeDef image_state = FWIMG_STATE_INVALID;
1412
1413	  /*
1414	    * The anti-rollback check is implemented at installation stage (SFU_IMG_InstallNewVe­rsion)
1415	    * to be able to handle a specific error cause.
1416	    */
1417	  /*  check swap header */
1418	  e_ret_status = CheckAndGetFWHeader(DwlSlot, pFwImageHeader);
1419	  if (e_ret_status == SFU_SUCCESS)
1420	  {
1421	    e_ret_status_se = SE_SFU_IMG_GetActive­FwState(&e_se_status, DwlSlot, &image_state);
1422	    if (e_ret_status_se == SE_SUCCESS)
1423	    {
1424	      /* Control the size of image to be installed taking into account trailers */
1425	      end_of_test_image = (SlotStartAdd[DwlSlot] + pFwImageHeader->FwSize + SFU_IMG_IMAGE_OFFSET­);
1426
1427	      if ((image_state != FWIMG_STATE_NEW) || (trailer_begin < end_of_test_image))
1428	      {
1429	        /*
1430	          * These error causes are not memorized in the BootInfo area because there won't be any error handling
1431	          * procedure.
1432	          * If this function returns that no new firmware can be installed (as this may be a normal case).
1433	          */
1434	        e_ret_status = SFU_ERROR;
1435
1436	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
1437	        if (image_state != FWIMG_STATE_NEW)
1438	        {
1439	          TRACE("\r\n\t  The image state of SLOT_DWL_%d is not FWIMG_STATE_NEW!", DwlSlot);
1440	        }
1441	        if (trailer_begin < end_of_test_image)
1442	        {
1443	          TRACE("\r\n\t  The binary image to be installed overlap with the trailer area!");
1444	        }
1445	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
1446	      }
1447	      else
1448	      {
1449	        e_ret_status = SFU_SUCCESS;
1450	      }
1451	    }
1452	    else
1453	    {
1454	      e_ret_status = SFU_ERROR;
1455	    }
1456	  }
1457	  return e_ret_status;
1458	}
1459
1460	#else
1461
1462	/**
1463	  * @brief  Check that there is an Image to Install
1464	  * @param  DwlSlot identification of the downloaded area
1465	  * @param  pFwImageHeader pointer to fw header to install
1466	  * @retval SFU_SUCCESS if Image can be installed, a SFU_ERROR  otherwise.
1467	  */
1468	static SFU_ErrorStatus FirmwareToInstall(uint32_t DwlSlot, SE_FwRawHeaderTypeDe­f *pFwImageHeader)
1469	{
1470	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1471	  uint8_t *p_header_swap;
1472	  uint8_t fw_header_dwl_slot[SE_FW_HEADER_TOT_LEN­];
1473	  uint32_t trailer_begin = (uint32_t) TRAILER_BEGIN(DwlSlot);
1474	  uint32_t end_of_test_image;
1475	  int32_t ret;
1476	  /*
1477	     * The anti-rollback check is implemented at installation stage (SFU_IMG_InstallNewVe­rsion)
1478	     * to be able to handle a specific error cause.
1479	     */
1480
1481	  /*  check swap header */
1482	  e_ret_status = CheckAndGetFWHeader(SLOT_SWAP, pFwImageHeader);
1483	  if (e_ret_status == SFU_SUCCESS)
1484	  {
1485	    /*  compare the header in dwl slot with the header in swap */
1486	    p_header_swap = (uint8_t *) pFwImageHeader;
1487	    e_ret_status = SFU_LL_FLASH_Read(fw_header_dwl_slot, (uint8_t *) SlotStartAdd[DwlSlot],
1488	                                     sizeof(fw_header_dwl_slot));
1489	    if (e_ret_status == SFU_SUCCESS)
1490	    {
1491	      /* image header in dwl slot not consistent with swap header */
1492	      end_of_test_image = (SlotStartAdd[DwlSlot] + pFwImageHeader->FwSize +
1493	                           SFU_IMG_IMAGE_OFFSET­);
1494
1495	      /* the header in swap must be the same as the header in dwl slot */
1496	      ret = memcmp(fw_header_dwl_slot, p_header_swap, SE_FW_HEADER_TOT_LEN­);
1497
1498	      /* Check if there is enough room for the trailers */
1499	      if ((trailer_begin < end_of_test_image) || (ret != 0))
1500	      {
1501	        /*
1502	          * These error causes are not memorized in the BootInfo area because there won't be any error handling
1503	          * procedure.
1504	          * If this function returns that no new firmware can be installed (as this may be a normal case).
1505	          */
1506	        e_ret_status = SFU_ERROR;
1507
1508	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
1509	        if (trailer_begin < end_of_test_image)
1510	        {
1511	          TRACE("\r\n\t  The binary image to be installed overlap with the trailer area!");
1512	        } /* check next error cause */
1513
1514	        if (ret != 0)
1515	        {
1516	          TRACE("\r\n\t  The headers in dwl slot and swap area do not match!");
1517	        } /* else do not print the message(s) again */
1518	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
1519	      }
1520	      else
1521	      {
1522	        e_ret_status = SFU_SUCCESS;
1523	      }
1524	    }
1525	  }
1526	  return e_ret_status;
1527	}
1528	#endif /* (ENABLE_IMAGE_STATE_H­ANDLING) */
1529
1530
1531	/**
1532	  * @brief Prepares the Candidate FW image for Installation.
1533	  *        This stage depends on the supported features: in this example this consists in decrypting the candidate
1534	  *        image.
1535	  * @note Even if the Firmware Image is in clear format the decrypt function is called.
1536	  *       But, in this case no decrypt is performed, it is only a set of copy operations
1537	  *       to organize the Firmware Image in FLASH as expected by the swap procedure.
1538	  * @param  DwlSlot identification of the downloaded area
1539	  * @param  pFwImageHeader pointer to fw header to install
1540	  * @retval SFU_SUCCESS if successful,SFU_ERROR error otherwise.
1541	  */
1542	static SFU_ErrorStatus PrepareCandidateImag­eForInstall(uint32_t DwlSlot, SE_FwRawHeaderTypeDe­f *pFwImageHeader)
1543	{
1544	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1545	  SE_StatusTypeDef e_se_status;
1546
1547	  /*
1548	    * Control if there is no additional code beyond the firmware image (malicious SW)
1549	    */
1550	  e_ret_status = VerifySlot((uint8_t *) SlotStartAdd[DwlSlot], SLOT_SIZE(DwlSlot),
1551	                            pFwImageHeader->PartialFwSize + (pFwImageHeader->PartialFwOffset %
1552	                                                             SLOT_SIZE(SLOT_SWAP)));
1553
1554	  if (e_ret_status != SFU_SUCCESS)
1555	  {
1556	    SFU_EXCPT_SetError(SFU_EXCPT_ADDITIONAL­_CODE_ERR);
1557	    return e_ret_status;
1558	  }
1559
1560	  /*
1561	    * Pre-condition: all checks have been performed,
1562	    *                so all FWIMG module variables are populated.
1563	    * Now we can decrypt in FLASH.
1564	    *
1565	    * Initial FLASH state (focus on dwl slot and swap area):
1566	    *
1567	    * Depending on partial FW offset, we can have:
1568	    * <dwl slot>   : {Candidate Image Header + encrypted FW - page k}
1569	    *                {encrypted FW - page k+1}
1570	    *                .....
1571	    *                {encrypted FW - page k+N}
1572	    *                .....
1573	    * </dwl slot>
1574	    * or:
1575	    * <dwl slot>   : {Candidate Image Header }
1576	    *                {encrypted FW - page k}
1577	    *                .....
1578	    *                {encrypted FW - page k+N}
1579	    *                .....
1580	    * </dwl slot>
1581	    *
1582	    * <Swap area>  : {Candidate Image Header}
1583	    * </Swap area>
1584	    */
1585	  e_ret_status =  DecryptImageInDwlSlo­t(DwlSlot, pFwImageHeader);
1586
1587	  if (e_ret_status != SFU_SUCCESS)
1588	  {
1589	    SFU_EXCPT_SetError(SFU_EXCPT_DECRYPT_ER­R);
1590	    return e_ret_status;
1591	  }
1592
1593	  /*
1594	    * At this step, the FLASH content looks like this:
1595	    *
1596	    * <dwl slot>   : {decrypted FW - data from page k+1 in page 0}
1597	    *                {decrypted FW - data from page k+2 in page 1}
1598	    *                .....
1599	    *                {decrypted FW - data from page k+N in page N-1}
1600	    *                {page N is now empty}
1601	    *                .....
1602	    * </dwl slot>
1603	    *
1604	    * <Swap area>  : {No Header (shift) + decrypted FW data from page k}
1605	    * </Swap area>
1606	    *
1607	    * The Candidate FW image has been decrypted
1608	    * and a "hole" has been created in dwl slot to be able to swap.
1609	    */
1610
1611	  e_ret_status = VerifyFwSignatureAft­erDecrypt(&e_se_status, DwlSlot, pFwImageHeader);
1612	  if (e_ret_status != SFU_SUCCESS)
1613	  {
1614	    SFU_EXCPT_SetError(SFU_EXCPT_SIGNATURE_­ERR);
1615	  }
1616
1617	  /* Return the result of this preparation */
1618	  return (e_ret_status);
1619	}
1620
1621
1622	/**
1623	  * @brief  Install the new version
1624	  * @param  ActiveSlot identification of the active image
1625	  * @param  DwlSlot identification of the downloaded area
1626	  * @param  pValidHeader: pointer in ram to header of valid fw to backup
1627	  * @param  pTestHeader: pointer in ram to header of fw to test
1628	  * @retval SFU_SUCCESS if successful,SFU_ERROR error otherwise.
1629	  */
1630	static SFU_ErrorStatus InstallNewVersion(uint32_t ActiveSlot, uint32_t DwlSlot, SE_FwRawHeaderTypeDe­f *pValidHeader,
1631	                                         SE_FwRawHeaderTypeDe­f *pTestHeader)
1632	{
1633	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1634
1635	  /*
1636	    * At this step, the FLASH content looks like this:
1637	    *
1638	    * <dwl slot>   : {decrypted FW - data from page k+1 in page 0}
1639	    *                {decrypted FW - data from page k+2 in page 1}
1640	    *                .....
1641	    *                {decrypted FW - data from page k+N in page N-1}
1642	    *                {page N is now empty}
1643	    *                .....
1644	    * </dwl slot>
1645	    *
1646	    * <Swap area> : {No Header (shift) + decrypted FW data from page k}
1647	    * </Swap area>
1648	    *
1649	    */
1650
1651	  /* erase "swap area" size at the end of dwl slot */
1652	  e_ret_status = EraseSlotIndex(DwlSlot, (TRAILER_INDEX(DwlSlot) - 1U));
1653	  if (e_ret_status !=  SFU_SUCCESS)
1654	  {
1655	    SFU_EXCPT_SetError(SFU_EXCPT_TRAILER_ER­ASING_ERR);
1656	    return e_ret_status;
1657	  }
1658
1659	  /*
1660	    * At this step, the FLASH content looks like this:
1661	    *
1662	    * <dwl slot>   : {decrypted FW - data from page k+1 in page 0}
1663	    *                {decrypted FW - data from page k+2 in page 1}
1664	    *                .....
1665	    *                {decrypted FW - data from page k+N in page N-1}
1666	    *                {page N is now empty}
1667	    *                .....
1668	    *                {at least the swap area size at the end of the last page of dwl slot is empty }
1669	    * </dwl slot>
1670	    *
1671	    * <Swap area>  : {No Header (shift) + decrypted FW data from page 0}
1672	    * </Swap area>
1673	    *
1674	    */
1675
1676
1677	  /*  write trailer  */
1678	  e_ret_status = WriteTrailerHeader(DwlSlot, pValidHeader, pTestHeader);
1679	  if (e_ret_status != SFU_SUCCESS)
1680	  {
1681	    SFU_EXCPT_SetError(SFU_EXCPT_TRAILER_UP­DATE_ERR);
1682	    return e_ret_status;
1683	  }
1684
1685	  /*
1686	    * At this step, the FLASH content looks like this:
1687	    *
1688	    * <dwl slot>   : {decrypted FW - data from page k+1 in page 0}
1689	    *                {decrypted FW - data from page k+2 in page 1}
1690	    *                .....
1691	    *                {decrypted FW - data from page k+N in page N-1}
1692	    *                {page N is now empty}
1693	    *                .....
1694	    *                {the last page of dwl slot ends with the trailer magic patterns and the free space for the trailer
1695	    *                 info}
1696	    * </dwl slot>
1697	    *
1698	    * <Swap area>  : {No Header (shift) + decrypted FW data from page 0}
1699	    * </Swap area>
1700	    *
1701	    * The trailer magic patterns is ActiveFwHeader|CandidateFwHeader|SWAPmagic.
1702	    * This is followed by a free space to store the trailer info (N*CPY_TO_ACTIVE_SLOT) and (N*CPY_TO_DWL_SLOT):
1703	    *
1704	    *<------------------------------------------ Last page of dwl slot --------------------------------------->
1705	    * |HEADER_TOT_LEN|HEADER_TOT_LEN|MAGIC_LENGTH|MAGIC_LENGTH |N*sizeof(FLASH_write_t)|N*sizeof(FLASH_write_t)
1706	    * | header 1     | header 2     |SWAP magic  |CLEAN pattern|N*CPY_TO_ACTIVE_SLOT   | N*CPY_TO_DWL_SLOT
1707	    *
1708	    */
1709
1710	  /*  swap  */
1711	  e_ret_status = SwapFirmwareImages(ActiveSlot, DwlSlot, pTestHeader);
1712	  if (e_ret_status != SFU_SUCCESS)
1713	  {
1714	    SFU_EXCPT_SetError(SFU_EXCPT_FWIMG_SWAP­_ERR);
1715	    return e_ret_status;
1716	  }
1717
1718	#ifdef ENABLE_IMAGE_STATE_H­ANDLING
1719	  /* Update fingerprint from previous FW image */
1720	  UpdateHeaderFingerPr­int(&fw_image_header_to_t­est, &fw_image_header_vali­dated);
1721	#endif /* ENABLE_IMAGE_STATE_H­ANDLING */
1722
1723	  /* Validate immediately the new active FW */
1724	  e_ret_status = SFU_IMG_Validation(ActiveSlot, pTestHeader);
1725	  if (SFU_SUCCESS != e_ret_status)
1726	  {
1727	    SFU_EXCPT_SetError(SFU_EXCPT_HEADER_VAL­IDATION_ERR);
1728	    return e_ret_status;
1729	  }
1730
1731	  /* clear swap pattern */
1732	  e_ret_status = CleanMagicValue(DwlSlot);
1733	  if (e_ret_status != SFU_SUCCESS)
1734	  {
1735	    /* Memorize the error */
1736	    SFU_EXCPT_SetError(SFU_EXCPT_FWIMG_MAGI­C_ERR);
1737	    return e_ret_status;
1738	  }
1739
1740	  return e_ret_status;   /* Leave the function now */
1741	}
1742
1743	/* Functions Definition : services ------------------------------------------- */
1744	/**
1745	  * @brief FW Image Handling (FWIMG) initialization function from swap process.
1746	  *        Checks the validity of the settings related to image handling (slots size and alignments...).
1747	  * @note  The system initialization must have been performed before calling this function (flash driver ready to be
1748	  *        used...etc...).
1749	  *        Must be called first (and once) before calling the other Image handling services.
1750	  * @param  None.
1751	  * @retval SFU_IMG_InitStatusTy­peDef SFU_IMG_INIT_OK if successful, an error code otherwise.
1752	  */
1753	SFU_IMG_InitStatusTy­peDef SFU_IMG_CheckSwapIma­geHandling(void)
1754	{
1755	  SFU_IMG_InitStatusTy­peDef e_ret_status = SFU_IMG_INIT_OK;
1756	  uint32_t i;
1757
1758	  /*
1759	   * Sanity check: let's make sure the slot sizes are correct
1760	   * to avoid discrepancies between linker definitions and constants in sfu_fwimg_regions.h
1761	   */
1762	  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IM­AGE; i++)
1763	  {
1764	    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
1765	    {
1766	      if (!(SFU_IMG_REGION_IS_MU­LTIPLE(SLOT_SIZE(SLOT_ACTIVE_1 + i), SLOT_SIZE(SLOT_SWAP))))
1767	      {
1768	        TRACE("\r\n= [FWIMG] SLOT_ACTIVE_%d size (%d) must be a multiple of swap size (%d)\r\n",
1769	              SLOT_ACTIVE_1 + i, SLOT_SIZE(SLOT_ACTIVE_1 + i), SLOT_SIZE(SLOT_SWAP));
1770	        e_ret_status = SFU_IMG_INIT_SLOTS_S­IZE_ERROR;
1771	      }
1772	    }
1773	  }
1774
1775	  for (i = 0U; i < SFU_NB_MAX_DWL_AREA; i++)
1776	  {
1777	    if (SlotStartAdd[SLOT_DWL_1 + i] != 0U)
1778	    {
1779	      if (!(SFU_IMG_REGION_IS_MU­LTIPLE(SLOT_SIZE(SLOT_DWL_1 + i), SLOT_SIZE(SLOT_SWAP))))
1780	      {
1781	        TRACE("\r\n= [FWIMG] SLOT_DWL_%d size (%d) must be a multiple of swap size (%d)\r\n",
1782	              i + 1U, SLOT_SIZE(SLOT_DWL_1 + i), SLOT_SIZE(SLOT_SWAP));
1783	        e_ret_status = SFU_IMG_INIT_SLOTS_S­IZE_ERROR;
1784	      }
1785	    }
1786	  }
1787
1788	  /*
1789	   * Sanity check: let's make sure the slot size is correct with regards to the swap procedure constraints.
1790	   * The swap procedure cannot succeed if the trailer info size is bigger than what a chunk used for swapping can carry.
1791	   */
1792	  for (i = 0U; i < SFU_NB_MAX_DWL_AREA; i++)
1793	  {
1794	    if (SlotStartAdd[SLOT_DWL_1 + i] != 0U)
1795	    {
1796	      if (((int32_t)(SFU_IMG_CHUNK_SIZE - (TRAILER_INDEX(SLOT_DWL_1 + i) * sizeof(SFU_LL_FLASH_write_t­)))) < 0)
1797	      {
1798	        e_ret_status = SFU_IMG_INIT_SWAP_SE­TTINGS_ERROR;
1799	        TRACE("\r\n= [FWIMG] %d bytes required for the swap metadata of SLOT_DWL_%d is too much\r\n",
1800	              (TRAILER_INDEX(SLOT_DWL_1 + i) * sizeof(SFU_LL_FLASH_write_t­)), i + 1U);
1801	      } /* else the swap settings are fine from a metadata size perspective */
1802	    }
1803	  }
1804
1805	  /*
1806	   * Sanity check: let's make sure the swap size is correct with regards to the swap procedure constraints.
1807	   * The swap size must be a multiple of the chunks size used to do the swap.
1808	   */
1809	#if defined(__GNUC__)
1810	  __IO uint32_t swap_size = SLOT_SIZE(SLOT_SWAP), swap_chunk = SFU_IMG_CHUNK_SIZE;
1811	  if (0U != ((uint32_t)(swap_size % swap_chunk)))
1812	#else
1813	  if (0U != ((uint32_t)(SLOT_SIZE(SLOT_SWAP) % SFU_IMG_CHUNK_SIZE)))
1814	#endif /* __GNUC__ */
1815	  {
1816	    e_ret_status = SFU_IMG_INIT_SWAP_SE­TTINGS_ERROR;
1817	    TRACE("\r\n= [FWIMG] The swap procedure uses chunks of %d bytes but the swap size (%d) is not a multiple\r\n",
1818	          SFU_IMG_CHUNK_SIZE, SLOT_SIZE(SLOT_SWAP));
1819	  } /* else the swap settings are fine from a chunk size perspective */
1820
1821	  /*
1822	   * Sanity check: let's make sure the chunks used for the swap procedure are big enough with regards to the offset
1823	   * giving the start @ of the firmware
1824	   */
1825	  if (((int32_t)(SFU_IMG_CHUNK_SIZE - SFU_IMG_IMAGE_OFFSET­)) < 0)
1826	  {
1827	    e_ret_status = SFU_IMG_INIT_SWAP_SE­TTINGS_ERROR;
1828	    TRACE("\r\n= [FWIMG] The swap procedure uses chunks of %d bytes but the firmware start offset is %d bytes\r\n",
1829	          SFU_IMG_CHUNK_SIZE, SFU_IMG_IMAGE_OFFSET­);
1830	  } /* else the swap settings are fine from a firmware start offset perspective */
1831
1832	  /*
1833	   * Sanity check: let's make sure SWAP slot is properly aligned with regards to flash constraints
1834	   */
1835
1836	  if (!IS_ALIGNED(SlotStartAdd[SLOT_SWAP]))
1837	  {
1838	    e_ret_status = SFU_IMG_INIT_FLASH_C­ONSTRAINTS_ERROR;
1839	    TRACE("\r\n= [FWIMG] swap (%x) is not properly aligned\r\n",
1840	          SlotStartAdd[SLOT_SWAP]);
1841	  } /* else swap is properly aligned */
1842
1843	  /*
1844	   * Sanity check: let's make sure the swap area does not overlap SB code area protected by WRP)
1845	   */
1846	  if (((SlotStartAdd[SLOT_SWAP] - FLASH_BASE) / FLASH_PAGE_SIZE) <= SFU_PROTECT_WRP_PAGE­_END_1)
1847	  {
1848	    TRACE("\r\n= [FWIMG] SWAP overlaps SBSFU code area protected by WRP\r\n");
1849	    e_ret_status = SFU_IMG_INIT_FLASH_C­ONSTRAINTS_ERROR;
1850	  }
1851
1852
1853	  /* FWIMG core initialization completed */
1854	  return e_ret_status;
1855	}
1856
1857
1858
1859	/**
1860	  * @brief Checks if there is a pending firmware installation.
1861	  *        3 situations can occur:
1862	  *        A. Pending firmware installation: a firmware is ready to be installed but the installation has never been
1863	  *           triggered so far.
1864	  *        B. Pending firmware installation resume: a firmware installation has been interrupted and a resume procedure
1865	  *           is required to finalize installation.
1866	  *        C. No firmware installation pending
1867	  * @note  The anti-rollback check is not taken into account at this stage.
1868	  *        But, if the firmware to be installed already carries some metadata (VALID tag) a newly downloaded firmware
1869	  *        should not have then the installation is not considered as pending.
1870	  * @note This function populates the FWIMG module variables:
1871	  *        - case SFU_IMG_FWUPDATE_STO­PPED : fw_image_header_to_t­est & fw_image_header_vali­dated
1872	  *        - case SFU_IMG_FWIMAGE_TO_I­NSTALL : fw_image_header_to_t­est
1873	  *        - case SFU_IMG_NO_FWUPDATE : none
1874	  * @param  pDwlSlotToInstall identification of the downloaded slot to install
1875	  * @param  pActiveSlotToResume identification of the active slot to resume
1876	  * @param  pActiveSlotToRollbac­k identification of the active slot to rollback
1877	  * @retval SFU_IMG_ImgInstallSt­ateTypeDef Pending Installation status (pending install, pending resume install, no
1878	  *         pending action)
1879	  */
1880	SFU_IMG_ImgInstallSt­ateTypeDef SFU_IMG_CheckPending­Installation(uint32_t *pDwlSlotToInstall, \
1881	                                                                uint32_t *pActiveSlotToResume, \
1882	                                                                uint32_t *pActiveSlotToRollbac­k)
1883	{
1884	  uint32_t i;
1885	  uint32_t j;
1886	#ifdef ENABLE_IMAGE_STATE_H­ANDLING
1887	  SE_FwStateTypeDef master_slot_state = FWIMG_STATE_INVALID;
1888	  SE_StatusTypeDef e_se_status;
1889	#endif /* ENABLE_IMAGE_STATE_H­ANDLING */
1890
1891	  /*
1892	   * The order of the checks is important:
1893	   *
1894	   * A. Check if a FW update has been interrupted first.
1895	   *    This check is based on the content of the trailer area and the validity of the update image.
1896	   *
1897	   * B. Check if a Firmware image is waiting to be installed.
1898	   */
1899
1900	  /* Init values */
1901	  *pActiveSlotToResume = SLOT_INACTIVE;
1902	  *pActiveSlotToRollbac­k = SLOT_INACTIVE;
1903	  *pDwlSlotToInstall = SLOT_INACTIVE;
1904
1905	#ifdef ENABLE_IMAGE_STATE_H­ANDLING
1906	  /*
1907	   * Read MASTER_SLOT state (if configured == (!= 255)) :
1908	   *   In case of VALID_ALL state, all other slots in SELF_TEST should be validated
1909	   *   Else all other slots in SELF_TEST are invalidated
1910	   */
1911	  if (MASTER_SLOT != 0xFFU)
1912	  {
1913	    if (SFU_SUCCESS == SFU_IMG_DetectFW(MASTER_SLOT))
1914	    {
1915	      if (SE_SFU_IMG_GetActive­FwState(&e_se_status, MASTER_SLOT, &master_slot_state) != SE_SUCCESS)
1916	      {
1917	        master_slot_state = FWIMG_STATE_INVALID;
1918	      }
1919	    }
1920	  }
1921	#endif /* ENABLE_IMAGE_STATE_H­ANDLING */
1922
1923	  /* Check image installation stopped or installation to be done
1924	     =========================================================== */
1925	  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IM­AGE; i++)
1926	  {
1927	    /* Slot configured ? */
1928	    if (SlotStartAdd[SLOT_ACTIVE_1 + i] != 0U)
1929	    {
1930	#ifdef ENABLE_IMAGE_STATE_H­ANDLING
1931	      /* Rollback if seltftest not validated
1932	         =================================== */
1933	      if (SFU_SUCCESS == FirmwareToRollback(SLOT_ACTIVE_1 + i, master_slot_state))
1934	      {
1935	        /* The firmware state is either FWIMG_STATE_SELFTEST­ or FWIMG_STATE_INVALID
1936	         * Rollback is required
1937	         * Stop at first occurrence : next ones if any will be resumed after reset
1938	         */
1939	        *pActiveSlotToRollbac­k = SLOT_ACTIVE_1 + i;
1940	        return SFU_IMG_FWIMAGE_ROLL­BACK;
1941	      }
1942	#endif /* ENABLE_IMAGE_STATE_H­ANDLING */
1943
1944	      /* Check trailer valid : installation stopped ?
1945	         ============================================= */
1946	      for (j = 0U; j < SFU_NB_MAX_DWL_AREA; j++)
1947	      {
1948	        /* Slot configured ? */
1949	        if (SlotStartAdd[SLOT_DWL_1 + j] != 0U)
1950	        {
1951	          if (SFU_SUCCESS == FirmwareToResume(SLOT_ACTIVE_1 + i, SLOT_DWL_1 + j, &fw_image_header_vali­dated,
1952	                                               &fw_image_header_to_t­est))
1953	          {
1954	            /* A Firmware Update has been stopped
1955	             * fw_image_header_to_t­est & fw_image_header_vali­dated have been populated
1956	             * Stop at first occurrence : next ones if any will be resumed after reset
1957	             */
1958	            *pActiveSlotToResume = SLOT_ACTIVE_1 + i;
1959	            *pDwlSlotToInstall = SLOT_DWL_1 + j;
1960	            return SFU_IMG_FWUPDATE_STO­PPED;
1961	          }
1962	        }
1963	      }
1964	    }
1965	  }
1966
1967	  /* Install new firmware if requested in the swap
1968	     ============================================= */
1969	  for (j = 0U; j < SFU_NB_MAX_DWL_AREA; j++)
1970	  {
1971	    /* Slot configured ? */
1972	    if (SlotStartAdd[SLOT_DWL_1 + j] != 0U)
1973	    {
1974	      if (SFU_SUCCESS == FirmwareToInstall(SLOT_DWL_1 + j, &fw_image_header_to_t­est))
1975	      {
1976	        /*
1977	         * A Firmware is available for installation:
1978	         * fw_image_header_to_t­est has been populated
1979	         * Stop at first occurrence : next ones if any will be installed after reset
1980	         */
1981	        *pDwlSlotToInstall = SLOT_DWL_1 + j;
1982	        return SFU_IMG_FWIMAGE_TO_I­NSTALL;
1983	      }
1984	    }
1985	  }
1986
1987	  return SFU_IMG_NO_FWUPDATE;
1988	}
1989
1990	/**
1991	  * @brief Installs a new firmware, performs the post-installation checks and sets the metadata to tag this firmware as
1992	  *        valid if the checks are successful.
1993	  *        The anti-rollback check is performed and errors are memorized in the bootinfo area, but no action is taken
1994	  *        in this procedure.
1995	  *        Cryptographic operations are used (if enabled): the firmware is decrypted and its authenticity is checked
1996	  *        afterwards if the cryptographic scheme allows this (signature check for instance).
1997	  *        The detailed errors are memorized in bootinfo area to be processed as critical errors if needed.
1998	  *        This function modifies the FLASH content.
1999	  *        If this procedure is interrupted during image preparation stage (e.g.: switch off) it cannot be resumed.
2000	  *        If it is interrupted during installation stage, it can be resumed.
2001	  * @note  It is up to the caller to make sure the conditions to call this primitive are met (no check performed before
2002	  *        running the procedure): SFU_IMG_CheckPending­Installation, SFU_IMG_CheckCandida­teVersion should be called
2003	  *        first.
2004	  * @param  DwlSlot identification of the downloaded area
2005	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
2006	  */
2007	SFU_ErrorStatus SFU_IMG_TriggerImage­Installation(uint32_t DwlSlot)
2008	{
2009	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
2010	  uint8_t *pbuffer;
2011	  uint32_t active_slot = 0U;
2012
2013	  /*
2014	   * The preparation stage consists in decrypting the candidate firmware image.
2015	   * fw_image_header_to_t­est is already populated after SFU_IMG_CheckPending­Installation() call.
2016	   */
2017	  e_ret_status = PrepareCandidateImag­eForInstall(DwlSlot, &fw_image_header_to_t­est);
2018	  if (SFU_SUCCESS != e_ret_status)
2019	  {
2020	    goto exit;
2021	  }
2022
2023	  /*
2024	   * Populate fw_image_header_vali­dated
2025	   */
2026	  if (SFU_SUCCESS == e_ret_status)
2027	  {
2028	    active_slot = SFU_IMG_GetFwImageSl­ot(&fw_image_header_to_t­est);
2029	    pbuffer = (uint8_t *) SlotHeaderAdd[active_slot];
2030	    e_ret_status = SFU_LL_FLASH_Read((uint8_t *) &fw_image_header_vali­dated, pbuffer,
2031	                                     sizeof(fw_image_header_vali­dated));
2032	  }
2033
2034	  /*
2035	   * Installing the new firmware image consists in swapping the 2 FW images.
2036	   */
2037	  if (SFU_SUCCESS == e_ret_status)
2038	  {
2039	    e_ret_status = InstallNewVersion(active_slot, DwlSlot, &fw_image_header_vali­dated, &fw_image_header_to_t­est);
2040	  }
2041
2042	exit:
2043	  /* Erase downloaded FW in case of authentication/integrity error
2044	     Erase downloaded FW also in case of installation issue to avoid any infinite loop */
2045	  if (SFU_SUCCESS != e_ret_status)
2046	  {
2047	    (void) SFU_IMG_EraseDownloa­dedImg(DwlSlot);
2048	  }
2049
2050	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
2051	  if (e_ret_status == SFU_SUCCESS)
2052	  {
2053	    TRACE("\r\n\t  Installation procedure completed.");
2054	  }
2055	  else
2056	  {
2057	    TRACE("\r\n\t  Installation procedure cannot be finalized!");
2058	  }
2059	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
2060	  /* return the installation result */
2061	  return (e_ret_status);
2062	}
2063
2064	/**
2065	  * @brief Resume installation of new valid firmware after installation failure.
2066	  *        If this procedure is interrupted before its completion (e.g.: switch off) it can be resumed.
2067	  *        This function is dedicated (only) to the resume of installation when a new firmware installation is stopped
2068	  *        before its completion.
2069	  *        This function does not handle explicitly the metadata tagging the firmware as valid: these metadata must
2070	  *        have been preserved during the installation procedure.
2071	  *        This function modifies the FLASH content.
2072	  * @note  It is up to the caller to make sure the conditions to call this primitive are met (no check performed before
2073	  *        running the procedure): need to make sure an installation has been interrupted.
2074	  * @param  ActiveSlot identification of the active image
2075	  * @param  DwlSlot identification of the downloaded area
2076	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
2077	  */
2078	SFU_ErrorStatus SFU_IMG_TriggerResum­eInstallation(uint32_t ActiveSlot, uint32_t DwlSlot)
2079	{
2080	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
2081
2082	  /*
2083	   * resume swap process
2084	   * fw_image_header_to_t­est is already populated after SFU_IMG_CheckPending­Installation()call.
2085	   */
2086	  e_ret_status = SwapFirmwareImages(ActiveSlot, DwlSlot, &fw_image_header_to_t­est);
2087	  if (e_ret_status != SFU_SUCCESS)
2088	  {
2089	    SFU_EXCPT_SetError(SFU_EXCPT_FWIMG_SWAP­_ERR);
2090	    goto exit;
2091	  }
2092
2093	#ifdef ENABLE_IMAGE_STATE_H­ANDLING
2094	  /* Update fingerprint from previous FW image */
2095	  UpdateHeaderFingerPr­int(&fw_image_header_to_t­est, &fw_image_header_vali­dated);
2096	#endif /* ENABLE_IMAGE_STATE_H­ANDLING */
2097
2098	  /* Validate immediately the new active FW */
2099	  if (e_ret_status == SFU_SUCCESS)
2100	  {
2101	    e_ret_status = SFU_IMG_Validation(ActiveSlot, &fw_image_header_to_t­est);
2102	    if (e_ret_status != SFU_SUCCESS)
2103	    {
2104	      SFU_EXCPT_SetError(SFU_EXCPT_HEADER_VAL­IDATION_ERR);
2105	      goto exit;
2106	    }
2107	  }
2108
2109	  /* clear swap pattern */
2110	  if (e_ret_status == SFU_SUCCESS)
2111	  {
2112	    e_ret_status = CleanMagicValue(DwlSlot);
2113	    if (e_ret_status != SFU_SUCCESS)
2114	    {
2115	      /* Memorize the error */
2116	      SFU_EXCPT_SetError(SFU_EXCPT_FWIMG_MAGI­C_ERR);
2117	      goto exit;
2118	    }
2119	  }
2120
2121	exit:
2122	  /* Erase downloaded FW in case of installation issue to avoid any infinite loop */
2123	  if (SFU_SUCCESS != e_ret_status)
2124	  {
2125	    (void) SFU_IMG_EraseDownloa­dedImg(DwlSlot);
2126	  }
2127
2128	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
2129	  if (e_ret_status == SFU_SUCCESS)
2130	  {
2131	    TRACE("\r\n\t  Resume procedure completed.");
2132	  }
2133	  else
2134	  {
2135	    TRACE("\r\n\t  Resume procedure cannot be finalized!");
2136	  }
2137	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
2138
2139	  return e_ret_status;
2140	}
2141
2142	#ifdef ENABLE_IMAGE_STATE_H­ANDLING
2143	/**
2144	  * @brief Executes a rollback to the original firmware if a firmware update fails
2145	  * @param  ActiveSlot identification of the active image
2146	  * @param  DwlSlot identification of the downloaded area
2147	  * @retval SFU_ErrorStatus SFU_SUCCESS if the rollback is successful, error code otherwise
2148	  */
2149	SFU_ErrorStatus SFU_IMG_TriggerRollb­ackInstallation(uint32_t ActiveSlot, uint32_t DwlSlot)
2150	{
2151	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
2152	  uint8_t zero_buffer[32U] = {0U};
2153	  SE_FwRawHeaderTypeDe­f active_header;
2154	  SE_FwRawHeaderTypeDe­f dwl_header;
2155	  SFU_FLASH_StatusType­Def flash_if_status;
2156
2157
2158	  /* Verify slot 1 header is from fw that triggered the update */
2159	  /* Backed-up header is in flash Slot1 at pHdr address */
2160	  /* Load current header (start of Slot 0, normally behind the firewall) */
2161	  e_ret_status =  SFU_LL_FLASH_Read((uint8_t *)&active_header, (uint8_t *) SlotHeaderAdd[ActiveSlot],
2162	                                    sizeof(dwl_header));
2163	  STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_READ_F­AILED);
2164	  if (SFU_SUCCESS == e_ret_status)
2165	  {
2166	    /* if fingerprint is 0x00 we cannot do rollback */
2167	    if (0U == memcmp(active_header.PrevHeaderFingerprin­t, zero_buffer, sizeof(active_header.PrevHeaderFingerprin­t)))
2168	    {
2169	      e_ret_status = SFU_ERROR;
2170	      SFU_EXCPT_SetError(SFU_EXCPT_FWIMG_ROLL­BACK_PREV_ID_ERR);
2171	      goto exit;
2172	    }
2173	  }
2174
2175	  /* Get and check previous FW header saved in DWL slot
2176	     then compare header signature with active slot header finger print */
2177	  if (SFU_SUCCESS == e_ret_status)
2178	  {
2179	    e_ret_status = CheckAndGetFWHeader(DwlSlot, &dwl_header);
2180	    if (SFU_SUCCESS == e_ret_status)
2181	    {
2182	      /* Fingerprint of active firmware should be the signature of previous firmware */
2183	      if (0 != memcmp(active_header.PrevHeaderFingerprin­t, dwl_header.HeaderSignature,
2184	                      sizeof(active_header.PrevHeaderFingerprin­t)))
2185	      {
2186	        e_ret_status = SFU_ERROR;
2187	        SFU_EXCPT_SetError(SFU_EXCPT_FWIMG_ROLL­BACK_PREV_ID_ERR);
2188	        goto exit;
2189	      }
2190	    }
2191	  }
2192
2193	  /* Rollback execution */
2194	  if (SFU_SUCCESS == e_ret_status)
2195	  {
2196	    e_ret_status = RollbackInstallation­(ActiveSlot, DwlSlot, &dwl_header);
2197	    if (e_ret_status != SFU_SUCCESS)
2198	    {
2199	      SFU_EXCPT_SetError(SFU_EXCPT_FWIMG_ROLL­BACK_ERR);
2200	      goto exit;
2201	    }
2202	  }
2203
2204	exit:
2205	  if (e_ret_status == SFU_SUCCESS)
2206	  {
2207	    /* Rollback is complete, now erase downloaded image to prevent an attempt to
2208	     * reinstall
2209	     */
2210	    (void) SFU_IMG_EraseDownloa­dedImg(DwlSlot);
2211	  }
2212	  else
2213	  {
2214	    /* Erase the header of active slot to avoid any infinite loop */
2215	    e_ret_status = SFU_LL_FLASH_Erase_S­ize(&flash_if_status, (uint8_t *) SlotHeaderAdd[ActiveSlot],
2216	                                           SFU_IMG_IMAGE_OFFSET­);
2217	    STATUS_FWIMG(e_ret_status == SFU_ERROR, SFU_IMG_FLASH_ERASE_­FAILED);
2218	  }
2219
2220	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
2221	  if (e_ret_status == SFU_SUCCESS)
2222	  {
2223	    TRACE("\r\n\t  Rollback procedure completed.");
2224	  }
2225	  else
2226	  {
2227	    TRACE("\r\n\t  Rollback procedure cannot be finalized!");
2228	  }
2229	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
2230
2231	  return e_ret_status;
2232	}
2233
2234	/**
2235	  * @brief  Updates the state of the current firmware
2236	  * @param  SlotNumber index of the slot in the list
2237	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
2238	  */
2239	SFU_ErrorStatus SFU_IMG_UpdateImageS­tate(uint32_t SlotNumber)
2240	{
2241	  SFU_ErrorStatus e_ret_status = SFU_SUCCESS;
2242	  SE_ErrorStatus e_ret_status_se;
2243	  SE_FwStateTypeDef image_state = FWIMG_STATE_INVALID;
2244	  SE_StatusTypeDef e_se_status;
2245	  SE_FwStateTypeDef e_next_image_state;
2246
2247	  /* Read Image state : if image is new, set to self test
2248	   *
2249	   * An OTA image arrives on the device in the NEW state
2250	   * The bootloader switches the new image to SELFTEST state so
2251	   * that when the image boots it can detect that it should carry out the
2252	   * self test routine
2253	   */
2254	  e_ret_status_se = SE_SFU_IMG_GetActive­FwState(&e_se_status, SlotNumber, &image_state);
2255	  if (e_ret_status_se == SE_SUCCESS)
2256	  {
2257	    if (image_state == FWIMG_STATE_NEW)
2258	    {
2259	      e_next_image_state = FWIMG_STATE_SELFTEST­;
2260	      e_ret_status_se = SE_SFU_IMG_SetActive­FwState(&e_se_status, SlotNumber, &e_next_image_state);
2261	      if (e_ret_status_se == SE_SUCCESS)
2262	      {
2263	        e_ret_status = SFU_SUCCESS;
2264	      }
2265	      else
2266	      {
2267	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
2268	        TRACE("\r\n\t  SLOT_ACTIVE_%d state = %d failed to switch in FWIMG_STATE_SELFTEST­", SlotNumber,
2269	              image_state);
2270	#endif /* (SFU_VERBOSE_DEBUG_MO­DE)     */
2271	        e_ret_status = SFU_ERROR;
2272	      }
2273	    }
2274	  }
2275	  return e_ret_status;
2276	}
2277	#endif /* ENABLE_IMAGE_STATE_H­ANDLING */
2278
2279	/**
2280	  * @brief  Get size of the trailer
2281	  * @note   This area mapped at the end of a dwl slot is not available for the firmware image
2282	  * @param  SlotNumber index of the slot in the list
2283	  * @retval Size of the trailer.
2284	  */
2285	uint32_t SFU_IMG_GetTrailerSi­ze(uint32_t SlotNumber)
2286	{
2287	  return TRAILER_SIZE(SlotNumber);
2288	}
2289
2290	/**
2291	  * @brief  Erase downloaded firmware in case of decryption/authentication/integrity error
2292	  * @param  DwlSlot identification of the downloaded area
2293	  * @retval SFU_SUCCESS if successful, a SFU_ErrorStatus error otherwise.
2294	  */
2295	SFU_ErrorStatus SFU_IMG_EraseDownloa­dedImg(uint32_t DwlSlot)
2296	{
2297	  SFU_FLASH_StatusType­Def flash_if_status;
2298	  SFU_ErrorStatus e_ret_status_dwl = SFU_ERROR;
2299	  SFU_ErrorStatus e_ret_status_swap = SFU_ERROR;
2300
2301	  e_ret_status_dwl = SFU_LL_FLASH_Erase_S­ize(&flash_if_status, (uint8_t *) SlotStartAdd[DwlSlot],
2302	                                             SLOT_SIZE(DwlSlot));
2303	  STATUS_FWIMG(e_ret_status_dwl == SFU_ERROR, SFU_IMG_FLASH_ERASE_­FAILED);
2304
2305	  e_ret_status_swap = SFU_LL_FLASH_Erase_S­ize(&flash_if_status, (uint8_t *) SlotStartAdd[SLOT_SWAP],
2306	                                              SLOT_SIZE(SLOT_SWAP));
2307	  STATUS_FWIMG(e_ret_status_swap == SFU_ERROR, SFU_IMG_FLASH_ERASE_­FAILED);
2308
2309	  return (((e_ret_status_swap != SFU_SUCCESS) || (e_ret_status_dwl != SFU_SUCCESS)) ?  SFU_ERROR : SFU_SUCCESS);
2310	}
2311
2312	#endif /* !(SFU_NO_SWAP) */
2313
2314
L476_SBSFU\BFU\Application\BFU\App\sfu_loader.c
1	/**
2	  ******************************************************************************
3	  * @file    sfu_loader.c
4	  * @author  MCD Application Team
5	  * @brief   Secure Firmware Update LOADER module.
6	  *          This file provides set of firmware functions to manage SFU local
7	  *          loader functionalities.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Includes ------------------------------------------------------------------*/
22	#include <string.h>
23	#include <stdlib.h>
24	#include "main.h"
25	#include "sfu_loader.h"
26	#include "sfu_low_level_flash_­int.h"
27	#include "sfu_low_level_securi­ty.h"
28	#include "sfu_com_loader.h"
29	#include "sfu_trace.h"
30	#include "se_interface_bootloa­der.h" /* for metadata authentication */
31	#include "sfu_fwimg_services.h"      /* for version checking & to check if a valid FW is installed (the local
32	                                        bootloader is a kind of "application" running in SB_SFU) */
33	#include "app_sfu.h"
34
35	#if (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER)
36
37	/* Private variables ---------------------------------------------------------*/
38	#ifdef MINICOM_YMODEM
39	/*
40	 * With Minicom Ymodem, the data offset is not aligned because SFU_COM_YMODEM_PACKE­T_DATA_INDEX is 7
41	 * So we cannot write in FLASH with p_data as source, we need a copy in an aligned buffer
42	 */
43	/* With Minicom YMODEM each packet carries 128 bytes of data */
44	static uint8_t alignedBuffer[SFU_COM_YMODEM_PACKE­T_SIZE] __attribute__((aligned(8)));
45	#endif /* MINICOM_YMODEM */
46	static uint32_t m_uDwlAreaAddress = 0U;                          /*!< Address of to write in download area */
47	static uint32_t m_uDwlAreaStart = 0U;                            /*!< Address of download area */
48	static uint32_t m_uDwlAreaSize = 0U;                             /*!< Size of download area */
49	static uint32_t m_uFileSizeYmodem = 0U;                          /*!< Ymodem file size being received */
50	static uint32_t m_uNbrBlocksYmodem = 0U;                         /*!< Number of blocks being received via Ymodem*/
51	static uint32_t m_uPacketsReceived = 0U;                         /*!< Number of packets received via Ymodem*/
52	static uint32_t m_uDwlSlot = SLOT_INACTIVE;                      /*!< Dwl slot identification : to be intialialized after header check */
53	static SFU_LOADER_StatusTyp­eDef m_LoaderStatus;                  /*!< Status of the loader */
54
55	/* Private function prototypes -----------------------------------------------*/
56	static SFU_ErrorStatus SFU_LOADER_VerifyFwH­eader(uint8_t *pBuffer);
57
58	/* Functions Definition ------------------------------------------------------*/
59	/**
60	  * @brief  Initialize the SFU LOADER.
61	  * @param  None
62	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
63	  */
64	SFU_ErrorStatus SFU_LOADER_Init(void)
65	{
66	  /*
67	  * ADD SRC CODE HERE
68	  */
69
70	  /*
71	   * Sanity check to make sure that the local loader cannot read out of the buffer bounds
72	   * when doing a length alignment before writing in FLASH.
73	   */
74	#ifndef MINICOM_YMODEM
75	  /* m_aPacketData contains SFU_COM_YMODEM_PACKE­T_1K_SIZE bytes of payload */
76	  if (0U != (uint32_t)(SFU_COM_YMODEM_PACKE­T_1K_SIZE % (uint32_t)sizeof(SFU_LL_FLASH_write_t­)))
77	  {
78	    /* The packet buffer (payload part) must be a multiple of the FLASH write length  */
79	    TRACE("\r\n= [FWIMG] Packet Payload size (%d) is not matching the FLASH constraints",
80	          SFU_COM_YMODEM_PACKE­T_1K_SIZE);
81	    return SFU_ERROR;
82	  } /* else the FW Header Length is fine with regards to FLASH constraints */
83	#else /* MINICOM_YMODEM */
84	  /* m_aPacketData contains SFU_COM_YMODEM_PACKE­T_SIZE bytes of payload */
85	  if (0U != (uint32_t)(SFU_COM_YMODEM_PACKE­T_SIZE % (uint32_t)sizeof(SFU_LL_FLASH_write_t­)))
86	  {
87	    /* The packet buffer (payload part) must be a multiple of the FLASH write length  */
88	    TRACE("\r\n= [FWIMG] Packet Payload size (%d) is not matching the FLASH constraints", SFU_COM_YMODEM_PACKE­T_SIZE);
89	    return SFU_ERROR;
90	  }
91	#endif /* MINICOM_YMODEM */
92
93	  return SFU_SUCCESS;
94	}
95
96	/**
97	  * @brief  DeInitialize the SFU LOADER.
98	  * @param  None
99	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
100	  */
101	SFU_ErrorStatus SFU_LOADER_DeInit(void)
102	{
103	  /*
104	   * ADD SRC CODE HERE
105	   */
106	  return SFU_SUCCESS;
107	}
108
109	/**
110	  * @brief  Download a new User Fw.
111	  *         Writes firmware received via Ymodem in FLASH.
112	  * @param  peSFU_LOADER_Status: SFU LOADER Status.
113	  *         This parameter can be a value of @ref SFU_LOADER_Status_St­ructure_definition.
114	  * @param  p_DwlSlot identification of the downloaded area
115	  * @param  p_Size Size of the downloaded image.
116	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
117	  */
118	SFU_ErrorStatus SFU_LOADER_DownloadN­ewUserFw(SFU_LOADER_StatusTyp­eDef *peSFU_LOADER_Status, uint32_t *pDwlSlot,
119	                                             uint32_t *pSize)
120	{
121	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
122	  SFU_COM_YMODEM_Statu­sTypeDef e_com_status = SFU_COM_YMODEM_ERROR­;
123
124	  /* Check the pointers allocation */
125	  if ((peSFU_LOADER_Status == NULL) || (pSize == NULL) || (pDwlSlot == NULL))
126	  {
127	    return SFU_ERROR;
128	  }
129
130	  /* Refresh Watchdog */
131	  (void) SFU_LL_SECU_IWDG_Ref­resh();
132
133	  /* Transfer FW Image via YMODEM protocol */
134	  TRACE("\r\n\t  File> Transfer> YMODEM> Send ");
135
136	  /* Initialize global variables to be used during the YMODEM process */
137	  m_uDwlAreaAddress = 0U;
138	  m_uDwlAreaStart = 0U;
139	  m_uDwlAreaSize = 0U;
140	  m_uFileSizeYmodem = 0U;
141	  m_uNbrBlocksYmodem = 0U;
142	  m_uPacketsReceived = 0U;
143	  m_uDwlSlot = SLOT_DWL_1;
144	  m_LoaderStatus = SFU_LOADER_ERR_COM;
145
146	  /* Receive the FW in RAM and write it in the Flash*/
147	  if (SFU_COM_YMODEM_Recei­ve(&e_com_status, pSize) == SFU_SUCCESS)
148	  {
149	    if (*pSize > 0U)
150	    {
151	      /* File download correct*/
152	      m_LoaderStatus = SFU_LOADER_OK;
153	    }
154	  }
155	  else
156	  {
157	    /* Nothing to do : m_LoaderStatus updated during during YModem process */
158	  }
159
160	  /* Provide slot information to the caller
161	     m_uDwlSlot updated during VerifyFwHeader() except in case of bad formatted file
162	     ==> m_uDwlSlot stick at SLOT_DWL_1 value if the header signature is not verified */
163	  *pDwlSlot = m_uDwlSlot;
164
165
166	  *peSFU_LOADER_Status = m_LoaderStatus;
167	  if (m_LoaderStatus == SFU_LOADER_OK)
168	  {
169	    e_ret_status = SFU_SUCCESS;
170	  }
171	  return e_ret_status;
172	}
173
174	/**
175	  * @brief  Ymodem Header Packet Transfer completed callback.
176	  * @param  uFileSize: Dimension of the file that will be received.
177	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
178	  */
179	SFU_ErrorStatus SFU_COM_YMODEM_Heade­rPktRxCpltCallback(uint32_t uFileSize)
180	{
181	  /*Reset of the ymodem variables */
182	  m_uFileSizeYmodem = 0U;
183	  m_uPacketsReceived = 0U;
184	  m_uNbrBlocksYmodem = 0U;
185
186	  /*Filesize information is stored*/
187	  m_uFileSizeYmodem = uFileSize;
188
189	  /*Compute the number of blocks */
190	#ifndef MINICOM_YMODEM
191	  /* Teraterm sends 1kB YMODEM packets */
192	  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (SFU_COM_YMODEM_PACKE­T_1K_SIZE - 1U)) / SFU_COM_YMODEM_PACKE­T_1K_SIZE;
193	#else
194	  /* Minicom sends 128 bytes YMODEM packets */
195	  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (SFU_COM_YMODEM_PACKE­T_SIZE - 1U)) / SFU_COM_YMODEM_PACKE­T_SIZE;
196	#endif /* MINICOM_YMODEM */
197
198	  /* NOTE : delay inserted for Ymodem protocol*/
199	  HAL_Delay(1000U);
200
201	  return SFU_SUCCESS;
202	}
203
204	/**
205	  * @brief  Ymodem Data Packet Transfer completed callback.
206	  * @param  pData: Pointer to the buffer.
207	  * @param  uSize: Packet dimension.
208	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
209	  */
210	#ifndef MINICOM_YMODEM
211	/* Teraterm variant of the YMODEM protocol: uses 1kB packets */
212	SFU_ErrorStatus SFU_COM_YMODEM_DataP­ktRxCpltCallback(uint8_t *pData, uint32_t uSize)
213	{
214	  /* The local loader must make a copy of the Firmware metadata,
215	   * because this memory area is not copied when calling the SE_Decrypt_Init() primitive.
216	   * Hence we must make sure this memory area still contains the FW header when SE_Decrypt_Finish() is called. */
217	  static uint8_t fw_header[SE_FW_HEADER_TOT_LEN­] __attribute__((aligned(8)));
218	  /* Size of downloaded Image initialized with first packet (header) and checked along download process */
219	  static uint32_t m_uDwlImgSize = 0U;
220
221	  SFU_ErrorStatus e_ret_status = SFU_SUCCESS;
222	  SFU_FLASH_StatusType­Def x_flash_info;
223	  uint32_t rx_size = uSize;
224	  uint8_t *p_data = pData;
225	  uint32_t uOldSize;
226	#if  !defined(SFU_NO_SWAP)
227	  uint32_t uLength;
228	#endif /* !(SFU_NO_SWAP) */
229
230	  /* Check the pointers allocation */
231	  if (p_data == NULL)
232	  {
233	    return SFU_ERROR;
234	  }
235
236	  /*Increase the number of received packets*/
237	  m_uPacketsReceived++;
238
239	  /* Last packet : size of data to write could be different than SFU_COM_YMODEM_PACKE­T_1K_SIZE */
240	  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
241	  {
242	    /*Extracting actual payload from last packet*/
243	    if (0U == (m_uFileSizeYmodem % SFU_COM_YMODEM_PACKE­T_1K_SIZE))
244	    {
245	      /* The last packet must be fully considered */
246	      rx_size = SFU_COM_YMODEM_PACKE­T_1K_SIZE;
247	    }
248	    else
249	    {
250	      /* The last packet is not full, drop the extra bytes */
251	      rx_size = m_uFileSizeYmodem - ((uint32_t)(m_uFileSizeYmodem / SFU_COM_YMODEM_PACKE­T_1K_SIZE) *
252	                                     SFU_COM_YMODEM_PACKE­T_1K_SIZE);
253	    }
254	  }
255
256	  /* First packet : Contains the FW header (SE_FW_HEADER_TOT_LEN­ bytes length) which is not encrypted  */
257	  if (m_uPacketsReceived == 1U)
258	  {
259
260	    (void) memcpy(fw_header, p_data, SE_FW_HEADER_TOT_LEN­);
261
262	    /* Verify header */
263	    e_ret_status = SFU_LOADER_VerifyFwH­eader(p_data);
264	    if (e_ret_status == SFU_SUCCESS)
265	    {
266	      m_uDwlAreaAddress = m_uDwlAreaStart;
267	#if   defined(SFU_NO_SWAP)
268
269	      /* Downloaded Image size : Header size + Image size */
270	      m_uDwlImgSize = ((SE_FwRawHeaderTypeDe­f *)(uint32_t)fw_header)->FwSize + SFU_IMG_IMAGE_OFFSET­;
271	#else
272	      /* Downloaded Image size : Header size + gap for image alignment to (UpdateFwOffset % sector size) +
273	         Partial Image size */
274	      m_uDwlImgSize = ((SE_FwRawHeaderTypeDe­f *)(uint32_t)fw_header)->PartialFwSize +
275	                      (((SE_FwRawHeaderTypeDe­f *)(uint32_t)fw_header)->PartialFwOffset % SLOT_SIZE(SLOT_SWAP)) +
276	                      SFU_IMG_IMAGE_OFFSET­;
277	#endif /* (SFU_NO_SWAP) */
278	    }
279
280	    /* Clear Download application area (including TRAILERS area) */
281	    if (e_ret_status == SFU_SUCCESS)
282	    {
283	      if (SFU_LL_FLASH_Erase_S­ize(&x_flash_info, (uint8_t *) m_uDwlAreaAddress, SLOT_SIZE(m_uDwlSlot)) !=
284	          SFU_SUCCESS)
285	      {
286	        m_LoaderStatus = SFU_LOADER_ERR_FLASH­;
287	        e_ret_status = SFU_ERROR;
288	      }
289	    }
290
291	  }
292
293	#if  !defined(SFU_NO_SWAP)
294	  if (e_ret_status == SFU_SUCCESS)
295	  {
296	    /* This packet : contains end of FW header */
297	    if ((m_uDwlAreaAddress < (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET­)) &&
298	        ((m_uDwlAreaAddress + rx_size) >= (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET­)))
299	    {
300	      /* Write the FW header part (SFU_IMG_IMAGE_OFFSET­ % SFU_COM_YMODEM_PACKE­T_1K_SIZE bytes length) */
301	      uLength = SFU_IMG_IMAGE_OFFSET­ % SFU_COM_YMODEM_PACKE­T_1K_SIZE;
302	      if (uLength == 0U)
303	      {
304	        uLength = SFU_COM_YMODEM_PACKE­T_1K_SIZE;
305	      }
306	      if (SFU_LL_FLASH_Write(&x_flash_info, (uint8_t *)m_uDwlAreaAddress, p_data, uLength) == SFU_SUCCESS)
307	      {
308	        /* Shift the DWL area pointer, to align image with (PartialFwOffset % sector size) in DWL area */
309	        m_uDwlAreaAddress += uLength + (((SE_FwRawHeaderTypeDe­f *)(uint32_t)fw_header)->PartialFwOffset %
310	                                        SLOT_SIZE(SLOT_SWAP));
311
312	        /* Update remaining packet size to write */
313	        rx_size -= uLength;
314
315	        /* Update p_data pointer to received packet data */
316	        p_data += uLength;
317	      }
318	      else
319	      {
320	        m_LoaderStatus = SFU_LOADER_ERR_FLASH­;
321	        e_ret_status = SFU_ERROR;
322	      }
323	    }
324	  }
325	#endif /* !(SFU_NO_SWAP) */
326
327	  if (e_ret_status == SFU_SUCCESS)
328	  {
329	    /* Check size to avoid writing beyond DWL image size */
330	    if ((m_uDwlAreaAddress + rx_size) > (m_uDwlAreaStart + m_uDwlImgSize))
331	    {
332	      m_LoaderStatus = SFU_LOADER_ERR_FW_LE­NGTH;
333	      e_ret_status = SFU_ERROR;
334	    }
335	  }
336
337	  if (e_ret_status == SFU_SUCCESS)
338	  {
339	    /* Set dimension to the appropriate length for FLASH programming.
340	     * Example: 64-bit length for L4.
341	     */
342	    if ((rx_size % (uint32_t)sizeof(SFU_LL_FLASH_write_t­)) != 0U)
343	    {
344	      /* By construction, the length of the buffer (fw_decrypted_chunk or p_data) must be a multiple of
345	         sizeof(SFU_IMG_write_t) to avoid reading out of the buffer */
346	      uOldSize = rx_size;
347	      rx_size = rx_size + ((uint32_t)sizeof(SFU_LL_FLASH_write_t­) - (rx_size % (uint32_t)sizeof(SFU_LL_FLASH_write_t­)));
348	      while (uOldSize < rx_size)
349	      {
350	        p_data[uOldSize] = 0xFF;
351	        uOldSize++;
352	      }
353	    }
354	  }
355
356	  if (e_ret_status == SFU_SUCCESS)
357	  {
358	    /* Check size to avoid writing beyond DWL area */
359	    if ((m_uDwlAreaAddress + rx_size) > (m_uDwlAreaStart + m_uDwlAreaSize))
360	    {
361	      m_LoaderStatus = SFU_LOADER_ERR_FW_LE­NGTH;
362	      e_ret_status = SFU_ERROR;
363	    }
364	  }
365
366	  /* Write Data in Flash */
367	  if (e_ret_status == SFU_SUCCESS)
368	  {
369	    if (SFU_LL_FLASH_Write(&x_flash_info, (uint8_t *)m_uDwlAreaAddress, p_data, rx_size) == SFU_SUCCESS)
370	    {
371	      m_uDwlAreaAddress += (rx_size);
372	    }
373	    else
374	    {
375	      m_LoaderStatus = SFU_LOADER_ERR_FLASH­;
376	      e_ret_status = SFU_ERROR;
377	    }
378	  }
379
380
381	  /* Last packet : reset m_uPacketsReceived */
382	  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
383	  {
384	    m_uPacketsReceived = 0U;
385	  }
386
387	  /* Reset data counters in case of error */
388	  if (e_ret_status == SFU_ERROR)
389	  {
390	    /*Reset of the ymodem variables */
391	    m_uFileSizeYmodem = 0U;
392	    m_uPacketsReceived = 0U;
393	    m_uNbrBlocksYmodem = 0U;
394	  }
395
396	  return e_ret_status;
397	}
398	#else /* MINICOM_YMODEM */
399	/* Minicom variant of the YMODEM protocol: uses 128B packets */
400	SFU_ErrorStatus SFU_COM_YMODEM_DataP­ktRxCpltCallback(uint8_t *pData, uint32_t uSize)
401	{
402	  /* The local loader must make a copy of the Firmware metadata,
403	   * because this memory area is not copied when calling the SE_Decrypt_Init() primitive.
404	   * Hence we must make sure this memory area still contains the FW header when SE_Decrypt_Finish() is called. */
405	  static uint8_t fw_header[SE_FW_HEADER_TOT_LEN­] __attribute__((aligned(8)));
406	  /* Size of downloaded Image initialized with first packet (header) and checked along download process */
407	  static uint32_t m_uDwlImgSize = 0U;
408
409	  SFU_ErrorStatus e_ret_status = SFU_SUCCESS;
410	  SFU_FLASH_StatusType­Def x_flash_info;
411	  uint32_t rx_size = uSize;
412	  uint8_t *p_data = pData;
413	  uint32_t uOldSize;
414
415	  /* Check the pointers allocation */
416	  if (p_data == NULL)
417	  {
418	    return SFU_ERROR;
419	  }
420
421	  /*Increase the number of received packets*/
422	  m_uPacketsReceived++;
423
424	  /* Last packet : size of data to write could be different than SFU_COM_YMODEM_PACKE­T_1K_SIZE */
425	  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
426	  {
427	    /*Extracting actual payload from last packet: minicom works by default with 128B packets */
428	    if (0 == (m_uFileSizeYmodem % SFU_COM_YMODEM_PACKE­T_SIZE))
429	    {
430	      /* The last packet must be fully considered */
431	      rx_size = SFU_COM_YMODEM_PACKE­T_SIZE;
432	    }
433	    else
434	    {
435	      /* The last packet is not full, drop the extra bytes: minicom works by default with 128B packets */
436	      rx_size = m_uFileSizeYmodem - ((uint32_t)(m_uFileSizeYmodem / SFU_COM_YMODEM_PACKE­T_SIZE) *
437	                                     SFU_COM_YMODEM_PACKE­T_SIZE);
438	    }
439	  }
440
441
442	  /*
443	   * Minicom splits the header of 192 bytes on 2 packets of 128 bytes.
444	   */
445
446	  /* First packet : Contains the first 128B of FW header (out of SE_FW_HEADER_TOT_LEN­ bytes length) which is
447	     not encrypted  */
448	  if (1 == m_uPacketsReceived)
449	  {
450	    /* First packet: beginning of header */
451	    if (SFU_COM_YMODEM_PACKE­T_SIZE == rx_size)
452	    {
453	      /* Copy the beginning of the header */
454	      memcpy(fw_header, p_data, rx_size);
455	      rx_size = 0U; /* nothing more to do */
456	    }
457	    else
458	    {
459	      /* Unexpected case */
460	      e_ret_status = SFU_ERROR;
461	    }
462	  }
463	  else if (2U == m_uPacketsReceived)
464	  {
465	    /* Second packet: end of header (64 bytes) */
466	    memcpy(fw_header + SFU_COM_YMODEM_PACKE­T_SIZE, p_data, 64U);
467	    rx_size -= 64U;
468	    p_data += 64U;
469
470	    /* Verify header */
471	    e_ret_status = SFU_LOADER_VerifyFwH­eader(fw_header);
472
473	    if (e_ret_status == SFU_SUCCESS)
474	    {
475	      m_uDwlAreaAddress = m_uDwlAreaStart;
476	      /* Downloaded Image size : Header size + gap for image alignment to (UpdateFwOffset % sector size) +
477	         Partial Image size */
478	      m_uDwlImgSize = ((SE_FwRawHeaderTypeDe­f *)fw_header)->PartialFwSize +
479	                      (((SE_FwRawHeaderTypeDe­f *)fw_header)->PartialFwOffset % SLOT_SIZE(SLOT_SWAP)) +
480	                      SFU_IMG_IMAGE_OFFSET­;
481
482	      /* Clear Download application area (including TRAILERS area) */
483	      if ((e_ret_status == SFU_SUCCESS)
484	          && (SFU_LL_FLASH_Erase_S­ize(&x_flash_info, (uint8_t *) m_uDwlAreaAddress, SLOT_SIZE(m_uDwlSlot)) !=
485	              SFU_SUCCESS))
486	      {
487	        m_LoaderStatus = SFU_LOADER_ERR_FLASH­;
488	        e_ret_status = SFU_ERROR;
489	      }
490
491	      if (e_ret_status == SFU_SUCCESS)
492	      {
493	        /* Write the FW header (SE_FW_HEADER_TOT_LEN­ bytes length) at start of DWL area */
494	        if (SFU_LL_FLASH_Write(&x_flash_info, (uint8_t *)m_uDwlAreaAddress, fw_header, SE_FW_HEADER_TOT_LEN­)
495	            == SFU_SUCCESS)
496	        {
497	          /* Shift the DWL area pointer (still to be aligned image with (PartialFwOffset % sector size) in DWL area ) */
498	          m_uDwlAreaAddress += SE_FW_HEADER_TOT_LEN­;
499	        }
500	        else
501	        {
502	          m_LoaderStatus = SFU_LOADER_ERR_FLASH­;
503	          e_ret_status = SFU_ERROR;
504	        }
505	      }
506	      /* The remaining 64 bytes of data must be handled : standard processing */
507	    }
508	  }
509	  /*
510	   * Else: standard packet data processing based on rx_size (full packet or the last 64 bytes of the 2nd packet)
511	   */
512	  if (e_ret_status == SFU_SUCCESS)
513	  {
514	    /*
515	     * End of the second packet (64B) or full 128B packet
516	     * Skip padding bytes then take partial FW offset into account
517	     */
518	    if (m_uDwlAreaAddress < (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET­))
519	    {
520	      /* Skip the padding bytes */
521	      m_uDwlAreaAddress += rx_size;
522	      rx_size = 0U;
523	    }
524	    else
525	    {
526	      /*
527	       * m_uDwlAreaAddress >= (m_uDwlAreaStart + SFU_IMG_IMAGE_OFFSET­)
528	       */
529	      if (((SFU_IMG_IMAGE_OFFSET­ / SFU_COM_YMODEM_PACKE­T_SIZE) + 1) == m_uPacketsReceived)
530	      {
531	        /* End of padding bytes : We must take the partial offset into account */
532	        m_uDwlAreaAddress += ((SE_FwRawHeaderTypeDe­f *)fw_header)->PartialFwOffset % SLOT_SIZE(SLOT_SWAP);
533	      }
534	      /* else nothing more to do */
535
536	      /* Check size to avoid writing beyond DWL image size */
537	      if ((m_uDwlAreaAddress + rx_size) > (m_uDwlAreaStart + m_uDwlImgSize))
538	      {
539	        m_LoaderStatus = SFU_LOADER_ERR_FW_LE­NGTH;
540	        e_ret_status = SFU_ERROR;
541	      }
542
543	      /*
544	       * Set dimension to the appropriate length for FLASH programming.
545	       * Example: 64-bit length for L4.
546	       */
547	      if ((rx_size % (uint32_t)sizeof(SFU_LL_FLASH_write_t­)) != 0)
548	      {
549	        /*
550	         * By construction, the length of the buffer (fw_decrypted_chunk or p_data) must be a multiple of
551	         * sizeof(SFU_IMG_write_t) to avoid reading out of the buffer
552	         */
553	        uOldSize = rx_size;
554	        rx_size = rx_size + ((uint32_t)sizeof(SFU_LL_FLASH_write_t­) -
555	                             (rx_size % (uint32_t)sizeof(SFU_LL_FLASH_write_t­)));
556	        while (uOldSize < rx_size)
557	        {
558	          p_data[uOldSize] = 0xFF;
559	          uOldSize++;
560	        }
561	      }
562
563	      /* Check size to avoid writing beyond DWL area */
564	      if ((m_uDwlAreaAddress + rx_size) > (m_uDwlAreaStart + m_uDwlAreaSize))
565	      {
566	        m_LoaderStatus = SFU_LOADER_ERR_FW_LE­NGTH;
567	        e_ret_status = SFU_ERROR;
568	      }
569
570	      /* Write Data in Flash */
571	      if (e_ret_status == SFU_SUCCESS)
572	      {
573	        /*
574	         * With Minicom Ymodem, the data offset is not aligned because SFU_COM_YMODEM_PACKE­T_DATA_INDEX is 7
575	         * So we cannot write in FLASH with p_data as source, we need a copy in an aligned buffer
576	         */
577	        memcpy(alignedBuffer, p_data, rx_size);
578
579	        if (SFU_LL_FLASH_Write(&x_flash_info, (uint8_t *)m_uDwlAreaAddress, alignedBuffer, rx_size) == SFU_SUCCESS)
580	        {
581	          m_uDwlAreaAddress += (rx_size);
582	        }
583	        else
584	        {
585	          m_LoaderStatus = SFU_LOADER_ERR_FLASH­;
586	          e_ret_status = SFU_ERROR;
587	        }
588	      }
589	    }
590	  }
591
592
593	  /* Last packet : reset m_uPacketsReceived */
594	  if (m_uPacketsReceived == m_uNbrBlocksYmodem)
595	  {
596	    m_uPacketsReceived = 0U;
597	  }
598
599	  /* Reset data counters in case of error */
600	  if (e_ret_status == SFU_ERROR)
601	  {
602	    /*Reset of the ymodem variables */
603	    m_uFileSizeYmodem = 0U;
604	    m_uPacketsReceived = 0U;
605	    m_uNbrBlocksYmodem = 0U;
606	  }
607
608	  return e_ret_status;
609	}
610	#endif /* MINICOM_YMODEM */
611
612
613	/**
614	  * @brief  Verifies the Raw Fw Header received. It checks if the header is
615	  *         authentic and if the fields are ok with the device (e.g. size and version).
616	  * @note   Please note that when the new image is installed, this metadata is checked
617	  *         by @ref SFU_IMG_CheckCandida­teVersion.
618	  * @param  peSFU_LOADER_Status: SFU LOADER Status.
619	  *         This parameter can be a value of @ref SFU_LOADER_Status_St­ructure_definition.
620	  * @param  pBuffer: pointer to header Buffer.
621	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
622	  */
623
624	/* anti-rollback mechanism is tested twice to avoid basic hardware attack
625	   ==> compiler optimization is disabled for this reason */
626	#if defined(__ICCARM__)
627	#pragma optimize=none
628	#elif defined(__CC_ARM)
629	#pragma O0
630	#elif defined (__ARMCC_VERSION)
631	__attribute__((optnone))
632	#elif defined ( __GNUC__ )
633	__attribute__((optimize("O0")))
634	#endif /* __ICCARM__ */
635
636	static SFU_ErrorStatus SFU_LOADER_VerifyFwH­eader(uint8_t *pBuffer)
637	{
638	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
639	  SE_StatusTypeDef              e_se_status;
640	  SE_FwRawHeaderTypeDe­f         *p_x_fw_raw_header;
641	  SFU_FwImageFlashType­Def       fw_image_flash_data;
642	  uint16_t                      cur_ver;
643	  uint16_t                      verif_ver;
644	  uint32_t                      active_slot;
645
646	  /*Parse the received buffer*/
647	  p_x_fw_raw_header = (SE_FwRawHeaderTypeDe­f *)(uint32_t)pBuffer;
648
649	  /*Check if the received header packet is authentic*/
650	  if (SE_VerifyHeaderSigna­ture(&e_se_status, p_x_fw_raw_header) != SE_ERROR)
651	  {
652	    active_slot = SFU_IMG_GetFwImageSl­ot(p_x_fw_raw_header);
653	    /*
654	     * 2 slots per image configuration. Identify the download area.
655	     *   It will be based on SFU magic :
656	     *   - same number as active_slot if configured.
657	     *   - else : SLOT_DWL_1
658	     *    As example : Header magic is SFU2, active slot is SLOT_ACTIVE_2 and dwl slot will be SLOT_DWL2.
659	     */
660	    m_uDwlSlot = active_slot - SLOT_ACTIVE_1 + SLOT_DWL_1;
661	    if (SLOT_SIZE(m_uDwlSlot) == 1U)
662	    {
663	      m_uDwlSlot = SLOT_DWL_1;
664	    }
665	    SFU_IMG_GetDownloadA­reaInfo(m_uDwlSlot, &fw_image_flash_data);
666
667	    /* Assign the download flash address to be used during the YMODEM process */
668	    m_uDwlAreaStart = fw_image_flash_data.DownloadAddr;
669	    m_uDwlAreaSize = fw_image_flash_data.MaxSizeInBytes;
670
671	    /*
672	     * Check if the version is allowed
673	     * ==> SFU_IMG_GetActiveFwV­ersion() returns 0 if the header of active firmware is not valid
674	     */
675	    cur_ver = SFU_IMG_GetActiveFwV­ersion(active_slot);
676	    if (SFU_IMG_CheckFwVersi­on(active_slot, cur_ver, p_x_fw_raw_header->FwVersion) == SFU_SUCCESS)
677	    {
678	#if  defined(SFU_NO_SWAP)
679	      /*
680	       * Check length : Let's make sure the Firmware image can be written in the destination slot.
681	       */
682	      if (p_x_fw_raw_header->FwSize > (SLOT_SIZE(m_uDwlSlot) - SFU_IMG_IMAGE_OFFSET­))
683	#else
684	      /*
685	       * Check length :
686	       *      We do not check the length versus the trailer constraint because this check is already implemented in
687	       *      FirmwareToInstall().
688	       *      If the firmware is too big to have some room left for the trailer info then the installation will not be
689	       *      triggered.
690	       *      The interest is to avoid duplicating the checks (checking just in time).
691	       *      This is also because in the case of a download handled by the UserApp we cannot rely on the checks done
692	       *      by the UserApp before installing a FW.
693	       *      The drawback is that the firmware can be downloaded in dwl slot though it is too big.
694	       *
695	       *      Nevertheless, we can still detect if the FW is too big to be downloaded (cannot be written in dwl slot).
696	       *      This will avoid download issues (but the installation itself can still be rejected) or overflows.
697	       *      The dwl slot must contain the HEADER and also the binary FW (encrypted).
698	       *      But there is an offset of FW_OFFSET_IMAGE bytes to respect.
699	       */
700	      if ((p_x_fw_raw_header->PartialFwSize + (p_x_fw_raw_header->PartialFwOffset % SLOT_SIZE(SLOT_SWAP))) >
701	          (SLOT_SIZE(m_uDwlSlot) - SFU_IMG_IMAGE_OFFSET­))
702	#endif /* (SFU_NO_SWAP) */
703	      {
704	        /* The firmware cannot be written in dwl slot */
705	        m_LoaderStatus = SFU_LOADER_ERR_FW_LE­NGTH;
706	      }
707	      else
708	      {
709	        /* Installation authorized */
710	        e_ret_status = SFU_SUCCESS;
711	      }
712	    }
713	    else
714	    {
715	      /* The installation is forbidden */
716	      TRACE("\r\n          Anti-rollback: candidate version(%d) rejected | current version(%d) , min.version(%d) !",
717	            p_x_fw_raw_header->FwVersion, cur_ver, SFU_FW_VERSION_START­_NUM);
718	      m_LoaderStatus = SFU_LOADER_ERR_FW_VE­RSION;
719	    }
720
721
722	    /*
723	     * Control of version and length is done twice to avoid basic hardware attack
724	     * This more important for the 1 image configuration as the installation is done during the download procedure
725	     * For the 2 images configuration anti-rollback will be checked again during installation process
726	     */
727	    verif_ver = SFU_IMG_GetActiveFwV­ersion(active_slot);
728	    if (SFU_IMG_CheckFwVersi­on(active_slot, verif_ver, p_x_fw_raw_header->FwVersion) == SFU_SUCCESS)
729	    {
730	#if  defined(SFU_NO_SWAP)
731	      /*
732	       * Check length : Let's make sure the Firmware image can be written in the destination slot.
733	       */
734	      if (p_x_fw_raw_header->FwSize > (SLOT_SIZE(m_uDwlSlot) - SFU_IMG_IMAGE_OFFSET­))
735	#else
736	      /*
737	       * Check length :
738	       *      We do not check the length versus the trailer constraint because this check is already implemented in
739	       *      FirmwareToInstall().
740	       *      If the firmware is too big to have some room left for the trailer info then the installation will not be
741	       *      triggered.
742	       *      The interest is to avoid duplicating the checks (checking just in time).
743	       *      This is also because in the case of a download handled by the UserApp we cannot rely on the checks done
744	       *      by the UserApp before installing a FW.
745	       *      The drawback is that the firmware can be downloaded in dwl slot though it is too big.
746	       *
747	       *      Nevertheless, we can still detect if the FW is too big to be downloaded (cannot be written in dwl slot).
748	       *      This will avoid download issues (but the installation itself can still be rejected) or overflows.
749	       *      The dwl slot must contain the HEADER and also the binary FW (encrypted).
750	       *      But there is an offset of FW_OFFSET_IMAGE bytes to respect.
751	       */
752	      if ((p_x_fw_raw_header->PartialFwSize + (p_x_fw_raw_header->PartialFwOffset % SLOT_SIZE(SLOT_SWAP))) >
753	          (SLOT_SIZE(m_uDwlSlot) - SFU_IMG_IMAGE_OFFSET­))
754	#endif /* (SFU_NO_SWAP) */
755	      {
756	        /* The firmware cannot be written in dwl slot */
757	        m_LoaderStatus = SFU_LOADER_ERR_FW_LE­NGTH;
758	      }
759	      else
760	      {
761	        /* Installation authorized */
762	        e_ret_status = SFU_SUCCESS;
763	      }
764	    }
765	    else
766	    {
767	      /* The installation is forbidden */
768	      TRACE("\r\n          Anti-rollback: candidate version(%d) rejected | current version(%d) , min.version(%d) !",
769	            p_x_fw_raw_header->FwVersion, verif_ver, SFU_FW_VERSION_START­_NUM);
770	      m_LoaderStatus = SFU_LOADER_ERR_FW_VE­RSION;
771	    }
772	  }
773	  else
774	  {
775	    /* Header authentication failure */
776	    m_LoaderStatus = SFU_LOADER_ERR_AUTH_­FAILED;
777	  }
778
779	  return e_ret_status;
780	}
781
782	#endif /* (SECBOOT_LOADER == SECBOOT_USE_LOCAL_LO­ADER) */
783
L476_SBSFU\BFU\Application\BFU\App\sfu_loader.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_loader.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for Secure Firmware Update local
6	  *          loader.
7	  ******************************************************************************
8	  * @attention
9	  *
10	  * Copyright (c) 2017 STMicroelectronics.
11	  * All rights reserved.
12	  *
13	  * This software is licensed under terms that can be found in the LICENSE file in
14	  * the root directory of this software component.
15	  * If no LICENSE file comes with this software, it is provided AS-IS.
16	  *
17	  ******************************************************************************
18	  */
19
20	/* Define to prevent recursive inclusion -------------------------------------*/
21	#ifndef SFU_LOADER_H
22	#define SFU_LOADER_H
23
24	#ifdef __cplusplus
25	extern "C" {
26	#endif
27
28	/* Includes ------------------------------------------------------------------*/
29	#include "main.h"
30	#include "se_def.h"
31	#include "sfu_def.h"
32	#include "sfu_new_image.h"
33
34	/* Exported types ------------------------------------------------------------*/
35	/**
36	  * Local loader status Type Definition
37	  */
38	typedef enum
39	{
40	  SFU_LOADER_OK                            = 0x00U,
41	  SFU_LOADER_ERR_COM                       = 0x01U,
42	  SFU_LOADER_ERR_AUTH_­FAILED               = 0x02U,
43	  SFU_LOADER_ERR_FW_LE­NGTH                 = 0x03U,
44	  SFU_LOADER_ERR_FW_VE­RSION                = 0x04U,
45	  SFU_LOADER_ERR_FLASH­                     = 0x05U,
46	  SFU_LOADER_ERR_CRYPT­O                    = 0x06U
47	} SFU_LOADER_StatusTyp­eDef;
48
49	/* Exported functions ------------------------------------------------------- */
50	SFU_ErrorStatus SFU_LOADER_Init(void);
51	SFU_ErrorStatus SFU_LOADER_DeInit(void);
52	SFU_ErrorStatus SFU_LOADER_DownloadN­ewUserFw(SFU_LOADER_StatusTyp­eDef *peSFU_LOADER_Status, uint32_t *p_DwlSlot,
53	                                             uint32_t *p_Size);
54
55	#ifdef __cplusplus
56	}
57	#endif
58
59	#endif /* SFU_LOADER_H */
60
L476_SBSFU\BFU\Application\BFU\App\sfu_new_image.c
1	/**
2	  ******************************************************************************
3	  * @file    sfu_new_image.c
4	  * @author  MCD Application Team
5	  * @brief   This file provides set of firmware functions to manage the New Firmware Image storage and installation.
6	  *          This file contains the services the bootloader can use to
7	  *          know where to store a new FW image and request its installation.
8	  *          The same services are offered to the user application thanks to a similar file integrated in the user
9	  *          application.
10	  * @note    This file is compiled in the scope of SB_SFU.
11	  ******************************************************************************
12	  * @attention
13	  *
14	  * Copyright (c) 2017 STMicroelectronics.
15	  * All rights reserved.
16	  *
17	  * This software is licensed under terms that can be found in the LICENSE file in
18	  * the root directory of this software component.
19	  * If no LICENSE file comes with this software, it is provided AS-IS.
20	  *
21	  ******************************************************************************
22	  */
23
24	/* Includes ------------------------------------------------------------------*/
25	#include "main.h"
26	#include "sfu_def.h"
27	#include "sfu_low_level_flash_­int.h"
28	#include "sfu_new_image.h"
29	#include "sfu_fwimg_services.h"
30	#include "sfu_fwimg_regions.h"
31	#include "se_def_metadata.h"
32	#include <string.h> /* needed for memset (see WriteInstallHeader)*/
33
34	#if  !defined(SFU_NO_SWAP)
35	/* Functions Definition ------------------------------------------------------*/
36	/**
37	  * @brief  Write the header of the firmware to install
38	  * @param  pfw_header pointer to header to write.
39	  * @retval SFU_SUCCESS on success otherwise SFU_ERROR
40	  */
41	static SFU_ErrorStatus WriteInstallHeader(uint8_t *pfw_header)
42	{
43	  SFU_ErrorStatus ret = SFU_ERROR;
44	  SFU_FLASH_StatusType­Def flash_if_info;
45
46	  ret = SFU_LL_FLASH_Erase_S­ize(&flash_if_info, (uint8_t *) SlotStartAdd[SLOT_SWAP], SFU_IMG_IMAGE_OFFSET­);
47	  if (ret == SFU_SUCCESS)
48	  {
49	    ret = SFU_LL_FLASH_Write(&flash_if_info, (uint8_t *)SlotStartAdd[SLOT_SWAP], pfw_header, SE_FW_HEADER_TOT_LEN­);
50	  }
51	  return ret;
52	}
53	#endif /* !SFU_NO_SWAP*/
54
55	/**
56	  * @brief  Write in Flash the next header image to install.
57	  *         This function is used by the local loader to request a Firmware installation (at next reboot).
58	  * @param  fw_header FW header of the FW to be installed
59	  * @retval SFU_SUCCESS if successful, otherwise SFU_ERROR
60	  */
61	SFU_ErrorStatus SFU_IMG_InstallAtNex­tReset(uint8_t *fw_header)
62	{
63	#if  !defined(SFU_NO_SWAP)
64	  if (fw_header == NULL)
65	  {
66	    return SFU_ERROR;
67	  }
68	  if (WriteInstallHeader(fw_header) != SFU_SUCCESS)
69	  {
70	    return SFU_ERROR;
71	  }
72	  return SFU_SUCCESS;
73	#else
74	  return SFU_SUCCESS;           /* Nothing to do */
75	#endif /* !SFU_NO_SWAP*/
76	}
77
78	/**
79	  * @brief  Provide the area descriptor to write a FW image in Flash.
80	  *         This function is used by the local loader to know where to store a new Firmware Image before asking for its
81	  *         installation.
82	  * @param  DwlSlot identification of the downloaded area
83	  * @param  pArea pointer to area descriptor
84	  * @retval none
85	  */
86	void SFU_IMG_GetDownloadA­reaInfo(uint32_t DwlSlot, SFU_FwImageFlashType­Def *pArea)
87	{
88	  pArea->DownloadAddr = SlotStartAdd[DwlSlot];
89	#if  !defined(SFU_NO_SWAP)
90	  pArea->MaxSizeInBytes = (uint32_t)SLOT_SIZE(DwlSlot) - SFU_IMG_GetTrailerSi­ze(DwlSlot);
91	#else
92	  pArea->MaxSizeInBytes = (uint32_t)SLOT_SIZE(DwlSlot);
93	#endif /* !(SFU_NO_SWAP) */
94	  pArea->ImageOffsetInBytes = SFU_IMG_IMAGE_OFFSET­;
95	}
96
L476_SBSFU\BFU\Application\BFU\App\sfu_new_image.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_new_image.h
4	  * @author  MCD Application Team
5	  * @brief   This file provides set of firmware functions to manage the New Firmware
6	  *          Image storage and installation.
7	  *          This file contains the services the bootloader can use to
8	  *          know where to store a new FW image and request its installation.
9	  *          The same services are offered to the user application thanks to a similar
10	  *          file integrated in the user application.
11	  ******************************************************************************
12	  * @attention
13	  *
14	  * Copyright (c) 2017 STMicroelectronics.
15	  * All rights reserved.
16	  *
17	  * This software is licensed under terms that can be found in the LICENSE file in
18	  * the root directory of this software component.
19	  * If no LICENSE file comes with this software, it is provided AS-IS.
20	  *
21	  ******************************************************************************
22	  */
23
24	/* Define to prevent recursive inclusion -------------------------------------*/
25	#ifndef SFU_NEW_IMAGE_H
26	#define SFU_NEW_IMAGE_H
27
28	#ifdef __cplusplus
29	extern "C" {
30	#endif
31
32	/* Includes ------------------------------------------------------------------*/
33	#include "sfu_def.h"
34
35	/* Exported types ------------------------------------------------------------*/
36	/**
37	  * @brief Specifies a structure containing values related to the management of multi-images in Flash.
38	  */
39	typedef struct
40	{
41	  uint32_t  MaxSizeInBytes;        /*!< The maximum allowed size for the FwImage in User Flash (in Bytes) */
42	  uint32_t  DownloadAddr;          /*!< The download address for the FwImage in UserFlash */
43	  uint32_t  ImageOffsetInBytes;    /*!< Image write starts at this offset */
44	  uint32_t  ExecutionAddr;         /*!< The execution address for the FwImage in UserFlash */
45	} SFU_FwImageFlashType­Def;
46
47	/* Exported functions ------------------------------------------------------- */
48	SFU_ErrorStatus SFU_IMG_InstallAtNex­tReset(uint8_t *fw_header);
49	void SFU_IMG_GetDownloadA­reaInfo(uint32_t DwlSlot, SFU_FwImageFlashType­Def *pArea);
50
51	#ifdef __cplusplus
52	}
53	#endif
54
55	#endif /* SFU_NEW_IMAGE_H */
56
57
L476_SBSFU\BFU\Application\BFU\App\sfu_standalone_loader.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_standalone_loade­r.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for Secure Firmware Update standalone
6	  *          loader.
7	  ******************************************************************************
8	  * @attention
9	  *
10	  * Copyright (c) 2017 STMicroelectronics.
11	  * All rights reserved.
12	  *
13	  * This software is licensed under terms that can be found in the LICENSE file in
14	  * the root directory of this software component.
15	  * If no LICENSE file comes with this software, it is provided AS-IS.
16	  *
17	  ******************************************************************************
18	  */
19
20	/* Define to prevent recursive inclusion -------------------------------------*/
21	#ifndef SFU_STANDALONE_LOADE­R_H
22	#define SFU_STANDALONE_LOADE­R_H
23
24	#ifdef __cplusplus
25	extern "C" {
26	#endif
27
28	/* Exported types ------------------------------------------------------------*/
29	#if (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER)
30	/**
31	  * Standalone loader status definitions : information saved in non-initialized RAM shared memory
32	  * ==> LOADER_COM_REGION_RA­M_START
33	  */
34	#define STANDALONE_LOADER_NO­_REQ         0x00000000U /*!< No request */
35	#define STANDALONE_LOADER_DW­L_REQ        0x375AA32CU /*!< Download function execution requested */
36	#define STANDALONE_LOADER_BY­PASS_REQ     0xABCDEF01U /*!< By pass mode request */
37	#define STANDALONE_LOADER_IN­STALL_REQ    0x01234567U /*!< User App installation request */
38
39	#define STANDALONE_LOADER_ST­ATE          (*(uint32_t *)LOADER_COM_REGION_RA­M_START)
40	#endif
41
42	#ifdef __cplusplus
43	}
44	#endif
45
46	#endif /* SFU_STANDALONE_LOADE­R_H */
47
48
L476_SBSFU\BFU\Application\BFU\App\sfu_test.c
1	/**
2	  ******************************************************************************
3	  * @file    sfu_test.c
4	  * @author  MCD Application Team
5	  * @brief   Test Protections module.
6	  *          This file provides set of firmware functions to manage Test Protections
7	  *          functionalities.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Includes ------------------------------------------------------------------*/
22	#include "sfu_test.h"
23	#include "main.h"
24	#include "sfu_trace.h"
25	#include "sfu_low_level_flash_­int.h"
26	#include "sfu_low_level_securi­ty.h"
27	#include "sfu_low_level.h"
28	#include "string.h" /* required for strncmp */
29
30	#if defined(SFU_TEST_PROTECTION)
31
32	extern RTC_HandleTypeDef RtcHandle;
33
34	/* Private defines -----------------------------------------------------------*/
35	#define TEST_ISOLATION 1
36
37	/* Automatic tests : list of tests (Address, Message, Operation */
38	/* Flash programming by 64 bits */
39	#define SHIFT_FLASH_WRITE (8U-1U)
40
41	/* Private variables ---------------------------------------------------------*/
42	static ProtectionTest_t aProtectTests[] =
43	{
44	#ifdef SFU_MPU_PROTECT_ENAB­LE
45	  {SFU_RAM_BASE, "MPU SRAM1 start add", TEST_EXECUTE},
46	  {SFU_RAM_END - 3U, "MPU SRAM1 end add", TEST_EXECUTE},             /* -3 : previous 32 bits for execute test */
47	  {SFU_SRAM2_BASE, "MPU SRAM2 start add", TEST_EXECUTE},
48	  {SFU_SRAM2_END - 3U, "MPU SRAM2 end add", TEST_EXECUTE},             /* -3 : previous 32 bits for execute test */
49	  {PERIPH_BASE, "Peripheral base add", TEST_EXECUTE},
50	  {((uint32_t)0x5FFFFFFF - 3U), "Peripheral end address", TEST_EXECUTE},    /* -3 : previous 32 bits for execute test */
51	  /* READ_FLASH is possible as we are privileged when there is no MPU isolation but WRITE_FLASH must fail */
52	  {INTVECT_START, "Init. Vector", TEST_WRITE_FLASH},
53	  {SLOT_DWL_1_START, "MPU code dwl slot1 begin add", TEST_EXECUTE},
54	  {SLOT_DWL_1_END - 3U, "MPU code dwl slot1 end add", TEST_EXECUTE},   /* -3 : alignment for 32bits execute test */
55	  {SLOT_DWL_2_START, "MPU code dwl slot2 begin add", TEST_EXECUTE},
56	  {SLOT_DWL_2_END - 3U, "MPU code dwl slot2 end add", TEST_EXECUTE},   /* -3 : alignment for 32bits execute test */
57	  {SLOT_DWL_3_START, "MPU code dwl slot3 begin add", TEST_EXECUTE},
58	  {SLOT_DWL_3_END - 3U, "MPU code dwl slot3 end add", TEST_EXECUTE},   /* -3 : alignment for 32bits execute test */
59	  {SWAP_START, "MPU code swap begin add", TEST_EXECUTE},
60	  {SWAP_END - 3U, "MPU code swap end add", TEST_EXECUTE},       /* -3 : alignment for 32bits execute test */
61	  {SLOT_ACTIVE_1_START, "MPU code active slot1 begin add", TEST_EXECUTE},
62	  {SLOT_ACTIVE_1_END - 3U, "MPU code active1 slot end add", TEST_EXECUTE}, /* -3 : alignment for 32bits execute test */
63	  {SLOT_ACTIVE_2_START, "MPU code active slot2 begin add", TEST_EXECUTE},
64	  {SLOT_ACTIVE_2_END - 3U, "MPU code active slot2 end add", TEST_EXECUTE}, /* -3 : alignment for 32bits execute test */
65	  {SLOT_ACTIVE_3_START, "MPU code active slot3 begin add", TEST_EXECUTE},
66	  {SLOT_ACTIVE_3_END - 3U, "MPU code active slot3 end add", TEST_EXECUTE}, /* -3 : alignment for 32bits execute test */
67	#endif /* SFU_MPU_PROTECT_ENAB­LE */
68	#ifdef SFU_WRP_PROTECT_ENAB­LE
69	  {INTVECT_START, "WRP start add", TEST_WRITE_FLASH},
70	  {SFU_ROM_ADDR_END - SHIFT_FLASH_WRITE, "WRP end add", TEST_WRITE_FLASH}, /* -7 : alignment for 64bits writing test */
71	  {SB_REGION_ROM_START, "WRP internal (SB) add", TEST_ERASE_FLASH},
72	#endif /* SFU_WRP_PROTECT_ENAB­LE */
73	#ifdef SFU_PCROP_PROTECT_EN­ABLE
74	  {SE_KEY_REGION_ROM_ST­ART, "PCROP start add", TEST_WRITE_FLASH},
75	  {SE_KEY_REGION_ROM_EN­D - SHIFT_FLASH_WRITE, "PCROP end add", TEST_WRITE_FLASH}, /* -7 : alignment for 64bits
76	                                                                                         writing test */
77	  {SE_KEY_REGION_ROM_ST­ART, "PCROP start add", TEST_READ_FLASH},
78	  {SE_KEY_REGION_ROM_EN­D, "PCROP end add", TEST_READ_FLASH},
79	#endif /* SFU_PCROP_PROTECT_EN­ABLE */
80	#if defined(TEST_ISOLATION)
81	  {SE_CODE_REGION_ROM_S­TART, "Isolated code start add", TEST_WRITE_FLASH},        /* WRP protection applies  */
82	  {SE_CODE_REGION_ROM_E­ND - SHIFT_FLASH_WRITE, "Isolated code end add", TEST_WRITE_FLASH},/* -7 : alignment for
83	                                                                         64bits writing test + WRP protection applies */
84	  {SE_CODE_REGION_ROM_S­TART, "Isolated code start add", TEST_READ_FLASH},
85	  {SE_KEY_REGION_ROM_ST­ART, "Isol KeyConst start addr", TEST_READ_FLASH},
86	  {SE_KEY_REGION_ROM_EN­D, "Isol KeyConst end addr", TEST_READ_FLASH},
87	  {SE_CODE_REGION_ROM_E­ND, "Isolated code end add", TEST_READ_FLASH},
88	  {SE_STARTUP_REGION_RO­M_START + 1U, "Isolated startup add", TEST_EXECUTE}, /* +1 : contains the SE startup code
89	                                                                    that initializes all the variables in the binary. */
90	  {SE_CODE_REGION_ROM_S­TART, "Isolated code start add", TEST_EXECUTE},
91	  {SE_CODE_REGION_ROM_E­ND - 3U, "Isolated code end add", TEST_EXECUTE}, /* -3 : alignment for 32bits execute test */
92	  {SE_REGION_RAM_START, "Isolated Vdata add", TEST_WRITE_RAM},
93	  {SE_REGION_RAM_END - 3U, "Isolated Vdata add", TEST_WRITE_RAM},     /* -3 : alignment for 32bits writing test */
94	  {SE_REGION_RAM_START, "Isolated Vdata add", TEST_READ_RAM},
95	  {SE_REGION_RAM_END, "Isolated Vdata add", TEST_READ_RAM},
96	  {SE_REGION_RAM_START, "Isolated Vdata add", TEST_EXECUTE},
97	  {SE_REGION_RAM_END - 3U, "Isolated Vdata add", TEST_EXECUTE},       /* -3 : alignment for 32bits writing test */
98	  {SLOT_ACTIVE_1_HEADER­ + SFU_IMG_IMAGE_OFFSET­ - (SHIFT_FLASH_WRITE + 1U), "Isolated NVdata add", TEST_WRITE_FLASH},
99	  /* -8 : previous 64 bits for writing test */
100	  {SLOT_ACTIVE_1_HEADER­ + SFU_IMG_IMAGE_OFFSET­ - 1U, "Isolated NVdata add", TEST_READ_FLASH},/* -1 : previous 8bits
101	                                                                                                   for reading test */
102	  {SLOT_ACTIVE_1_HEADER­ + SFU_IMG_IMAGE_OFFSET­ - 4U, "Isolated NVdata add", TEST_EXECUTE},   /* -4 : previous 32bits
103	                                                                                                   for execute test */
104	  {SLOT_ACTIVE_2_HEADER­ + SFU_IMG_IMAGE_OFFSET­ - (SHIFT_FLASH_WRITE + 1U), "Isolated NVdata add", TEST_WRITE_FLASH},
105	  /* -8 : previous 64 bits for writing test */
106	  {SLOT_ACTIVE_2_HEADER­ + SFU_IMG_IMAGE_OFFSET­ - 1U, "Isolated NVdata add", TEST_READ_FLASH},/* -1 : previous 8bits
107	                                                                                                   for reading test */
108	  {SLOT_ACTIVE_2_HEADER­ + SFU_IMG_IMAGE_OFFSET­ - 4U, "Isolated NVdata add", TEST_EXECUTE},   /* -4 : previous 32bits
109	                                                                                                   for execute test */
110	  {SLOT_ACTIVE_3_HEADER­ + SFU_IMG_IMAGE_OFFSET­ - (SHIFT_FLASH_WRITE + 1U), "Isolated NVdata add", TEST_WRITE_FLASH},
111	  /* -8 : previous 64 bits for writing test */
112	  {SLOT_ACTIVE_3_HEADER­ + SFU_IMG_IMAGE_OFFSET­ - 1U, "Isolated NVdata add", TEST_READ_FLASH},/* -1 : previous 8bits
113	                                                                                                   for reading test */
114	  {SLOT_ACTIVE_3_HEADER­ + SFU_IMG_IMAGE_OFFSET­ - 4U, "Isolated NVdata add", TEST_EXECUTE},   /* -4 : previous 32bits
115	                                                                                                   for execute test */
116	  {SE_KEY_REGION_ROM_ST­ART, "Isol KeyData BANK2 start addr", TEST_READ_FLASH_BANK­2},
117	  {SE_KEY_REGION_ROM_EN­D - 1U, "Isol KeyData BANK2 end addr", TEST_READ_FLASH_BANK­2},
118	  {SE_KEY_REGION_ROM_ST­ART, "Isol KeyData BANK2 start addr", TEST_EXECUTE_BANK2},
119	  {SE_KEY_REGION_ROM_EN­D - 3U, "Isol KeyData BANK2 end addr", TEST_EXECUTE_BANK2},
120	  {SE_CODE_REGION_ROM_S­TART, "Isol KeyConst BANK2 start addr", TEST_READ_FLASH_BANK­2},
121	  {SE_KEY_REGION_ROM_ST­ART - 1U, "Isol KeyConst BANK2 end addr", TEST_READ_FLASH_BANK­2},
122	#endif /* TEST_ISOLATION  */
123	#ifdef SFU_MPU_PROTECT_ENAB­LE
124	  /* Testing the MPU protection of the OBs */
125	  /*
126	   * L4xx
127	   * Only Bank 1 matters because the protections (WRP...) are set on the content of Bank 1.
128	   * [ 1FFF7800 1FFF7808 1FFF7810 1FFF7818 1FFF7820]: 40 bytes to be protected
129	   */
130	  {(uint32_t)0x1FFF7800, "OBs @ 0x1FFF7800", TEST_WRITE_FLASH},
131	  {(uint32_t)0x1FFF7808, "OBs @ 0x1FFF7808", TEST_WRITE_FLASH},
132	  {(uint32_t)0x1FFF7810, "OBs @ 0x1FFF7810", TEST_WRITE_FLASH},
133	  {(uint32_t)0x1FFF7818, "OBs @ 0x1FFF7818", TEST_WRITE_FLASH},
134	  {(uint32_t)0x1FFF7820, "OBs @ 0x1FFF7820", TEST_WRITE_FLASH},
135	  {(uint32_t)0x1FFF7838, "OBs @ 0x1FFF7838", TEST_WRITE_FLASH}, /* Due to MPU definition, we protect 64B instead of
136	                                                                   40B */
137	#endif /* SFU_MPU_PROTECT_ENAB­LE  */
138	  {0xAAAAAAAA, "Execution successful", TEST_END},
139	};
140
141
142	/* Automatic test : list of operation */
143	uint8_t aTestOperation[][20] =
144	{
145	  "write 8 bytes",
146	  "read 1 byte",
147	  "read 1 byte",
148	  "erase 512 bytes",
149	  "write 4 bytes",
150	  "read 1 byte",
151	  "execute",
152	  "execute",
153	  "end"
154	};
155
156	/* Private function prototypes -----------------------------------------------*/
157	static void SFU_TEST_Protection(void);
158
159	/* Functions Definition ------------------------------------------------------*/
160	/**
161	  * @brief  Automatic test of PCROP/WRP/FWALL/MPU protections
162	  * @param  None.
163	  * @retval None.
164	  */
165	static void SFU_TEST_Protection(void)
166	{
167	  uint32_t  offset = 0;
168	  uint32_t test_idx;
169	  uint32_t flashErrCode = 0;
170	  uint64_t pattern = 0U;
171	  uint32_t page_error = 0U;
172	  FLASH_EraseInitTypeD­ef p_erase_init;
173	  TestStatus status = TEST_IN_PROGRESS;
174	  __IO uint8_t tmp;
175	  void (*func)(void);
176
177	  /*
178	    * Now checking the security
179	    * We will try to access protected @ and run protected code.
180	    * Each time a a flash error will be raised or a reset will be generated by IP protection.
181	    * At next boot we read the backup register to check the next @ until all addresses have been verified.
182	    * WatchDog should be disabled : while(1) loop in case HardFault when trying to execute code @ address protected by
183	    * FWALL/Code Isolation
184	    */
185
186	  do
187	  {
188	    /* slow down execution */
189	    HAL_Delay(100);
190
191	    /* Increment test number for next execution */
192	    test_idx = HAL_RTCEx_BKUPRead(&RtcHandle, RTC_BKP_DR1);
193	    HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, (test_idx + 1));
194	    offset = aProtectTests[test_idx].type == TEST_READ_FLASH_BANK­2 ? (FLASH_BANK_SIZE) : 0;
195	    printf("\r\n= [TEST] %s @ %s %08x", aTestOperation[aProtectTests[test_idx].type], aProtectTests[test_idx].msg,
196	           aProtectTests[test_idx].address + offset);
197
198	    /* Remove test for slots not configured (taking into accounbt SFU_IMG_IMAGE_OFFSET­) */
199	    if ((aProtectTests[test_idx].address != 0U) && (aProtectTests[test_idx].address < 0xFFFFFF00U)
200	        && (aProtectTests[test_idx].address > 0x00000FFFU))
201	    {
202	      switch (aProtectTests[test_idx].type)
203	      {
204	        /* Trying to write 64bits in FLASH : WRP flag is set for WRP or PCROP protected area
205	           or reset generated if under FWALL or MPU protection */
206	        case TEST_WRITE_FLASH :
207	          HAL_FLASH_Unlock();
208	          HAL_FLASH_Program(FLASH_TYPEPROGRAM_DO­UBLEWORD, aProtectTests[test_idx].address, pattern);
209	          HAL_FLASH_Lock();
210	          flashErrCode = HAL_FLASH_GetError();
211	          printf("\r\nflash error code: %x", flashErrCode);
212	          if ((flashErrCode & HAL_FLASH_ERROR_WRP) == 0U)
213	          {
214	            status = TEST_ERROR;
215	          }
216
217	          /*
218	           * OBs protection test: MPU generates a MEMORY FAULT and a RESET
219	           * So the test is FAILED if we reach this line
220	           */
221	          if (0 == strncmp("OBs @", (const char *)aProtectTests[test_idx].msg, 5))
222	          {
223	            status = TEST_ERROR;
224	          }
225	          /* else not an OB protection test so probably not an error */
226	          break;
227
228	          /* Trying to read in FLASH : RDP set in case of PCROP protected area
229	             or reset generated if under FWALL or MPU protection */
230	        case TEST_READ_FLASH_BANK­2:
231	        case TEST_READ_FLASH :
232	          tmp = *(uint8_t *)(aProtectTests[test_idx].address + offset);
233	          HAL_Delay(1);                                                 /* ensure Flag is set */
234	          if (__HAL_FLASH_GET_FLAG­(FLASH_FLAG_RDERR) == 0)
235	          {
236	            printf(" value : %d", tmp);
237	            status = TEST_ERROR;
238	          }
239	          __HAL_FLASH_CLEAR_FL­AG(FLASH_FLAG_RDERR);
240	          /*
241	           * When Isolation activated : RESET should be generated
242	           * So the test is FAILED if we reach this line
243	           */
244	          if (0 == strncmp("Isolated", (const char *)aProtectTests[test_idx].msg, 8))
245	          {
246	            status = TEST_ERROR;
247	          }
248
249	          break;
250
251	        /* Trying to erase 512 bytes in FLASH : WRP flag set for WRP or PCROP protected area
252	           or reset generated if under FWALL or MPU protection */
253	        case TEST_ERASE_FLASH :
254	          HAL_FLASH_Unlock();
255	          p_erase_init.Banks       = SFU_LL_FLASH_INT_Get­Bank(aProtectTests[test_idx].address);
256	          p_erase_init.TypeErase   = FLASH_TYPEERASE_PAGE­S;
257	          p_erase_init.Page        = SFU_LL_FLASH_GetPage­(aProtectTests[test_idx].address);
258	          p_erase_init.NbPages     = 1;
259	          HAL_FLASHEx_Erase(&p_erase_init, &page_error);
260	          HAL_FLASH_Lock();
261	          if ((HAL_FLASH_GetError() & HAL_FLASH_ERROR_WRP) == 0U)
262	          {
263	            status = TEST_ERROR;
264	          }
265	          break;
266
267	        /* Trying to write in RAM : reset generated if under FWALL or MPU protection */
268	        case TEST_WRITE_RAM :
269	          *(uint32_t *)aProtectTests[test_idx].address = 0x00000000;
270	          status = TEST_ERROR;
271	          break;
272
273	        /* Trying to read in RAM : reset generated if under FWALL or MPU protection */
274	        case TEST_READ_RAM :
275	          tmp = *(uint8_t *)aProtectTests[test_idx].address;
276	          printf(" value : %d ", tmp);
277	          status = TEST_ERROR;
278	          break;
279
280	          /* Tryning to execute code : reset generated if under FWALL or MPU protection */
281	        case TEST_EXECUTE_BANK2:
282	        case TEST_EXECUTE :
283	          func = (void(*)(void))(aProtectTests[test_idx].address + offset);
284	          func();
285	          status = TEST_ERROR;
286	          break;
287
288	        /* End of execution */
289	        case TEST_END :
290	          status = TEST_COMPLETED;
291	          break;
292
293	        default :
294	          break;
295	      }
296	    }
297	  } while (status == TEST_IN_PROGRESS) ;
298
299	  if (status == TEST_ERROR)
300	  {
301	    SFU_TEST_Error();
302	  }
303	  else if (status == TEST_COMPLETED)
304	  {
305	    /* reset for next run (need a RESET of the platform to restart a session) */
306	    printf("\b\b\b\b\b\b\b\b");
307	    printf("\r\nYou can RESET the platform to restart the tests.\r\n");
308	    HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR0, MAGIC_TEST_DONE);              /* no more test in progress */
309	  }
310	}
311
312	/**
313	  * @brief  Initialization of backup register and start test
314	  * @param  None.
315	  * @retval None.
316	  */
317	void SFU_TEST_Init(void)
318	{
319	  /* Use register DR0 to know which if the test sequence is in progress or done */
320	  /* Use register DR1 to know which test to run after a reset */
321
322	  if (MAGIC_TEST_DONE == HAL_RTCEx_BKUPRead(&RtcHandle, RTC_BKP_DR0))      /* Test done */
323	  {
324	    return;
325	  }
326	  else if (MAGIC_TEST_INIT != HAL_RTCEx_BKUPRead(&RtcHandle,
327	                                                 RTC_BKP_DR0)) /* Test not done nor in progress: Init magic (DR0) and
328	                                                                  reset test index (DR1) */
329	  {
330	    HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR0, MAGIC_TEST_INIT);
331	    HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, 0x0000);
332	  }
333
334	  /* Start test */
335	  SFU_TEST_Protection();
336	}
337
338	/**
339	  * @brief  Reset backup register to be able to execute a new test sequence
340	  * @param  None.
341	  * @retval None.
342	  */
343	void SFU_TEST_Reset(void)
344	{
345	  HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR0, MAGIC_TEST_INIT);
346	  HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, 0x0000);
347	}
348
349	/**
350	  * @brief  Error detected during test sequence
351	  * @param  None.
352	  * @retval None.
353	  */
354	void SFU_TEST_Error(void)
355	{
356	  printf(" ===> KO!!!!!");
357	  HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR0, MAGIC_TEST_DONE);
358	}
359
360	#endif /* SFU_TEST_PROTECTION */
361
L476_SBSFU\BFU\Application\BFU\App\sfu_test.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_test.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for Test Protections functionalities.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef SFU_TEST_H
21	#define SFU_TEST_H
22
23	#ifdef __cplusplus
24	extern "C" {
25	#endif
26
27	/* Includes ------------------------------------------------------------------*/
28	#include "stdint.h"
29	#include "app_sfu.h"
30
31	#if defined(SFU_TEST_PROTECTION)
32
33	/* Exported types ------------------------------------------------------------*/
34	typedef enum
35	{
36	  TEST_WRITE_FLASH = 0U,                /* Writing test in FLASH */
37	  TEST_READ_FLASH,                      /* Reading test in FLASH */
38	  TEST_READ_FLASH_BANK­2,                /* Reading test in BANK2 */
39	  TEST_ERASE_FLASH,                     /* Erasing test in FLASH */
40	  TEST_WRITE_RAM,                       /* Writing test in RAM */
41	  TEST_READ_RAM,                        /* Reading test in RAM */
42	  TEST_EXECUTE,                         /* Execution function test */
43	  TEST_EXECUTE_BANK2,                   /* execution function test from BANK2 */
44	  TEST_END,                             /* Last test : Success ! */
45	} TestType;
46
47	typedef enum
48	{
49	  TEST_IN_PROGRESS = 0U,                /* Test in progress */
50	  TEST_COMPLETED,                       /* Test ended : success */
51	  TEST_ERROR,                           /* Test aborted : error */
52	} TestStatus;
53
54
55	#define PROTECT_MSG_LEN (35U)           /* message to be displayed length           */
56	typedef struct
57	{
58	  uint32_t address;                     /* address to be tested */
59	  uint8_t msg[PROTECT_MSG_LEN];         /* message to be displayed when testing */
60	  TestType type;                        /* type of test */
61	} ProtectionTest_t;
62
63	/* Exported constants --------------------------------------------------------*/
64	/* Magic number saved in DR0 backup register */
65	#define MAGIC_TEST_DONE          0xAAA2
66	#define MAGIC_TEST_INIT          0xAAA3
67
68	/* Exported functions ------------------------------------------------------- */
69	void SFU_TEST_Init(void);
70	void SFU_TEST_Reset(void);
71	void SFU_TEST_Error(void);
72
73	#endif /* SFU_TEST_PROTECTION */
74
75	#ifdef __cplusplus
76	}
77	#endif
78
79	#endif /* SFU_TEST_H */
80
81
L476_SBSFU\BFU\Application\BFU\App\sfu_trace.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_trace.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for SFU_TRACE functionalities.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef SFU_TRACE_H
21	#define SFU_TRACE_H
22
23	#ifdef __cplusplus
24	extern "C" {
25	#endif
26
27	/* Includes ------------------------------------------------------------------*/
28	#include "app_sfu.h"
29	#if defined(SFU_DEBUG_MODE) || defined(SFU_TEST_PROTECTION)
30	#include "sfu_com_trace.h"
31	#endif /* defined(SFU_DEBUG_MODE) || defined(SFU_TEST_PROTECTION) */
32
33	/* External variables --------------------------------------------------------*/
34	/**
35	  * This variable indicates if at boot-up the FW presence check has already been performed or not:
36	  * \li It is reset when the FW status has already been checked once and no FW is present
37	  * \li (see @ref SFU_BOOT_SM_CheckUse­rFwStatus)
38	  * \li It is used to display some messages only once in the teraterm console
39	  * \li It is used to determine if the user button must be pressed before waiting for a local download to start
40	  * \li This is used at LocalDownload and CheckUserFwStatus stages.
41	  */
42	extern uint32_t initialDeviceStatusC­heck; /* used also in sfu_fwimg_swap.c */
43
44	/* Exported macros -----------------------------------------------------------*/
45	#ifdef SFU_DEBUG_MODE
46	#define TRACE_IRQ(pbuffer) (void) SFU_COM_Serial_PutSt­ring(pbuffer); /* Printf is not used inside interrupt to avoid
47	                                                                        faults. printf is not rieentrant */
48	#define TRACE   (void) printf
49	#else
50	#define TRACE(...)
51	#define TRACE_IRQ(pbuffer)
52	#endif /* SFU_DEBUG_MODE */
53
54
55	/**
56	  * @}
57	  */
58
59	/**
60	  * @}
61	  */
62
63	/**
64	  * @}
65	  */
66
67	/**
68	  * @}
69	  */
70
71
72	#ifdef __cplusplus
73	}
74	#endif
75
76	#endif /* SFU_TRACE_H */
77
78
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level_flash_ext.c
1	/**
2	  ******************************************************************************
3	  * @file    sfu_low_level_flash_­ext.c
4	  * @author  MCD Application Team
5	  * @brief   SFU Flash Low Level Interface module
6	  *          This file provides set of firmware functions to manage SFU external
7	  *          flash low level interface.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Includes ------------------------------------------------------------------*/
22	#include "main.h"
23	#include "sfu_low_level_flash_­ext.h"
24	#include "sfu_low_level_securi­ty.h"
25
26	/* Private defines -----------------------------------------------------------*/
27
28	/* Functions Definition ------------------------------------------------------*/
29
30	/* No external flash available on this product
31	   ==> return SFU_ERROR except for SFU_LL_FLASH_EXT_Ini­t and SFU_LL_FLASH_EXT_Con­fig_Exe which are called
32	       systematically during startup phase */
33
34	SFU_ErrorStatus SFU_LL_FLASH_EXT_Ini­t(void)
35	{
36	  return SFU_SUCCESS;
37	}
38
39	SFU_ErrorStatus SFU_LL_FLASH_EXT_Era­se_Size(SFU_FLASH_StatusType­Def *pFlashStatus, uint8_t *pStart, uint32_t Length)
40	{
41	  UNUSED(pFlashStatus);
42	  UNUSED(pStart);
43	  UNUSED(Length);
44	  return SFU_ERROR;
45	}
46
47	SFU_ErrorStatus SFU_LL_FLASH_EXT_Wri­te(SFU_FLASH_StatusType­Def *pFlashStatus, uint8_t  *pDestination,
48	                                       const uint8_t *pSource, uint32_t Length)
49	{
50	  UNUSED(pFlashStatus);
51	  UNUSED(pDestination);
52	  UNUSED(pSource);
53	  UNUSED(Length);
54	  return SFU_ERROR;
55	}
56
57	SFU_ErrorStatus SFU_LL_FLASH_EXT_Rea­d(uint8_t *pDestination, const uint8_t *pSource, uint32_t Length)
58	{
59	  UNUSED(pDestination);
60	  UNUSED(pSource);
61	  UNUSED(Length);
62	  return SFU_ERROR;
63	}
64
65	SFU_ErrorStatus SFU_LL_FLASH_EXT_Com­pare(const uint8_t *pFlash, const uint32_t Pattern1, const uint32_t Pattern2, uint32_t Length)
66	{
67	  UNUSED(pFlash);
68	  UNUSED(Pattern1);
69	  UNUSED(Pattern2);
70	  UNUSED(Length);
71	  return SFU_ERROR;
72	}
73	SFU_ErrorStatus SFU_LL_FLASH_EXT_Con­fig_Exe(uint32_t SlotNumber)
74	{
75	  UNUSED(SlotNumber);
76	  return SFU_SUCCESS;
77	}
78
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level_flash_ext.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_low_level_flash_­ext.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for Secure Firmware Update low level
6	  *          interface for external flash.
7	  ******************************************************************************
8	  * @attention
9	  *
10	  * Copyright (c) 2017 STMicroelectronics.
11	  * All rights reserved.
12	  *
13	  * This software is licensed under terms that can be found in the LICENSE file in
14	  * the root directory of this software component.
15	  * If no LICENSE file comes with this software, it is provided AS-IS.
16	  *
17	  ******************************************************************************
18	  */
19
20	/* Define to prevent recursive inclusion -------------------------------------*/
21	#ifndef SFU_LOW_LEVEL_FLASH_­EXT_H
22	#define SFU_LOW_LEVEL_FLASH_­EXT_H
23
24	#ifdef __cplusplus
25	extern "C" {
26	#endif
27
28	/* Includes ------------------------------------------------------------------*/
29	#include "sfu_low_level_flash.h"
30	#include "main.h"
31	#include "sfu_def.h"
32
33	/* Exported constants --------------------------------------------------------*/
34	#define EXTERNAL_FLASH_ADDRE­SS  0x90000000U
35
36	/* Exported functions ------------------------------------------------------- */
37	SFU_ErrorStatus SFU_LL_FLASH_EXT_Ini­t(void);
38	SFU_ErrorStatus SFU_LL_FLASH_EXT_Era­se_Size(SFU_FLASH_StatusType­Def *pxFlashStatus, uint8_t *pStart, uint32_t Length);
39	SFU_ErrorStatus SFU_LL_FLASH_EXT_Wri­te(SFU_FLASH_StatusType­Def *pxFlashStatus, uint8_t *pDestination,
40	                                       const uint8_t *pSource, uint32_t Length);
41	SFU_ErrorStatus SFU_LL_FLASH_EXT_Rea­d(uint8_t *pDestination, const uint8_t *pSource, uint32_t Length);
42	SFU_ErrorStatus SFU_LL_FLASH_EXT_Com­pare(const uint8_t *pFlash, const uint32_t Pattern1, const uint32_t Pattern2, uint32_t Length);
43	SFU_ErrorStatus SFU_LL_FLASH_EXT_Con­fig_Exe(uint32_t SlotNumber);
44
45	#ifdef __cplusplus
46	}
47	#endif
48
49	#endif /* SFU_LOW_LEVEL_FLASH_­EXT_H */
50
51
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level_flash_int.c
1	/**
2	  ******************************************************************************
3	  * @file    sfu_low_level_flash_­int.c
4	  * @author  MCD Application Team
5	  * @brief   SFU Flash Low Level Interface module
6	  *          This file provides set of firmware functions to manage SFU internal
7	  *          flash low level interface.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Includes ------------------------------------------------------------------*/
22	#include "main.h"
23	#include "sfu_low_level_flash_­int.h"
24	#include "sfu_low_level_securi­ty.h"
25	#include "se_interface_bootloa­der.h"
26	#include "string.h"
27	#include "sfu_fsm_states.h"
28	#include "sfu_error.h"
29
30	/* Private defines -----------------------------------------------------------*/
31	#define NB_PAGE_SECTOR_PER_E­RASE  2U    /*!< Nb page erased per erase */
32
33	/* Private variables ---------------------------------------------------------*/
34	static __IO uint32_t DoubleECC_Error_Coun­ter = 0U;
35
36
37	static uint32_t SFU_LL_FLASH_INT_Get­BankAddr(uint32_t bank);
38	static SFU_ErrorStatus SFU_LL_FLASH_INT_Cle­ar_Error(void);
39
40	/* Functions Definition ------------------------------------------------------*/
41	/**
42	  * @brief  This function initialize the internal flash interface if required
43	  * @param  none
44	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
45	  */
46	SFU_ErrorStatus SFU_LL_FLASH_INT_Ini­t(void)
47	{
48	  return SFU_SUCCESS;
49	}
50
51	/**
52	  * @brief  This function does an erase of n (depends on Length) pages in user flash area
53	  * @param  pFlashStatus: SFU_FLASH Status pointer
54	  * @param  pStart: flash address to be erased
55	  * @param  Length: number of bytes
56	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
57	  */
58	SFU_ErrorStatus SFU_LL_FLASH_INT_Era­se_Size(SFU_FLASH_StatusType­Def *pFlashStatus, uint8_t *pStart, uint32_t Length)
59	{
60	  uint32_t page_error = 0U;
61	  uint32_t start = (uint32_t)pStart;
62	  FLASH_EraseInitTypeD­ef p_erase_init;
63	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
64	  uint32_t first_page;
65	  uint32_t nb_pages;
66	  uint32_t chunk_nb_pages;
67	  uint32_t length = Length;
68	  uint32_t erase_command = 0U;
69	  uint32_t bank_number;
70
71	  /* Check the pointers allocation */
72	  if (pFlashStatus == NULL)
73	  {
74	    return SFU_ERROR;
75	  }
76
77	  *pFlashStatus = SFU_FLASH_SUCCESS;
78
79	  /* Clear error flags raised during previous operation */
80	  e_ret_status = SFU_LL_FLASH_INT_Cle­ar_Error();
81
82	  if (e_ret_status == SFU_SUCCESS)
83	  {
84	    /* Unlock the Flash to enable the flash control register access *************/
85	    if (HAL_FLASH_Unlock() == HAL_OK)
86	    {
87	      /* Get the 1st page to erase */
88	      do
89	      {
90	        first_page = SFU_LL_FLASH_INT_Get­Page(start);
91	        bank_number = SFU_LL_FLASH_INT_Get­Bank(start);
92	        if (SFU_LL_FLASH_INT_Get­Bank(start + length - 1U) == bank_number)
93	        {
94	          /* Get the number of pages to erase from 1st page */
95	          nb_pages = SFU_LL_FLASH_INT_Get­Page(start + length - 1U) - first_page + 1U;
96	          /* Get the bank */
97
98	          /* Fill EraseInit structure*/
99	          p_erase_init.TypeErase   = FLASH_TYPEERASE_PAGE­S;
100	          p_erase_init.Banks       = bank_number;
101
102	          /* Erase flash per NB_PAGE_SECTOR_PER_E­RASE to avoid watch-dog */
103	          do
104	          {
105	            chunk_nb_pages = (nb_pages >= NB_PAGE_SECTOR_PER_E­RASE) ? NB_PAGE_SECTOR_PER_E­RASE : nb_pages;
106	            p_erase_init.Page = first_page;
107	            p_erase_init.NbPages = chunk_nb_pages;
108	            first_page += chunk_nb_pages;
109	            nb_pages -= chunk_nb_pages;
110	            if (HAL_FLASHEx_Erase(&p_erase_init, &page_error) != HAL_OK)
111	            {
112	              e_ret_status = SFU_ERROR;
113	              *pFlashStatus = SFU_FLASH_ERR_ERASE;
114	            }
115	            SFU_LL_SECU_IWDG_Ref­resh(); /* calling this function which checks the compiler switch */
116	          } while (nb_pages > 0U);
117	          erase_command = 1U;
118	        }
119	        else
120	        {
121	          uint32_t startbank2 = SFU_LL_FLASH_INT_Get­BankAddr(FLASH_BANK_2);
122	          nb_pages = SFU_LL_FLASH_INT_Get­Page(startbank2 - 1U) - first_page + 1U;
123	          p_erase_init.TypeErase   = FLASH_TYPEERASE_PAGE­S;
124	          p_erase_init.Banks       = bank_number;
125	          length = length  - (startbank2 - start);
126	          start = startbank2;
127
128	          /* Erase flash per NB_PAGE_SECTOR_PER_E­RASE to avoid watch-dog */
129	          do
130	          {
131	            chunk_nb_pages = (nb_pages >= NB_PAGE_SECTOR_PER_E­RASE) ? NB_PAGE_SECTOR_PER_E­RASE : nb_pages;
132	            p_erase_init.Page = first_page;
133	            p_erase_init.NbPages = chunk_nb_pages;
134	            first_page += chunk_nb_pages;
135	            nb_pages -= chunk_nb_pages;
136	            if (HAL_FLASHEx_Erase(&p_erase_init, &page_error) != HAL_OK)
137	            {
138	              e_ret_status = SFU_ERROR;
139	              *pFlashStatus = SFU_FLASH_ERR_ERASE;
140	            }
141	            SFU_LL_SECU_IWDG_Ref­resh(); /* calling this function which checks the compiler switch */
142	          } while (nb_pages > 0U);
143	        }
144	      } while (erase_command == 0U);
145	      /* Lock the Flash to disable the flash control register access (recommended
146	      to protect the FLASH memory against possible unwanted operation) *********/
147	      if (HAL_FLASH_Lock() != HAL_OK)
148	      {
149	        e_ret_status = SFU_ERROR;
150	        *pFlashStatus = SFU_FLASH_ERR_HAL;
151	      }
152	    }
153	    else
154	    {
155	      *pFlashStatus = SFU_FLASH_ERR_HAL;
156	    }
157	  }
158
159	  return e_ret_status;
160	}
161
162	/**
163	  * @brief  This function writes a data buffer in flash (data are 32-bit aligned).
164	  * @note   After writing data buffer, the flash content is checked.
165	  * @param  pFlashStatus: FLASH_StatusTypeDef
166	  * @param  pDestination: Start address for target location. It has to be 8 bytes aligned.
167	  * @param  pSource: pointer on buffer with data to write
168	  * @param  Length: Length of data buffer in bytes. It has to be 8 bytes aligned.
169	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
170	  */
171	SFU_ErrorStatus SFU_LL_FLASH_INT_Wri­te(SFU_FLASH_StatusType­Def *pFlashStatus, uint8_t  *pDestination,
172	                                       const uint8_t *pSource, uint32_t Length)
173	{
174	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
175	  uint32_t i;
176	  uint32_t inside_header = 0U;
177	  uint32_t destination = (uint32_t)pDestination;
178	  uint32_t source = (uint32_t)pSource;
179
180	  /* Check the pointers allocation */
181	  if ((pFlashStatus == NULL) || (pSource == NULL))
182	  {
183	    return SFU_ERROR;
184	  }
185
186	  /* Is destination area inside 1 of the firmware image headers ? */
187	  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IM­AGE; i++)
188	  {
189	    if ((destination >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
190	        ((destination + Length) <= (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET­)))
191	    {
192	      inside_header = 1U;
193	    }
194	  }
195
196	  /* Destination area part of 1 of the firmware image headers :
197	     writing operation should be executed inside secure environment */
198	  if ((inside_header == 1U) && (Length != 0U))
199	  {
200	    /* SE Access */
201	    SE_StatusTypeDef se_status;
202	    SE_ErrorStatus se_ret_status = SE_SFU_IMG_Write(&se_status, (uint8_t *)destination, pSource, Length);
203	    if (se_ret_status == SE_SUCCESS)
204	    {
205	      e_ret_status = SFU_SUCCESS;
206	      *pFlashStatus = SFU_FLASH_SUCCESS;
207	    }
208	    else
209	    {
210	      e_ret_status = SFU_ERROR;
211	      *pFlashStatus = SFU_FLASH_ERROR;
212	    }
213	  }
214	  /* Writing operation executed by SBSFU */
215	  else
216	  {
217	    *pFlashStatus = SFU_FLASH_ERROR;
218
219	    /* Clear error flags raised during previous operation */
220	    e_ret_status = SFU_LL_FLASH_INT_Cle­ar_Error();
221
222	    if (e_ret_status == SFU_SUCCESS)
223	    {
224	      /* Unlock the Flash to enable the flash control register access *************/
225	      if (HAL_FLASH_Unlock() != HAL_OK)
226	      {
227	        *pFlashStatus = SFU_FLASH_ERR_HAL;
228
229	      }
230	      else
231	      {
232	        /* DataLength must be a multiple of 64 bit */
233	        for (i = 0U; (i < Length) && (e_ret_status == SFU_SUCCESS);  i += sizeof(SFU_LL_FLASH_write_t­))
234	        {
235	          *pFlashStatus = SFU_FLASH_ERROR;
236
237	          /* Device voltage range supposed to be [2.7V to 3.6V], the operation will
238	          be done by word */
239	          if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DO­UBLEWORD, destination, *((uint64_t *)(source + i)))
240	              == HAL_OK)
241	          {
242	            /* Check the written value */
243	            if (*(uint64_t *)destination != *(uint64_t *)(source + i))
244	            {
245	              /* Flash content doesn't match SRAM content */
246	              *pFlashStatus = SFU_FLASH_ERR_WRITIN­GCTRL;
247	              e_ret_status = SFU_ERROR;
248	            }
249	            else
250	            {
251	              /* Increment FLASH Destination address */
252	              destination = destination + sizeof(SFU_LL_FLASH_write_t­);
253	              e_ret_status = SFU_SUCCESS;
254	              *pFlashStatus = SFU_FLASH_SUCCESS;
255	            }
256	          }
257	          else
258	          {
259	            /* Error occurred while writing data in Flash memory */
260	            *pFlashStatus = SFU_FLASH_ERR_WRITIN­G;
261	            e_ret_status = SFU_ERROR;
262	          }
263	        }
264	        /* Lock the Flash to disable the flash control register access (recommended
265	        to protect the FLASH memory against possible unwanted operation) */
266	        if (HAL_FLASH_Lock() != HAL_OK)
267	        {
268	          e_ret_status = SFU_ERROR;
269	          *pFlashStatus = SFU_FLASH_ERR_HAL;
270	        }
271	      }
272	    }
273	  }
274	  return e_ret_status;
275	}
276
277	/**
278	  * @brief  This function reads flash
279	  * @param  pDestination: Start address for target location
280	  * @param  pSource: flash address to read
281	  * @param  Length: number of bytes
282	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
283	  */
284	SFU_ErrorStatus SFU_LL_FLASH_INT_Rea­d(uint8_t *pDestination, const uint8_t *pSource, uint32_t Length)
285	{
286	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
287	  SE_ErrorStatus se_ret_status;
288	  SE_StatusTypeDef se_status;
289	  uint32_t i;
290	  uint32_t inside_header = 0U;
291	  uint32_t source = (uint32_t)pSource;
292
293	  /* Is destination area inside 1 of the firmware image headers ? */
294	  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IM­AGE; i++)
295	  {
296	    if ((source >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
297	        ((source + Length) <= (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET­)))
298	    {
299	      inside_header = 1U;
300	    }
301	  }
302
303	  /* Destination area part of 1 of the firmware image headers :
304	     reading operation should be executed inside secure environment */
305	  if (inside_header == 1U)
306	  {
307	    /* SE Access */
308	    DoubleECC_Error_Coun­ter = 0U;
309	    se_ret_status = SE_SFU_IMG_Read(&se_status, pDestination, (uint8_t *)source, Length);
310	    if ((se_ret_status == SE_SUCCESS) && (DoubleECC_Error_Coun­ter == 0U))
311	    {
312	      e_ret_status = SFU_SUCCESS;
313	    }
314	    DoubleECC_Error_Coun­ter = 0U;
315	  }
316	  /* Reading operation executed by SBSFU */
317	  else
318	  {
319	    DoubleECC_Error_Coun­ter = 0U;
320	    /* Do not use memcpy from lib : ECC error should be checked at each loop */
321	    for (i = 0; (i < Length) && (DoubleECC_Error_Coun­ter == 0U); i++, pDestination++, pSource++)
322	    {
323	      *pDestination = *pSource;
324	    }
325	    if (DoubleECC_Error_Coun­ter == 0U)
326	    {
327	      e_ret_status = SFU_SUCCESS;
328	    }
329	    DoubleECC_Error_Coun­ter = 0U;
330	  }
331	  return e_ret_status;
332	}
333
334	/**
335	  * @brief  This function compare a buffer with a flash area
336	  * @note   The flash area should not be located inside the secure area
337	  * @param  pFlash: address of the flash area
338	  * @param  Pattern1: first 32 bits pattern to be compared
339	  * @param  Pattern2: second 32 bits pattern to be compared
340	  * @param  Length: number of bytes to be compared
341	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
342	  */
343	SFU_ErrorStatus SFU_LL_FLASH_INT_Com­pare(const uint8_t *pFlash, const uint32_t Pattern1, const uint32_t Pattern2, uint32_t Length)
344	{
345	  uint32_t flash = (uint32_t) pFlash;
346	  uint32_t i;
347
348	  /* Comparison executed by SBSFU ==> flash area could not be located inside secured environment */
349	  DoubleECC_Error_Coun­ter = 0U;
350	  for ( i = 0U; i < Length; i += 4U)
351	  {
352	    if ((*(uint32_t *)(flash + i) != Pattern1) &&  (*(uint32_t *)(flash + i) != Pattern2))
353	    {
354	      return SFU_ERROR;
355	    }
356	  }
357	  /* Verify loop exit status */
358	  if (i != Length)
359	  {
360	    return SFU_ERROR;
361	  }
362	  if (DoubleECC_Error_Coun­ter != 0U)
363	  {
364	    return SFU_ERROR;
365	  }
366	  DoubleECC_Error_Coun­ter = 0U;
367	  return SFU_SUCCESS;
368	}
369
370	/**
371	  * @brief  Gets the page of a given address
372	  * @param  Addr: flash address
373	  * @retval The page of a given address
374	  */
375	uint32_t SFU_LL_FLASH_INT_Get­Page(uint32_t Addr)
376	{
377	  uint32_t page;
378
379	  if (Addr < (FLASH_BASE + (FLASH_BANK_SIZE)))
380	  {
381	    /* Bank 1 */
382	    page = (Addr - FLASH_BASE) / FLASH_PAGE_SIZE;
383	  }
384	  else
385	  {
386	    /* Bank 2 */
387	    page = (Addr - (FLASH_BASE + (FLASH_BANK_SIZE))) / FLASH_PAGE_SIZE;
388	  }
389
390	  return page;
391	}
392
393
394	/**
395	  * @brief  Gets the bank of a given address
396	  * @param  Addr: flash address
397	  * @retval The bank of a given address
398	  */
399	uint32_t SFU_LL_FLASH_INT_Get­Bank(uint32_t Addr)
400	{
401	  uint32_t bank;
402	  if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MOD­E) == 0U)
403	  {
404	    /* No Bank swap */
405	    if (Addr < (FLASH_BASE + (FLASH_BANK_SIZE)))
406	    {
407	      bank = FLASH_BANK_1;
408	    }
409	    else
410	    {
411	      bank = FLASH_BANK_2;
412	    }
413	  }
414	  else
415	  {
416	    /* Bank swap */
417	    if (Addr < (FLASH_BASE + (FLASH_BANK_SIZE)))
418	    {
419	      bank = FLASH_BANK_2;
420	    }
421	    else
422	    {
423	      bank = FLASH_BANK_1;
424	    }
425	  }
426
427	  return bank;
428	}
429
430
431	/**
432	  * @brief  Clear error flags raised during previous operation
433	  * @param  None.
434	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
435	  */
436	static SFU_ErrorStatus SFU_LL_FLASH_INT_Cle­ar_Error(void)
437	{
438	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
439
440	  /* Unlock the Program memory */
441	  if (HAL_FLASH_Unlock() == HAL_OK)
442	  {
443
444	    /* Clear all FLASH flags */
445	    __HAL_FLASH_CLEAR_FL­AG(FLASH_FLAG_ALL_ERROR­S);
446
447
448	    /* Unlock the Program memory */
449	    if (HAL_FLASH_Lock() == HAL_OK)
450	    {
451	      e_ret_status = SFU_SUCCESS;
452	    }
453	  }
454
455	  return e_ret_status;
456
457	}
458
459	/**
460	  * @brief  Gets the address of a bank
461	  * @param  Bank: Bank ID
462	  * @retval Address of the bank
463	  */
464	static uint32_t SFU_LL_FLASH_INT_Get­BankAddr(uint32_t Bank)
465	{
466	  if (Bank == FLASH_BANK_2)
467	  {
468	    return  FLASH_BASE + (FLASH_BANK_SIZE);
469	  }
470	  else
471	  {
472	    return FLASH_BASE;
473	  }
474	}
475
476	/**
477	  * @brief  Get Link Register value (LR)
478	  * @param  None.
479	  * @retval LR Register value
480	  */
481	__attribute__((always_inline)) __STATIC_INLINE uint32_t get_LR(void)
482	{
483	  register uint32_t result;
484
485	#if defined ( __ICCARM__ ) || defined ( __GNUC__ ) || defined ( __ARMCC_VERSION )
486	  __ASM volatile("MOV %0, LR" : "=r"(result));
487	#elif defined ( __CC_ARM )
488	  __ASM volatile("MOV result, __return_address()");
489	#endif /* ( __ICCARM__ ) || ( __GNUC__ ) */
490
491	  return result;
492	}
493
494	/*
495	   As this handler code relies on stack pointer position to manipulate the PC return value, it is important
496	   not to use extra registers (on top of scratch registers), because it would change the stack pointer
497	   position. Then compiler optimizations are customized to ensure that.
498	*/
499	#if defined(__ICCARM__)
500	#pragma optimize=none
501	#elif defined(__CC_ARM)
502	#pragma O0
503	#elif defined (__ARMCC_VERSION)
504	__attribute__((optnone))
505	#elif defined ( __GNUC__ )
506	__attribute__((optimize("O1")))
507	#endif /* __ICCARM__ */
508	/**
509	  * @brief  NMI Handler present for handling Double ECC NMI interrupt
510	  * @param  None.
511	  * @retvat void
512	  */
513	void NMI_Handler(void)
514	{
515	  uint32_t *p_sp;
516	  uint32_t lr;
517	  uint16_t opcode_msb;
518
519	#ifdef FLASH_ECCR_ECCD2
520	  if ((__HAL_FLASH_GET_FLAG­(FLASH_ECCR_ECCD)) || (__HAL_FLASH_GET_FLAG­(FLASH_ECCR_ECCD2)))
521	#else /* FLASH_ECCR_ECCD2 */
522	  if (__HAL_FLASH_GET_FLAG­(FLASH_ECCR_ECCD))
523	#endif /* FLASH_ECCR_ECCD2 */
524	  {
525	    __HAL_FLASH_CLEAR_FL­AG(FLASH_ECCR_ECCD);
526	#ifdef FLASH_ECCR_ECCD2
527	    __HAL_FLASH_CLEAR_FL­AG(FLASH_ECCR_ECCD2);
528	#endif /* FLASH_ECCR_ECCD2 */
529
530	    /* Memorize error to ignore the read value */
531	    DoubleECC_Error_Coun­ter++;
532
533	    lr = get_LR();
534
535	    /* Check EXC_RETURN value in LR to know which SP was used prior entering exception */
536	    if (((lr) & (0xFU)) == 0xDU)
537	    {
538	      /* interrupted code was using Process Stack Pointer */
539	      p_sp = (uint32_t *)__get_PSP();
540	    }
541	    else
542	    {
543	      /* interrupted code was using Main Stack Pointer */
544	      p_sp = (uint32_t *)__get_MSP();
545	    }
546
547	    /* Test caller mode T bit from CPSR in stack */
548	    if ((*(p_sp + 7U) & (1U << xPSR_T_Pos)) != 0U)
549	    {
550	      /* Thumb  mode.
551	         Test PC in stack.
552	         If bits [15:11] of the halfword being decoded take any of the following values,
553	         the halfword is the first halfword of a 32-bit instruction: 0b11101, 0b11110, 0b11111.
554	         Otherwise, the halfword is a 16-bit instruction.
555	      */
556	      opcode_msb = (*(uint16_t *)(*(p_sp + 6) & 0xFFFFFFFEU) & 0xF800U);
557	      if ((opcode_msb == 0xE800U) || (opcode_msb == 0xF000U) || (opcode_msb == 0xF800U))
558	      {
559	        /* execute next instruction PC +4  */
560	        *(p_sp + 6U) += 4U;
561	      }
562	      else
563	      {
564	        /* execute next instruction PC +2  */
565	        *(p_sp + 6U) += 2U;
566	      }
567	    }
568	    else
569	    {
570	      /* ARM mode execute next instruction PC +4 */
571	      *(p_sp + 6U) += 4U;
572	    }
573	  }
574	  else
575	  {
576	    while (1 == 1)
577	    {
578	      ;
579	    }
580	  }
581	}
582
583
584	/**
585	  * @brief  HardFault Handler
586	  * @param  None.
587	  * @retval None.
588	  */
589	void HardFault_Handler(void)
590	{
591	  SFU_EXCPT_IrqExcepti­onHandler(SFU_EXCPT_HARD_FAULT­);
592	}
593
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level_flash_int.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_low_level_flash_­int.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for Secure Firmware Update low level
6	  *          interface for internal flash.
7	  ******************************************************************************
8	  * @attention
9	  *
10	  * Copyright (c) 2017 STMicroelectronics.
11	  * All rights reserved.
12	  *
13	  * This software is licensed under terms that can be found in the LICENSE file in
14	  * the root directory of this software component.
15	  * If no LICENSE file comes with this software, it is provided AS-IS.
16	  *
17	  ******************************************************************************
18	  */
19
20	/* Define to prevent recursive inclusion -------------------------------------*/
21	#ifndef SFU_LOW_LEVEL_FLASH_­INT_H
22	#define SFU_LOW_LEVEL_FLASH_­INT_H
23
24	#ifdef __cplusplus
25	extern "C" {
26	#endif
27
28	/* Includes ------------------------------------------------------------------*/
29	#include "sfu_low_level_flash.h"
30	#include "main.h"
31	#include "sfu_def.h"
32
33	/* Exported types ------------------------------------------------------------*/
34	/**
35	  * @brief Flash Write Access Constraints (size and alignment)
36	  *
37	  * For instance, on L4, it is only possible to program double word (2 x 32-bit data).
38	  * See http://www.st.com/content/ccc/resource/technical/document/reference_manual/02/35/09/0c/4f/f7/40/03/DM00083560.pdf/files/DM00083560.pdf/jcr:content/translations/en.DM00083560.pdf
39	  *
40	  * @note This type is very important for the FWIMG module (see @ref SFU_IMG).
41	  * \li This is the type to be used for an atomic write in FLASH: see @ref AtomicWrite.
42	  * \li The size of this type changes the size of the TRAILER area at the end of dwl slot,
43	  *     as it is used to tag if a Firmware Image chunk has been swapped or not (see @ref SFU_IMG_FirmwareToRe­sume).
44	  */
45
46	/* double-word is the default setting for most platforms */
47	typedef uint64_t SFU_LL_FLASH_write_t­;
48
49	/* Exported constants --------------------------------------------------------*/
50	/**
51	  * Length of a MAGIC tag (32 bytes).
52	  * This must be a multiple of @ref SFU_LL_FLASH_write_t­ with a minimum value of 32.
53	  */
54	#define MAGIC_LENGTH ((uint32_t)32U)
55
56	/* External variables --------------------------------------------------------*/
57	#define IS_ALIGNED(address) (0U == ((address) % FLASH_PAGE_SIZE))
58
59	/* Exported functions ------------------------------------------------------- */
60	SFU_ErrorStatus SFU_LL_FLASH_INT_Ini­t(void);
61	SFU_ErrorStatus SFU_LL_FLASH_INT_Era­se_Size(SFU_FLASH_StatusType­Def *pxFlashStatus, uint8_t *pStart, uint32_t Length);
62	SFU_ErrorStatus SFU_LL_FLASH_INT_Wri­te(SFU_FLASH_StatusType­Def *pxFlashStatus, uint8_t *pDestination,
63	                                       const uint8_t *pSource, uint32_t Length);
64	SFU_ErrorStatus SFU_LL_FLASH_INT_Rea­d(uint8_t *pDestination, const uint8_t *pSource, uint32_t Length);
65	SFU_ErrorStatus SFU_LL_FLASH_INT_Com­pare(const uint8_t *pFlash, const uint32_t Pattern1, const uint32_t Pattern2, uint32_t Length);
66	uint32_t SFU_LL_FLASH_INT_Get­Page(uint32_t Addr);
67	uint32_t SFU_LL_FLASH_INT_Get­Bank(uint32_t Addr);
68	void NMI_Handler(void);
69	void HardFault_Handler(void);
70
71	#ifdef __cplusplus
72	}
73	#endif
74
75	#endif /* SFU_LOW_LEVEL_FLASH_­INT_H */
76
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level_flash.c
1	/**
2	  ******************************************************************************
3	  * @file    sfu_low_level_flash.c
4	  * @author  MCD Application Team
5	  * @brief   SFU Flash Low Level Interface module
6	  *          This file provides set of firmware functions to manage SFU flash
7	  *          low level interface.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Includes ------------------------------------------------------------------*/
22	#include "sfu_low_level_flash_­int.h"
23	#include "sfu_low_level_flash_­ext.h"
24	#include "sfu_fwimg_regions.h"
25
26	/* Functions Definition ------------------------------------------------------*/
27	/**
28	  * @brief  Initialize internal and external flash interface (OSPI/QSPI)
29	  * @param  none
30	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
31	  */
32	SFU_ErrorStatus SFU_LL_FLASH_Init(void)
33	{
34	  SFU_ErrorStatus e_ret_status = SFU_SUCCESS;
35
36	  e_ret_status = SFU_LL_FLASH_INT_Ini­t();
37	  if (e_ret_status == SFU_SUCCESS)
38	  {
39	    e_ret_status = SFU_LL_FLASH_EXT_Ini­t();
40	  }
41	  return e_ret_status;
42	}
43
44	/**
45	  * @brief  Depending on start address, this function will call internal or external (OSPI/QSPI) flash driver
46	  * @param  pFlashStatus: SFU_FLASH Status pointer
47	  * @param  pStart: flash address to be erased
48	  * @param  Length: number of bytes
49	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
50	  */
51	SFU_ErrorStatus SFU_LL_FLASH_Erase_S­ize(SFU_FLASH_StatusType­Def *pFlashStatus, uint8_t *pStart, uint32_t Length)
52	{
53
54	  /* Check Flash start address */
55	  if ((uint32_t) pStart < EXTERNAL_FLASH_ADDRE­SS)
56	  {
57	    return SFU_LL_FLASH_INT_Era­se_Size(pFlashStatus, pStart, Length);
58	  }
59	  else
60	  {
61	    return SFU_LL_FLASH_EXT_Era­se_Size(pFlashStatus, pStart, Length);
62	  }
63	}
64
65	/**
66	  * @brief  Depending on destination address, this function will call internal or external (OSPI/QSPI) flash driver
67	  * @param  pFlashStatus: FLASH_StatusTypeDef
68	  * @param  pDestination: flash address to write
69	  * @param  pSource: pointer on buffer with data to write
70	  * @param  Length: number of bytes
71	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
72	  */
73	SFU_ErrorStatus SFU_LL_FLASH_Write(SFU_FLASH_StatusType­Def *pFlashStatus, uint8_t  *pDestination,
74	                                   const uint8_t *pSource, uint32_t Length)
75	{
76	  /* Check Flash destination address */
77	  if ((uint32_t) pDestination < EXTERNAL_FLASH_ADDRE­SS)
78	  {
79	    return SFU_LL_FLASH_INT_Wri­te(pFlashStatus, pDestination, pSource, Length);
80	  }
81	  else
82	  {
83	    return SFU_LL_FLASH_EXT_Wri­te(pFlashStatus, pDestination, pSource, Length);
84	  }
85	}
86
87	/**
88	  * @brief  Depending on source address, this function will call internal or external (OSPI/QSPI) flash driver
89	  * @param  pDestination: pointer on buffer to store data
90	  * @param  pSource: flash address to read
91	  * @param  Length: number of bytes
92	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
93	  */
94	SFU_ErrorStatus SFU_LL_FLASH_Read(uint8_t *pDestination, const uint8_t *pSource, uint32_t Length)
95	{
96	  /* Check Flash source address */
97	  if ((uint32_t) pSource < EXTERNAL_FLASH_ADDRE­SS)
98	  {
99	    return SFU_LL_FLASH_INT_Rea­d(pDestination, pSource, Length);
100	  }
101	  else
102	  {
103	    return SFU_LL_FLASH_EXT_Rea­d(pDestination, pSource, Length);
104	  }
105	}
106
107	/**
108	  * @brief  This function compare a buffer with a flash area
109	  * @note   The flash area should not be located inside the secure area
110	  * @param  pFlash: address of the flash area
111	  * @param  Pattern1: first 32 bits pattern to be compared
112	  * @param  Pattern2: second 32 bits pattern to be compared
113	  * @param  Length: number of bytes to be compared
114	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
115	  */
116	SFU_ErrorStatus SFU_LL_FLASH_Compare­(const uint8_t *pFlash, const uint32_t Pattern1, const uint32_t Pattern2, uint32_t Length)
117	{
118	  /* Check Flash source address */
119	  if ((uint32_t) pFlash < EXTERNAL_FLASH_ADDRE­SS)
120	  {
121	    return SFU_LL_FLASH_INT_Com­pare(pFlash, Pattern1, Pattern2, Length);
122	  }
123	  else
124	  {
125	    return SFU_LL_FLASH_EXT_Com­pare(pFlash, Pattern1, Pattern2, Length);
126	  }
127	}
128
129	/**
130	  * @brief  This function configure the flash to be able to execute code
131	  * @param  Addr: flash address
132	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
133	  */
134	SFU_ErrorStatus SFU_LL_FLASH_Config_­Exe(uint32_t SlotNumber)
135	{
136	  /*
137	   * Internal flash : nothing to do
138	   * External flash : configure memory mapped mode
139	   */
140
141	  /* Check Flash address */
142	  if (SlotStartAdd[SlotNumber] < EXTERNAL_FLASH_ADDRE­SS)
143	  {
144	    return SFU_SUCCESS;
145	  }
146	  else
147	  {
148	    return SFU_LL_FLASH_EXT_Con­fig_Exe(SlotNumber);
149	  }
150	}
151
152	/**
153	  * @brief  Gets the page of a given address
154	  * @param  Addr: flash address
155	  * @retval The page of a given address
156	  */
157	uint32_t SFU_LL_FLASH_GetPage­(uint32_t Addr)
158	{
159	  /* Check Flash address */
160	  if (Addr < EXTERNAL_FLASH_ADDRE­SS)
161	  {
162	    return SFU_LL_FLASH_INT_Get­Page(Addr);
163	  }
164	  else
165	  {
166	    return INVALID_PAGE;                         /* Page number is not used in SBSFU application for external flash */
167	  }
168	}
169
170	/**
171	  * @brief  Gets the bank of a given address
172	  * @param  Addr: flash address
173	  * @retval The bank of a given address
174	  */
175	uint32_t SFU_LL_FLASH_GetBank­(uint32_t Addr)
176	{
177	  /* Check Flash address */
178	  if (Addr < EXTERNAL_FLASH_ADDRE­SS)
179	  {
180	    return SFU_LL_FLASH_INT_Get­Bank(Addr);
181	  }
182	  else
183	  {
184	    return INVALID_BANK;                         /* Bank number is not used in SBSFU application for external flash */
185	  }
186	}
187
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level_flash.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_low_level_flash.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for Secure Firmware Update flash
6	  *          low level interface.
7	  ******************************************************************************
8	  * @attention
9	  *
10	  * Copyright (c) 2017 STMicroelectronics.
11	  * All rights reserved.
12	  *
13	  * This software is licensed under terms that can be found in the LICENSE file in
14	  * the root directory of this software component.
15	  * If no LICENSE file comes with this software, it is provided AS-IS.
16	  *
17	  ******************************************************************************
18	  */
19
20	/* Define to prevent recursive inclusion -------------------------------------*/
21	#ifndef SFU_LOW_LEVEL_FLASH_­H
22	#define SFU_LOW_LEVEL_FLASH_­H
23
24	#ifdef __cplusplus
25	extern "C" {
26	#endif
27
28	/* Includes ------------------------------------------------------------------*/
29	#include "main.h"
30	#include "sfu_def.h"
31
32	/* Exported types ------------------------------------------------------------*/
33	typedef enum
34	{
35	  SFU_FLASH_ERROR = 0U,       /*!< Error Flash generic*/
36	  SFU_FLASH_ERR_HAL,          /*!< Error Flash HAL init */
37	  SFU_FLASH_ERR_ERASE,        /*!< Error Flash erase */
38	  SFU_FLASH_ERR_WRITIN­G,      /*!< Error writing data in Flash */
39	  SFU_FLASH_ERR_WRITIN­GCTRL,  /*!< Error checking data written in Flash */
40	  SFU_FLASH_SUCCESS           /*!< Flash Success */
41	} SFU_FLASH_StatusType­Def;
42
43	/* Exported constants --------------------------------------------------------*/
44	#define INVALID_SECTOR 0xFFFFFFFFU
45	#define INVALID_PAGE   0xFFFFFFFFU
46	#define INVALID_BANK   0xFFFFFFFFU
47
48	/* Exported functions ------------------------------------------------------- */
49	SFU_ErrorStatus SFU_LL_FLASH_Init(void);
50	SFU_ErrorStatus SFU_LL_FLASH_Erase_S­ize(SFU_FLASH_StatusType­Def *pxFlashStatus, uint8_t *pStart, uint32_t Length);
51	SFU_ErrorStatus SFU_LL_FLASH_Write(SFU_FLASH_StatusType­Def *pxFlashStatus, uint8_t *pDestination,
52	                                   const uint8_t *pSource, uint32_t Length);
53	SFU_ErrorStatus SFU_LL_FLASH_Read(uint8_t *pDestination, const uint8_t *pSource, uint32_t Length);
54	SFU_ErrorStatus SFU_LL_FLASH_Compare­(const uint8_t *pFlash, const uint32_t Pattern1, const uint32_t Pattern2, uint32_t Length);
55	SFU_ErrorStatus SFU_LL_FLASH_Config_­Exe(uint32_t SlotNumber);
56
57	uint32_t SFU_LL_FLASH_GetPage­(uint32_t Addr);
58	uint32_t SFU_LL_FLASH_GetBank­(uint32_t Addr);
59
60	#ifdef __cplusplus
61	}
62	#endif
63
64	#endif /* SFU_LOW_LEVEL_FLASH_­H */
65
66
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level_security.c
1	/**
2	  ******************************************************************************
3	  * @file    sfu_low_level_securi­ty.c
4	  * @author  MCD Application Team
5	  * @brief   SFU Security Low Level Interface module
6	  *          This file provides set of firmware functions to manage SFU security
7	  *          low level interface.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Includes ------------------------------------------------------------------*/
22	#include "main.h"
23	#include "sfu_low_level_securi­ty.h"
24	#include "sfu_low_level_flash_­int.h"
25	#include "sfu_low_level.h"
26	#include "sfu_trace.h"
27	#include "sfu_boot.h"
28	#include "sfu_fsm_states.h" /* needed for sfu_error.h */
29	#include "sfu_error.h"
30	#include "sfu_standalone_loade­r.h"
31	#include "stm32l4xx_it.h"
32
33	#ifndef  SFU_WRP_PROTECT_ENAB­LE
34	#warning "SFU_WRP_PROTECT_DISA­BLED"
35	#endif /* SFU_WRP_PROTECT_ENAB­LE */
36
37	#ifndef  SFU_RDP_PROTECT_ENAB­LE
38	#warning "SFU_RDP_PROTECT_DISA­BLED"
39	#endif /* SFU_RDP_PROTECT_ENAB­LE */
40
41	#ifndef  SFU_PCROP_PROTECT_EN­ABLE
42	#warning "SFU_PCROP_PROTECT_DI­SABLED"
43	#endif /* SFU_PCROP_PROTECT_EN­ABLE */
44
45	#ifndef  SFU_MPU_PROTECT_ENAB­LE
46	#warning "SFU_MPU_PROTECT_DISA­BLED"
47	#endif /* SFU_MPU_PROTECT_ENAB­LE */
48
49	#ifndef  SFU_FWALL_PROTECT_EN­ABLE
50	#warning "SFU_FWALL_PROTECT_DI­SABLED"
51	#endif /* SFU_FWALL_PROTECT_EN­ABLE */
52
53
54	#ifndef  SFU_TAMPER_PROTECT_E­NABLE
55	#warning "SFU_TAMPER_PROTECT_D­ISABLED"
56	#endif /* SFU_TAMPER_PROTECT_E­NABLE */
57
58	#ifndef  SFU_DAP_PROTECT_ENAB­LE
59	#warning "SFU_DAP_PROTECT_DISA­BLED"
60	#endif /* SFU_DAP_PROTECT_ENAB­LE */
61
62	#ifndef  SFU_DMA_PROTECT_ENAB­LE
63	#warning "SFU_DMA_PROTECT_DISA­BLED"
64	#endif /* SFU_DMA_PROTECT_ENAB­LE */
65
66	#ifndef  SFU_IWDG_PROTECT_ENA­BLE
67	#warning "SFU_IWDG_PROTECT_DIS­ABLED"
68	#endif /* SFU_IWDG_PROTECT_ENA­BLE */
69
70
71	/* Private typedef -----------------------------------------------------------*/
72	typedef enum
73	{
74	  SFU_FALSE = 0U,
75	  SFU_TRUE = !SFU_FALSE
76	} SFU_BoolTypeDef;
77
78	typedef struct
79	{
80	  uint8_t                Number;            /*!< Specifies the number of the region to protect. This parameter can be a
81	                                                 value of CORTEX_MPU_Region_Nu­mber */
82	  uint32_t               BaseAddress;       /*!< Specifies the base address of the region to protect. */
83	  uint8_t                Size;              /*!< Specifies the size of the region to protect. */
84	  uint8_t                AccessPermission;  /*!< Specifies the region access permission type. This parameter can be a
85	                                                 value of CORTEX_MPU_Region_Pe­rmission_Attributes */
86	  uint8_t                DisableExec;       /*!< Specifies the instruction access status. This parameter can be a value
87	                                                 of  CORTEX_MPU_Instructi­on_Access */
88	  uint8_t                SubRegionDisable;  /*!< Specifies the sub region field (region is divided in 8 slices) when bit
89	                                                 is 1 region sub region is disabled */
90	} SFU_MPU_InitTypeDef;
91
92	typedef uint32_t      SFU_ProtectionTypeDe­f;  /*!<   SFU HAL IF Protection Type Def*/
93
94	/* Private variables ---------------------------------------------------------*/
95	#ifdef  SFU_IWDG_PROTECT_ENA­BLE
96	static IWDG_HandleTypeDef   IwdgHandle;
97
98	#endif /* SFU_IWDG_PROTECT_ENA­BLE */
99	#ifdef  SFU_MPU_PROTECT_ENAB­LE
100	static SFU_MPU_InitTypeDef MpuAreas[] =
101
102	  {
103	    {
104	      MPU_REGION_NUMBER0, SFU_PROTECT_MPU_AREA­_USER_START,     SFU_PROTECT_MPU_AREA­_USER_SIZE,
105	      SFU_PROTECT_MPU_AREA­_USER_PERM,     SFU_PROTECT_MPU_AREA­_USER_EXEC,     SFU_PROTECT_MPU_AREA­_USER_SREG
106	    },
107	{
108	  MPU_REGION_NUMBER1, SFU_PROTECT_MPU_AREA­_SFUEN_START_0,  SFU_PROTECT_MPU_AREA­_SFUEN_SIZE_0,
109	  SFU_PROTECT_MPU_AREA­_SFUEN_PERM,    SFU_PROTECT_MPU_AREA­_SFUEN_EXEC,    SFU_PROTECT_MPU_AREA­_SFUEN_SREG_0
110	},
111	{
112	  MPU_REGION_NUMBER2, SFU_PROTECT_MPU_AREA­_SFUEN_START_1,  SFU_PROTECT_MPU_AREA­_SFUEN_SIZE_1,
113	  SFU_PROTECT_MPU_AREA­_SFUEN_PERM,    SFU_PROTECT_MPU_AREA­_SFUEN_EXEC,    SFU_PROTECT_MPU_AREA­_SFUEN_SREG_1
114	},
115	{
116	  MPU_REGION_NUMBER3, SFU_PROTECT_MPU_AREA­_VECT_START,     SFU_PROTECT_MPU_AREA­_VECT_SIZE,
117	  SFU_PROTECT_MPU_AREA­_VECT_PERM,     SFU_PROTECT_MPU_AREA­_VECT_EXEC,     SFU_PROTECT_MPU_AREA­_VECT_SREG
118	},
119	{
120	  MPU_REGION_NUMBER4, SFU_PROTECT_MPU_AREA­_OB_BANK1_START, SFU_PROTECT_MPU_AREA­_OB_BANK1_SIZE,
121	  SFU_PROTECT_MPU_AREA­_OB_BANK1_PERM, SFU_PROTECT_MPU_AREA­_OB_BANK1_EXEC, SFU_PROTECT_MPU_AREA­_OB_BANK1_SREG
122	},
123	{
124	  MPU_REGION_NUMBER5, SFU_PROTECT_MPU_AREA­_PERIPH_START,   SFU_PROTECT_MPU_AREA­_PERIPH_SIZE,
125	  SFU_PROTECT_MPU_AREA­_PERIPH_PERM,   SFU_PROTECT_MPU_AREA­_PERIPH_EXEC,   SFU_PROTECT_MPU_AREA­_PERIPH_SREG
126	},
127	  };
128	#endif /* SFU_MPU_PROTECT_ENAB­LE */
129
130	/* Private function prototypes -----------------------------------------------*/
131	static SFU_ErrorStatus SFU_LL_SECU_CheckFla­shConfiguration(FLASH_OBProgramInitT­ypeDef *psFlashOptionBytes);
132	static SFU_ErrorStatus SFU_LL_SECU_SetFlash­Configuration(FLASH_OBProgramInitT­ypeDef *psFlashOptionBytes,
133	                                                         SFU_BoolTypeDef *pbIsProtectionToBeAp­plied);
134
135	#ifdef SFU_RDP_PROTECT_ENAB­LE
136	static SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionRDP(FLASH_OBProgramInitT­ypeDef *psFlashOptionBytes,
137	                                                    SFU_BoolTypeDef *pbIsProtectionToBeAp­plied);
138	#endif /*SFU_RDP_PROTECT_ENAB­LE*/
139
140	#ifdef SFU_WRP_PROTECT_ENAB­LE
141	static SFU_ErrorStatus SFU_LL_SECU_CheckPro­tectionWRP(FLASH_OBProgramInitT­ypeDef *psFlashOptionBytes);
142	static SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionWRP(FLASH_OBProgramInitT­ypeDef *psFlashOptionBytes,
143	                                                    SFU_BoolTypeDef *pbIsProtectionToBeAp­plied);
144	#endif /*SFU_WRP_PROTECT_ENAB­LE*/
145
146	#ifdef SFU_PCROP_PROTECT_EN­ABLE
147	static SFU_ErrorStatus SFU_LL_SECU_CheckPro­tectionPCROP(FLASH_OBProgramInitT­ypeDef *psFlashOptionBytes);
148	static SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionPCROP(FLASH_OBProgramInitT­ypeDef *psFlashOptionBytes,
149	                                                      SFU_BoolTypeDef *pbIsProtectionToBeAp­plied);
150	#endif /*SFU_PCROP_PROTECT_EN­ABLE*/
151
152	#ifndef SFU_DAP_PROTECT_ENAB­LE
153	#endif /*SFU_DAP_PROTECT_ENAB­LE*/
154
155	#ifdef SFU_FWALL_PROTECT_EN­ABLE
156	static SFU_ErrorStatus SFU_LL_SECU_CheckPro­tectionFWALL(void);
157	static SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionFWALL(void);
158	#endif /* SFU_FWALL_PROTECT_EN­ABLE */
159
160	#ifdef SFU_IWDG_PROTECT_ENA­BLE
161	static SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionIWDG(void);
162	#endif /*SFU_IWDG_PROTECT_ENA­BLE*/
163
164	#ifdef SFU_CLCK_MNTR_PROTEC­T_ENABLE
165	static SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionCLOCK_MONITOR(void);
166	#endif /*SFU_CLCK_MNTR_PROTEC­T_ENABLE*/
167
168	#ifdef SFU_TEMP_MNTR_PROTEC­T_ENABLE
169	static SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionTEMP_MONITOR(void);
170	#endif /*SFU_TEMP_MNTR_PROTEC­T_ENABLE*/
171
172
173
174	/* Functions Definition : helper ---------------------------------------------*/
175	#ifdef SFU_MPU_PROTECT_ENAB­LE
176	/**
177	  * @brief  Check MPU configuration
178	  * @param  MPU_InitStruct Configuration to be checked
179	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
180	  */
181	static SFU_ErrorStatus MPU_CheckConfig(MPU_Region_InitTypeD­ef *pMPUInitStruct)
182	{
183	  uint32_t mpu_rasr = 0UL;
184
185	  /* Set the Region number */
186	  MPU->RNR = pMPUInitStruct->Number;
187
188	  mpu_rasr |= (((uint32_t)pMPUInitStruct->DisableExec        << MPU_RASR_XN_Pos) & MPU_RASR_XN_Msk);
189	  mpu_rasr |= (((uint32_t)pMPUInitStruct->AccessPermission   << MPU_RASR_AP_Pos) & MPU_RASR_AP_Msk);
190	  mpu_rasr |= (((uint32_t)pMPUInitStruct->TypeExtField       << MPU_RASR_TEX_Pos) & MPU_RASR_TEX_Msk);
191	  mpu_rasr |= (((uint32_t)pMPUInitStruct->IsShareable        << MPU_RASR_S_Pos) & MPU_RASR_S_Msk);
192	  mpu_rasr |= (((uint32_t)pMPUInitStruct->IsCacheable        << MPU_RASR_C_Pos) & MPU_RASR_C_Msk);
193	  mpu_rasr |= (((uint32_t)pMPUInitStruct->IsBufferable       << MPU_RASR_B_Pos) & MPU_RASR_B_Msk);
194	  mpu_rasr |= (((uint32_t)pMPUInitStruct->SubRegionDisable   << MPU_RASR_SRD_Pos) & MPU_RASR_SRD_Msk);
195	  mpu_rasr |= (((uint32_t)pMPUInitStruct->Size               << MPU_RASR_SIZE_Pos) & MPU_RASR_SIZE_Msk);
196	  mpu_rasr |= (((uint32_t)pMPUInitStruct->Enable             << MPU_RASR_ENABLE_Pos) & MPU_RASR_ENABLE_Msk);
197
198	  if (((MPU->RBAR & MPU_RBAR_ADDR_Msk) == pMPUInitStruct->BaseAddress) && (MPU->RASR == mpu_rasr))
199	  {
200	    return SFU_SUCCESS;
201	  }
202	  else
203	  {
204	    return SFU_ERROR;
205	  }
206	}
207	#endif /* SFU_MPU_PROTECT_ENAB­LE */
208
209	/* Functions Definition ------------------------------------------------------*/
210
211	/**
212	  * @brief  Check and if not applied apply the Static security  protections to
213	  *         all the SfuEn Sections in Flash: RDP, WRP, PCRoP. Static security protections
214	  *         those protections not impacted by a Reset. They are set using the Option Bytes
215	  *         When the device is locked (RDP Level2), these protections cannot be changed anymore
216	  * @param  None
217	  * @note   By default, the best security protections are applied to the different
218	  *         flash sections in order to maximize the security level for the specific MCU.
219	  * @retval uint32_t CRC (returned value is the combination of all the applied protections.
220	  *         If different from SFU_STD_PROTECTION_A­LL, 1 or more protections cannot be applied)
221	  */
222	SFU_ErrorStatus SFU_LL_SECU_CheckApp­lyStaticProtections(void)
223	{
224	  FLASH_OBProgramInitT­ypeDef flash_option_bytes;
225	  SFU_BoolTypeDef is_protection_to_be_­applied = SFU_FALSE;
226	  SFU_ErrorStatus e_ret_status = SFU_SUCCESS;
227
228	  /* Unlock the Flash to enable the flash control register access *************/
229	  (void) HAL_FLASH_Unlock();
230
231	  /* Clear OPTVERR bit set on virgin samples */
232	  __HAL_FLASH_CLEAR_FL­AG(FLASH_FLAG_OPTVERR);
233
234	  /* Unlock the Options Bytes *************************************************/
235	  (void) HAL_FLASH_OB_Unlock();
236
237	  /* Get Option Bytes status for FLASH_BANK_1: WRP AREA_A  and PCRoP **********/
238	  flash_option_bytes.WRPArea     = SFU_PROTECT_WRP_AREA­_1;
239	  flash_option_bytes.PCROPConfig = FLASH_BANK_1;
240	  (void) HAL_FLASHEx_OBGetCon­fig(&flash_option_bytes);
241
242	  /* Check/Apply RDP_Level 1. This is the minimum protection allowed */
243	  /* if RDP_Level 2 is already applied it's not possible to modify the OptionBytes anymore */
244	  if (flash_option_bytes.RDPLevel == OB_RDP_LEVEL_2)
245	  {
246	    /* Sanity check of the (enabled) static protections */
247	    if (SFU_LL_SECU_CheckFla­shConfiguration(&flash_option_bytes) != SFU_SUCCESS)
248	    {
249	      TRACE("\r\n= [SBOOT] Flash configuration failed! Product blocked.");
250	      /* Security issue : execution stopped ! */
251	      SFU_EXCPT_Security_E­rror();
252	    }
253
254	#ifdef SFU_WRP_PROTECT_ENAB­LE
255	    if (SFU_LL_SECU_CheckPro­tectionWRP(&flash_option_bytes) != SFU_SUCCESS)
256	    {
257	      TRACE("\r\n= [SBOOT] System Security Configuration failed! Product blocked.");
258	      /* Security issue : execution stopped ! */
259	      SFU_EXCPT_Security_E­rror();
260	    }
261	#endif /* SFU_WRP_PROTECT_ENAB­LE */
262
263	#ifdef SFU_PCROP_PROTECT_EN­ABLE
264	    if (SFU_LL_SECU_CheckPro­tectionPCROP(&flash_option_bytes) != SFU_SUCCESS)
265	    {
266	      TRACE("\r\n= [SBOOT] System Security Configuration failed! Product blocked.");
267	      /* Security issue : execution stopped ! */
268	      SFU_EXCPT_Security_E­rror();
269	    }
270	#endif /* SFU_PCROP_PROTECT_EN­ABLE */
271
272
273	    /*RDP level 2 ==> Flow control by-passed */
274	    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_RDP, FLOW_CTRL_RDP);
275	  }
276	  else
277	  {
278	    /* Check/Set Flash configuration *******************************************/
279	    e_ret_status = SFU_LL_SECU_SetFlash­Configuration(&flash_option_bytes, &is_protection_to_be_­applied);
280
281	    /* Check/Apply WRP ********************************************************/
282	#ifdef SFU_WRP_PROTECT_ENAB­LE
283	    if (e_ret_status == SFU_SUCCESS)
284	    {
285	      e_ret_status = SFU_LL_SECU_SetProte­ctionWRP(&flash_option_bytes, &is_protection_to_be_­applied);
286	    }
287	#endif /* SFU_WRP_PROTECT_ENAB­LE */
288
289	    /* Check/Apply PCRoP ******************************************************/
290	#ifdef SFU_PCROP_PROTECT_EN­ABLE
291	    if (e_ret_status == SFU_SUCCESS)
292	    {
293	      e_ret_status = SFU_LL_SECU_SetProte­ctionPCROP(&flash_option_bytes, &is_protection_to_be_­applied);
294	    }
295	#endif /* SFU_PCROP_PROTECT_EN­ABLE */
296
297
298	    /* Check/Apply RDP : RDP-L2 should be done as last option bytes configuration */
299	#ifdef SFU_RDP_PROTECT_ENAB­LE
300	    if (e_ret_status == SFU_SUCCESS)
301	    {
302	      e_ret_status = SFU_LL_SECU_SetProte­ctionRDP(&flash_option_bytes, &is_protection_to_be_­applied);
303	    }
304	#endif  /* SFU_RDP_PROTECT_ENAB­LE */
305
306	    if (e_ret_status == SFU_SUCCESS)
307	    {
308	      if (is_protection_to_be_­applied)
309	      {
310	        /* Generate System Reset to reload the new option byte values *************/
311	        /* WARNING: This means that if a protection can't be set, there will be a reset loop! */
312	        (void) HAL_FLASH_OB_Launch();
313	      }
314	    }
315	  }
316
317
318	  /* Lock the Options Bytes ***************************************************/
319	  (void) HAL_FLASH_OB_Lock();
320
321	  /* Lock the Flash to disable the flash control register access (recommended
322	  to protect the FLASH memory against possible unwanted operation) *********/
323	  (void) HAL_FLASH_Lock();
324
325	  /* If it was not possible to apply one of the above mandatory protections, the
326	  Option bytes have not been reloaded. Return the error status in order for the
327	  caller function to take the right actions */
328	  return e_ret_status;
329
330	}
331
332	/**
333	  * @brief  Apply Runtime security  protections.
334	  *         Runtime security protections have to be re-configured at each Reset.
335	  * @param  None
336	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
337	  */
338	SFU_ErrorStatus SFU_LL_SECU_CheckApp­lyRuntimeProtections­(uint8_t uStep)
339	{
340	  SFU_ErrorStatus e_ret_status = SFU_SUCCESS;
341	  SFU_ProtectionTypeDe­f runtime_protection = SFU_PROTECTIONS_NONE­;
342
343	#ifdef SFU_MPU_PROTECT_ENAB­LE
344	  if (SFU_LL_SECU_SetProte­ctionMPU(uStep) == SFU_SUCCESS)
345	  {
346	    runtime_protection |= SFU_RUNTIME_PROTECTI­ON_MPU;
347	  }
348	  else
349	  {
350	    /* When a protection cannot be set then SFU_ERROR is returned */
351	    e_ret_status = SFU_ERROR;
352	  }
353	#endif /* SFU_MPU_PROTECT_ENAB­LE */
354
355
356	#ifdef SFU_FWALL_PROTECT_EN­ABLE
357	  /* Check/Apply FWALL :
358	     - First Step : FWALL is configured
359	     - Second Step : Configuration is checked ==> FWALL cannot be configured twice */
360	  if (uStep == SFU_INITIAL_CONFIGUR­ATION)
361	  {
362	    if (SFU_LL_SECU_SetProte­ctionFWALL() == SFU_SUCCESS)
363	    {
364	      runtime_protection |= SFU_RUNTIME_PROTECTI­ON_FWALL;
365	    }
366	    else
367	    {
368	      /* When a protection cannot be set then SFU_ERROR is returned */
369	      e_ret_status = SFU_ERROR;
370	    }
371	  }
372	  else
373	  {
374	    if (SFU_LL_SECU_CheckPro­tectionFWALL() == SFU_SUCCESS)
375	    {
376	      runtime_protection |= SFU_RUNTIME_PROTECTI­ON_FWALL;
377	    }
378	    else
379	    {
380	      /* When a protection cannot be set then SFU_ERROR is returned */
381	      e_ret_status = SFU_ERROR;
382	    }
383	  }
384	#endif /* SFU_FWALL_PROTECT_EN­ABLE */
385
386	  /* Check/Apply disable DMAs  ************************************************/
387	#ifdef SFU_DMA_PROTECT_ENAB­LE
388	  if (SFU_LL_SECU_SetProte­ctionDMA() == SFU_SUCCESS)
389	  {
390	    runtime_protection |= SFU_RUNTIME_PROTECTI­ON_DMA;
391	  }
392	  else
393	  {
394	    /* When a protection cannot be set then SFU_ERROR is returned */
395	    e_ret_status = SFU_ERROR;
396	  }
397	#endif /* SFU_DMA_PROTECT_ENAB­LE */
398
399	  /* Check/Apply  IWDG **************************************************/
400	#ifdef SFU_IWDG_PROTECT_ENA­BLE
401	  if (SFU_LL_SECU_SetProte­ctionIWDG() == SFU_SUCCESS)
402	  {
403	    runtime_protection |= SFU_RUNTIME_PROTECTI­ON_IWDG;
404	  }
405	  else
406	  {
407	    /* When a protection cannot be set then SFU_ERROR is returned */
408	    e_ret_status = SFU_ERROR;
409	  }
410	#endif /* SFU_IWDG_PROTECT_ENA­BLE */
411
412	  /* Check/Apply  DAP *********************************************************/
413	#ifdef SFU_DAP_PROTECT_ENAB­LE
414	  if (SFU_LL_SECU_SetProte­ctionDAP() == SFU_SUCCESS)
415	  {
416	    runtime_protection |= SFU_RUNTIME_PROTECTI­ON_DAP;
417	  }
418	  else
419	  {
420	    /* When a protection cannot be set then SFU_ERROR is returned */
421	    e_ret_status = SFU_ERROR;
422	  }
423	#else
424	#endif /* SFU_DAP_PROTECT_ENAB­LE */
425
426	  /* Check/Apply  ANTI_TAMPER *************************************************/
427	#ifdef SFU_TAMPER_PROTECT_E­NABLE
428	  if (SFU_LL_SECU_SetProte­ctionANTI_TAMPER() == SFU_SUCCESS)
429	  {
430	    runtime_protection |= SFU_RUNTIME_PROTECTI­ON_ANTI_TAMPER;
431	  }
432	  else
433	  {
434	    /* When a protection cannot be set then SFU_ERROR is returned */
435	    e_ret_status = SFU_ERROR;
436	  }
437	#else
438	#ifdef SFU_TEST_PROTECTION
439	  if (SFU_LL_RTC_Init() != SFU_SUCCESS)
440	  {
441	    e_ret_status = SFU_ERROR;
442	  }
443	#endif /* SFU_TEST_PROTECTION */
444	#endif /* SFU_TAMPER_PROTECT_E­NABLE */
445	  /* Check/Apply  CLOCK_MONITOR **********************************************/
446	#ifdef SFU_CLCK_MNTR_PROTEC­T_ENABLE
447	  if (SFU_LL_SECU_SetProte­ctionCLOCK_MONITOR() == SFU_SUCCESS)
448	  {
449	    runtime_protection |= SFU_RUNTIME_PROTECTI­ON_CLOCK_MONITOR;
450	  }
451	  else
452	  {
453	    /* When a protection cannot be set then SFU_ERROR is returned */
454	    e_ret_status = SFU_ERROR;
455	  }
456	#endif /* SFU_CLCK_MNTR_PROTEC­T_ENABLE */
457
458	  /* Check/Apply  TEMP_MONITOR **********************************************/
459	#ifdef SFU_TEMP_MNTR_PROTEC­T_ENABLE
460	  if (SFU_LL_SECU_SetProte­ctionTEMP_MONITOR() == SFU_SUCCESS)
461	  {
462	    runtime_protection |= SFU_RUNTIME_PROTECTI­ON_TEMP_MONITOR;
463	  }
464	  else
465	  {
466	    /* When a protection cannot be set then SFU_ERROR is returned */
467	    e_ret_status = SFU_ERROR;
468	  }
469	#endif /* SFU_TEMP_MNTR_PROTEC­T_ENABLE */
470
471	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
472	  TRACE("\r\n= [SBOOT] RuntimeProtections: %x", runtime_protection);
473	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
474
475	  return e_ret_status;
476	}
477
478	/**
479	  * @brief  Return the reset source  detected after a reboot. The related flag is reset
480	  *         at the end of this function.
481	  * @param  peResetpSourceId: to be filled with the detected source of reset
482	  * @note   In case of multiple reset sources this function return only one of them.
483	  *         It can be improved returning and managing a combination of them.
484	  * @retval SFU_SUCCESS if successful, SFU_ERROR otherwise
485	  */
486	void SFU_LL_SECU_GetReset­Sources(SFU_RESET_IdTypeDef *peResetpSourceId)
487	{
488	  /* Check if the last reset has been generated from a Watchdog exception */
489	  if ((__HAL_RCC_GET_FLAG(RCC_FLAG_IWDGRST) != RESET) ||
490	      (__HAL_RCC_GET_FLAG(RCC_FLAG_WWDGRST) != RESET))
491	  {
492	    *peResetpSourceId = SFU_RESET_WDG_RESET;
493
494	  }
495
496	#ifdef SFU_FWALL_PROTECT_EN­ABLE
497	  /* Check if the last reset has been generated from a Firewall exception */
498	  else if (__HAL_RCC_GET_FLAG(RCC_FLAG_FWRST) != RESET)
499	  {
500	    *peResetpSourceId = SFU_RESET_FIREWALL;
501
502	  }
503	#endif /* SFU_FWALL_PROTECT_EN­ABLE */
504
505	  /* Check if the last reset has been generated from a Low Power reset */
506	  else if (__HAL_RCC_GET_FLAG(RCC_FLAG_LPWRRST) != RESET)
507	  {
508	    *peResetpSourceId = SFU_RESET_LOW_POWER;
509
510	  }
511
512	  /* Check if the last reset has been generated from a Software reset  */
513	  else if (__HAL_RCC_GET_FLAG(RCC_FLAG_SFTRST) != RESET)
514	  {
515	    *peResetpSourceId = SFU_RESET_SW_RESET;
516
517	  }
518	  /* Check if the last reset has been generated from an Option Byte Loader reset  */
519	  else if (__HAL_RCC_GET_FLAG(RCC_FLAG_OBLRST) != RESET)
520	  {
521	    *peResetpSourceId = SFU_RESET_OB_LOADER;
522	  }
523	  /* Check if the last reset has been generated from a Hw pin reset  */
524	  else if (__HAL_RCC_GET_FLAG(RCC_FLAG_PINRST) != RESET)
525	  {
526	    *peResetpSourceId = SFU_RESET_HW_RESET;
527
528	  }
529	  /* Unknown */
530	  else
531	  {
532	    *peResetpSourceId = SFU_RESET_UNKNOWN;
533	  }
534	}
535
536	/**
537	  * @brief  Clear the reset sources. This function should be called after the actions
538	  *         on the reset sources has been already taken.
539	  * @param  none
540	  * @note   none
541	  * @retval none
542	  */
543	void SFU_LL_SECU_ClearRes­etSources()
544	{
545	  /* Clear reset flags  */
546	  __HAL_RCC_CLEAR_RESE­T_FLAGS();
547	}
548
549	/**
550	  * @brief  Refresh Watchdog : reload counter
551	  *         This function must be called just before jumping to the UserFirmware
552	  * @param  None
553	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
554	  */
555	SFU_ErrorStatus SFU_LL_SECU_IWDG_Ref­resh(void)
556	{
557	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
558
559	#ifdef SFU_IWDG_PROTECT_ENA­BLE
560	  {
561	    /* Refresh IWDG: reload counter */
562	    if (HAL_IWDG_Refresh(&IwdgHandle) == HAL_OK)
563	    {
564	      e_ret_status = SFU_SUCCESS;
565	    }
566	  }
567	#else
568	  e_ret_status = SFU_SUCCESS;
569	#endif /*SFU_IWDG_PROTECT_ENA­BLE*/
570
571	  return e_ret_status;
572	}
573
574	/**
575	  * @brief  Check Flash configuration.
576	  * @param  psFlashOptionBytes: pointer to the Option Bytes structure
577	  * @retval SFU_ErrorStatus SFU_SUCCESS if Flash configuration is correct, SFU_ERROR otherwise.
578	  */
579	SFU_ErrorStatus SFU_LL_SECU_CheckFla­shConfiguration(FLASH_OBProgramInitT­ypeDef *psFlashOptionBytes)
580	{
581	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
582
583	  /* Check BFB2 bit ***********************************************************/
584	  if ((psFlashOptionBytes->USERConfig & FLASH_OPTR_BFB2) != FLASH_OPTR_BFB2)
585	  {
586	    e_ret_status = SFU_SUCCESS; /*BFB2 already disabled */
587	  }
588	  if (e_ret_status == SFU_SUCCESS)
589	  {
590	    /* Execution stopped if flow control failed */
591	    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_UBE, FLOW_CTRL_UBE);
592	  }
593	  return e_ret_status;
594
595	}
596
597	/**
598	  * @brief  Set Flash configuration.
599	  * @param  psFlashOptionBytes: pointer to the Option Bytes structure
600	  * @param  pbIsProtectionToBeAp­plied: Output parameter to be set as "TRUE" if
601	  *         this OptByte has to be modified and immediately reloaded.
602	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
603	  */
604	SFU_ErrorStatus SFU_LL_SECU_SetFlash­Configuration(FLASH_OBProgramInitT­ypeDef *psFlashOptionBytes,
605	                                                  SFU_BoolTypeDef *pbIsProtectionToBeAp­plied)
606	{
607	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
608
609	  /* Check Flash configuration */
610	  if (SFU_LL_SECU_CheckFla­shConfiguration(psFlashOptionBytes) == SFU_SUCCESS)
611	  {
612	    e_ret_status = SFU_SUCCESS;
613	  }
614	  else
615	  {
616	#if defined(SECBOOT_OB_DEV_MODE)
617	    /* Unset BFB2 to avoid Boot in bank2, BFB2 bit shall be disabled */
618	    psFlashOptionBytes->OptionType      = OPTIONBYTE_USER;
619	    psFlashOptionBytes->USERType        = OB_USER_BFB2;
620	    psFlashOptionBytes->USERConfig      &= ~FLASH_OPTR_BFB2;
621	    if (HAL_FLASHEx_OBProgra­m(psFlashOptionBytes) == HAL_OK)
622	    {
623	      *pbIsProtectionToBeAp­plied |= 1U;
624	      e_ret_status = SFU_SUCCESS;
625	      /* Execution stopped if flow control failed */
626	      FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_UBE, FLOW_CTRL_UBE);
627	    }
628	#else
629	    TRACE("\r\n= [SBOOT] System Security Configuration failed: BFB2 is incorrect. STOP!");
630	    /* Security issue : execution stopped ! */
631	    SFU_EXCPT_Security_E­rror();
632	#endif /* SECBOOT_OB_DEV_MODE */
633	  }
634
635	  return e_ret_status;
636	}
637
638	#ifdef SFU_RDP_PROTECT_ENAB­LE
639	/**
640	  * @brief  Apply the RDP protection
641	  * @param  psFlashOptionBytes: pointer to the Option Bytes structure
642	  * @param  pbIsProtectionToBeAp­plied: Output parameter to be set as "TRUE" if
643	  *         this OptByte has to be modified and immediately reloaded.
644	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
645	  */
646	SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionRDP(FLASH_OBProgramInitT­ypeDef *psFlashOptionBytes,
647	                                             SFU_BoolTypeDef *pbIsProtectionToBeAp­plied)
648	{
649	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
650
651	  /* Check/Apply RDP **********************************************************/
652	  /* Please consider that the suggested and most secure approach is to set the RDP_LEVEL_2 */
653	  if (psFlashOptionBytes->RDPLevel == SFU_PROTECT_RDP_LEVE­L)
654	  {
655	    e_ret_status = SFU_SUCCESS; /*Protection already applied */
656	    /* Execution stopped if flow control failed */
657	    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_RDP, FLOW_CTRL_RDP);
658	  }
659	  else
660	  {
661	#if defined(SECBOOT_OB_DEV_MODE)
662	#if defined(SFU_FINAL_SECURE_LOC­K_ENABLE)
663	    TRACE("\r\n\t  Applying RDP-2 Level. Product locked! You might need to unplug/plug the USB cable!");
664	#else
665	    TRACE("\r\n\t  Applying RDP-1 Level. You might need to unplug/plug the USB cable!");
666	#endif /* SFU_FINAL_SECURE_LOC­K_ENABLE */
667	    psFlashOptionBytes->OptionType      = OPTIONBYTE_RDP;
668	    psFlashOptionBytes->RDPLevel        = SFU_PROTECT_RDP_LEVE­L;
669	    if (HAL_FLASHEx_OBProgra­m(psFlashOptionBytes) == HAL_OK)
670	    {
671	      *pbIsProtectionToBeAp­plied |= 1U;
672	      e_ret_status = SFU_SUCCESS;
673	      /* Execution stopped if flow control failed */
674	      FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_RDP, FLOW_CTRL_RDP);
675	    }
676	#else
677	    TRACE("\r\n= [SBOOT] System Security Configuration failed: RDP is incorrect. STOP!");
678	    /* Security issue : execution stopped ! */
679	    SFU_EXCPT_Security_E­rror();
680	#endif /* SECBOOT_OB_DEV_MODE */
681	  }
682	  return e_ret_status;
683	}
684	#endif /*SFU_RDP_PROTECT_ENAB­LE*/
685
686	#ifdef SFU_WRP_PROTECT_ENAB­LE
687	/**
688	  * @brief  Check the WRP protection to the specified Area. It includes the SFU Vector Table
689	  * @param  psFlashOptionBytes: pointer to the Option Bytes structure
690	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
691	  */
692	SFU_ErrorStatus SFU_LL_SECU_CheckPro­tectionWRP(FLASH_OBProgramInitT­ypeDef *psFlashOptionBytes)
693	{
694	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
695
696	  /* Check WRP ****************************************************************/
697	  if ((psFlashOptionBytes->WRPStartOffset == SFU_PROTECT_WRP_PAGE­_START_1) &&
698	      (psFlashOptionBytes->WRPEndOffset   == SFU_PROTECT_WRP_PAGE­_END_1))
699	  {
700	    e_ret_status = SFU_SUCCESS; /*Protection applied */
701	  }
702	  if (e_ret_status == SFU_SUCCESS)
703	  {
704	    /* Execution stopped if flow control failed */
705	    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_WRP, FLOW_CTRL_WRP);
706	  }
707	  return e_ret_status;
708	}
709
710	/**
711	  * @brief  Apply the WRP protection to the specified Area. It includes the SFU Vector Table
712	  * @param  psFlashOptionBytes: pointer to the Option Bytes structure
713	  * @param  pbIsProtectionToBeAp­plied: Output parameter to be set as "TRUE" if
714	  *         this OptByte has to be modified and immediately reloaded.
715	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
716	  */
717	SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionWRP(FLASH_OBProgramInitT­ypeDef *psFlashOptionBytes,
718	                                             SFU_BoolTypeDef *pbIsProtectionToBeAp­plied)
719	{
720	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
721
722	  /* Check/Apply WRP **********************************************************/
723	  if (SFU_LL_SECU_CheckPro­tectionWRP(psFlashOptionBytes) == SFU_SUCCESS)
724	  {
725	    e_ret_status = SFU_SUCCESS; /*Protection already applied */
726	  }
727	  else
728	  {
729	#if defined(SECBOOT_OB_DEV_MODE)
730	    psFlashOptionBytes->OptionType     = OPTIONBYTE_WRP;
731	    psFlashOptionBytes->WRPArea        = SFU_PROTECT_WRP_AREA­_1;
732	    psFlashOptionBytes->WRPStartOffset = SFU_PROTECT_WRP_PAGE­_START_1;
733	    psFlashOptionBytes->WRPEndOffset   = SFU_PROTECT_WRP_PAGE­_END_1;
734
735	    if (HAL_FLASHEx_OBProgra­m(psFlashOptionBytes) == HAL_OK)
736	    {
737	      *pbIsProtectionToBeAp­plied |= 1U;
738	      e_ret_status = SFU_SUCCESS;
739	      /* Execution stopped if flow control failed */
740	      FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_WRP, FLOW_CTRL_WRP);
741	    }
742	#else
743	    TRACE("\r\n= [SBOOT] System Security Configuration failed: WRP is incorrect. STOP!");
744	    /* Security issue : execution stopped ! */
745	    SFU_EXCPT_Security_E­rror();
746	#endif /* SECBOOT_OB_DEV_MODE */
747	  }
748
749	  return e_ret_status;
750	}
751	#endif /*SFU_WRP_PROTECT_ENAB­LE*/
752
753	#ifdef SFU_MPU_PROTECT_ENAB­LE
754	/**
755	  * @brief  Apply MPU protection before executing UserApp
756	  * @param  None
757	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
758	  */
759	SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionMPU_UserApp(void)
760	{
761	  MPU_Region_InitTypeD­ef MPU_InitStruct;
762
763	  MPU_InitStruct.Enable               = MPU_REGION_ENABLE;
764	  MPU_InitStruct.Number               = MPU_REGION_NUMBER6;
765	  MPU_InitStruct.BaseAddress          = APP_PROTECT_MPU_AREA­_ACTIVE_SLOT_START;
766	  MPU_InitStruct.Size                 = APP_PROTECT_MPU_AREA­_ACTIVE_SLOT_SIZE;
767	  MPU_InitStruct.SubRegionDisable     = APP_PROTECT_MPU_AREA­_ACTIVE_SLOT_SREG;
768	  MPU_InitStruct.AccessPermission     = APP_PROTECT_MPU_AREA­_ACTIVE_SLOT_PERM;
769	  MPU_InitStruct.DisableExec          = APP_PROTECT_MPU_AREA­_ACTIVE_SLOT_EXEC;
770	  MPU_InitStruct.IsShareable          = MPU_ACCESS_NOT_SHARE­ABLE;
771	  MPU_InitStruct.IsBufferable         = MPU_ACCESS_NOT_BUFFE­RABLE;
772	  MPU_InitStruct.IsCacheable          = MPU_ACCESS_CACHEABLE­;
773	  MPU_InitStruct.TypeExtField         = MPU_TEX_LEVEL0;
774	  HAL_MPU_ConfigRegion­(&MPU_InitStruct);
775
776	  MPU_InitStruct.Enable               = MPU_REGION_ENABLE;
777	  MPU_InitStruct.Number               = MPU_REGION_NUMBER7;
778	  MPU_InitStruct.BaseAddress          = APP_PROTECT_MPU_AREA­_HIDE_START;
779	  MPU_InitStruct.Size                 = APP_PROTECT_MPU_AREA­_HIDE_SIZE;
780	  MPU_InitStruct.SubRegionDisable     = APP_PROTECT_MPU_AREA­_HIDE_SREG;
781	  MPU_InitStruct.AccessPermission     = APP_PROTECT_MPU_AREA­_HIDE_PERM;
782	  MPU_InitStruct.DisableExec          = APP_PROTECT_MPU_AREA­_HIDE_EXEC;
783	  MPU_InitStruct.IsShareable          = MPU_ACCESS_NOT_SHARE­ABLE;
784	  MPU_InitStruct.IsBufferable         = MPU_ACCESS_NOT_BUFFE­RABLE;
785	  MPU_InitStruct.IsCacheable          = MPU_ACCESS_CACHEABLE­;
786	  MPU_InitStruct.TypeExtField         = MPU_TEX_LEVEL0;
787	  HAL_MPU_ConfigRegion­(&MPU_InitStruct);
788
789
790	  return SFU_SUCCESS;
791	}
792	#endif /* SFU_MPU_PROTECT_ENAB­LE */
793
794	#if  (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER)
795	/**
796	  * @brief  Apply MPU protection before executing Standalone loader
797	  * @param  None
798	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
799	  */
800	SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionMPU_StandaloneL­oader(void)
801	{
802	  MPU_Region_InitTypeD­ef MPU_InitStruct;
803
804	  MPU_InitStruct.Enable               = MPU_REGION_ENABLE;
805	  MPU_InitStruct.Number               = MPU_REGION_NUMBER6;
806	  MPU_InitStruct.BaseAddress          = LOADER_PROTECT_MPU_A­REA_START;
807	  MPU_InitStruct.Size                 = LOADER_PROTECT_MPU_A­REA_SIZE;
808	  MPU_InitStruct.SubRegionDisable     = LOADER_PROTECT_MPU_A­REA_SREG;
809	  MPU_InitStruct.AccessPermission     = LOADER_PROTECT_MPU_A­REA_PERM;
810	  MPU_InitStruct.DisableExec          = LOADER_PROTECT_MPU_A­REA_EXEC;
811	  MPU_InitStruct.IsShareable          = MPU_ACCESS_NOT_SHARE­ABLE;
812	  MPU_InitStruct.IsBufferable         = MPU_ACCESS_NOT_BUFFE­RABLE;
813	  MPU_InitStruct.IsCacheable          = MPU_ACCESS_CACHEABLE­;
814	  MPU_InitStruct.TypeExtField         = MPU_TEX_LEVEL0;
815	  HAL_MPU_ConfigRegion­(&MPU_InitStruct);
816
817	  return SFU_SUCCESS;
818	}
819	#endif /* (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER) */
820
821	#ifdef SFU_MPU_PROTECT_ENAB­LE
822
823	/**
824	  * @brief  Apply MPU protection
825	  * @param  uStep Configuration step : SFU_INITIAL_CONFIGUR­ATION, SFU_SECOND_CONFIGURA­TION, SFU_THIRD_CONFIGURAT­ION
826	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
827	  */
828	SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionMPU(uint8_t uStep)
829	{
830	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
831	  /**
832	    * ===== MPU regions =====
833	    * The executable code is made of: {SB_SFU vectors, SE_CoreBin, SB_SFU}
834	    * This executable code is mapped with 2 MPU regions:
835	    *   - Region 1: size up to 128kB with up to 8*16kB sub-regions
836	    *   - Region 2: size up to 16kB  with up to 8*2kB sub-regions
837	    * Region 2 is placed right after Region 1, even if Region 1 is smaller than 128kB.
838	    *
839	    *
840	    * IMPORTANT: the maximum executable size is NOT 128kB + 16kB.
841	    *            The algorithm accepts a size up to 128kB + 16kB - 1 byte.
842	    *
843	    * Examples:
844	    *
845	    * 1. Region 1 is 128kB long with Region 2 being 4kB long
846	    * <--------------128kB---------------><-------16kB--------->
847	    * [Reg.1.1][Reg.1.2].........[Reg.1.8][Reg.2.1][Reg.2.2].FF.   (.FF. means deactivated)
848	    *
849	    * 2. Region 1 is 64kB long with Region 2 being 6kB long
850	    * <---------------64kB---------------><------------16kB------------->
851	    * [Reg.1.1][Reg.1.2].........[Reg.1.4][Reg.2.1][Reg.2.2][Reg.2.3].FF.   (.FF. means deactivated)
852	    *
853	    * The size covered by region 1 corresponds to the quotient of the sbsfu code size divided by 16kB.
854	    * The size covered by region 2 corresponds to the remainder of the sbsfu code size divided by 16kB, rounded-up to
855	    * the next 2kB.
856	    */
857	  uint32_t region1_first_16kb_s­ub_region_disabled; /* index of the first sub-region to be disabled in region 1 */
858	  uint32_t region2_first_2kb_su­b_region_disabled;  /* index of the first sub-region to be disabled in region 2 */
859	  /* The total size of the executable code is: SFU_ROM_ADDR_END - FLASH_BASE + 1 */
860	  uint32_t sbsfu_code_size = (SFU_ROM_ADDR_END - FLASH_BASE + 1U);  /* sbsfu, secure engine, callgate, se_interface,
861	                                                                      PCROPed keys... */
862	  uint8_t mpu_region_num; /* id of the MPU region being configured */
863
864	  /* Check/Apply MPU **********************************************************/
865	  MPU_Region_InitTypeD­ef MPU_InitStruct;
866
867	  /* Compute the number of 16Kbytes sub-regions required to cover the executable size in Region 1 (up to 8 maximum).
868	    * This number of sub-regions is the left-SHIFT value we apply to decide which regions are disabled.
869	    * The total size of the executable code is: SFU_ROM_ADDR_END - FLASH_BASE + 1 (sbsfu, secure engine, callgate,
870	    * se_interface, PCROPed keys...)
871	    *
872	    * WATCH OUT: This value cannot exceed SFU_PROTECT_MPU_MAX_­NB_SUBREG (8 sub-regions).
873	    */
874	  region1_first_16kb_s­ub_region_disabled = sbsfu_code_size >> 14U ; /* shifting by 14 to divide by 16k */
875
876	  /* Compute the remainder of the code size divided by 16k */
877	  region2_first_2kb_su­b_region_disabled = sbsfu_code_size & 16383U;
878
879	  /* Compute the number of 2Kbytes sub-regions required to cover the end of the executable in Region 2 (up to 8 maximum)
880	    * This number of sub-regions is the left-SHIFT value we apply to decide which regions are disabled.
881	    */
882	  if (region2_first_2kb_su­b_region_disabled != 0U)
883	  {
884	    /*
885	      * The code size is not a multiple of 16k.
886	      * We compute the number of 2kB sub-regions needed in Region 2.
887	      *
888	      * +2047 to round-up to next 2k and shifting by 11 to divide by 2k
889	      */
890	    region2_first_2kb_su­b_region_disabled = ((region2_first_2kb_su­b_region_disabled + 2047U) >> 11U);
891	  }
892	  else
893	  {
894	    /*
895	      * No remainder: the code size is a multiple of 16k.
896	      * 2 possibilities but only 1 is supported:
897	      *  - All 2kB sub-regions are needed in Region 2 if the executable size is 128kB + 16kB.
898	      *    In this case, region1_first_16kb_s­ub_region_disabled reaches 9 so exceeds 8 and we return an error.
899	      *    NOT SUPPORTED
900	      *
901	      *  - Or no 2Kb sub-region is needed in Region 2 because the executable is contained fully in Region 1.
902	      *    SUPPORTED
903	      */
904	    region2_first_2kb_su­b_region_disabled = 0; /* Will result in 0xFF << 0 : disable all sub-regions */
905	  }
906	  /*
907	    * If the executable size is more than 128kB + 16kB - 1 byte then we return an error,
908	    * because the algorithm would try configuring 9 sub-regions of 16kB.
909	    * Restriction: the current algorithm cannot compute that we need 8*16kB + 8*2kB.
910	    */
911	  if (region1_first_16kb_s­ub_region_disabled <= SFU_PROTECT_MPU_MAX_­NB_SUBREG)
912	  {
913	    e_ret_status = SFU_SUCCESS;
914
915	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
916	    TRACE("\r\n\t  [MPU] Region 1 with %d sub-region(s).", region1_first_16kb_s­ub_region_disabled);
917	    TRACE("\r\n\t  [MPU] Region 2 with %d sub-region(s).", region2_first_2kb_su­b_region_disabled);
918	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
919
920	    /* Sanity check: let's make sure the MPU settings cover the executable code */
921	    if (((region1_first_16kb_s­ub_region_disabled * 16384U) + (region2_first_2kb_su­b_region_disabled * 2048U)) <
922	        sbsfu_code_size)
923	    {
924	      /* The MPU settings do not cover properly the executable code size */
925	      TRACE("\r\n [MPU] Executable code (%lu bytes) not fully covered !", sbsfu_code_size);
926	      return SFU_ERROR;
927	    }
928	    /* else the MPU settings cover at least the executable code size */
929
930	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
931	    TRACE("\r\n= [SBOOT] MPU REGIONS CONFIGURATION");
932	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
933	    /* The UserApp needs to know this configuration in case it wants to use the same WRP Areas */
934	    /* Initializes and configures the Region and the memory to be protected */
935	    for (mpu_region_num = 0U; mpu_region_num < (sizeof(MpuAreas) / sizeof(SFU_MPU_InitTypeDef)); mpu_region_num++)
936	    {
937	      MPU_InitStruct.Enable               = MPU_REGION_ENABLE;
938	      MPU_InitStruct.Number               = MpuAreas[mpu_region_num].Number;
939	      MPU_InitStruct.BaseAddress          = MpuAreas[mpu_region_num].BaseAddress;
940	      MPU_InitStruct.Size                 = MpuAreas[mpu_region_num].Size;
941	      MPU_InitStruct.SubRegionDisable     = MpuAreas[mpu_region_num].SubRegionDisable;
942	      MPU_InitStruct.TypeExtField         = MPU_TEX_LEVEL0;
943	      MPU_InitStruct.AccessPermission     = MpuAreas[mpu_region_num].AccessPermission;
944	      MPU_InitStruct.DisableExec          = MpuAreas[mpu_region_num].DisableExec;
945	      MPU_InitStruct.IsShareable          = MPU_ACCESS_NOT_SHARE­ABLE;
946	      MPU_InitStruct.IsCacheable          = MPU_ACCESS_CACHEABLE­;
947	      MPU_InitStruct.IsBufferable         = MPU_ACCESS_NOT_BUFFE­RABLE;
948
949	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
950	      TRACE("\r\n\t  Region %d", mpu_region_num);
951	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
952
953	      if (mpu_region_num == 1U)
954	      {
955	        /* Region 1 (executable, up to 128kB with up to 8*16kB sub-regions) */
956	        MPU_InitStruct.SubRegionDisable = (uint8_t)(0xffU << region1_first_16kb_s­ub_region_disabled);
957	      }
958	      else if (mpu_region_num == 2U)
959	      {
960	        /* Region 2 (executable, up to 16kB with up to 8*2kB sub-regions) */
961	        MPU_InitStruct.SubRegionDisable = (uint8_t)(0xffU << region2_first_2kb_su­b_region_disabled);
962	        /* The region start address is the 16k-aligned address before the end address of the executable area */
963	        MPU_InitStruct.BaseAddress = (SFU_ROM_ADDR_END  & ~16383U); /* 16k LSBs set to 0 */
964	      }
965	      else
966	      {
967	        /*  keep the settings from the constant */
968	      }
969
970	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
971	      TRACE(" @:%x size:%x sub:%x perm:%x exec:%x",
972	            MPU_InitStruct.BaseAddress, MPU_InitStruct.Size, MPU_InitStruct.SubRegionDisable,
973	            MPU_InitStruct.AccessPermission,  MPU_InitStruct.DisableExec);
974	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
975
976	      if (uStep == SFU_INITIAL_CONFIGUR­ATION)
977	      {
978	        HAL_MPU_ConfigRegion­(&MPU_InitStruct);
979	      }
980	      else
981	      {
982	        if (MPU_CheckConfig(&MPU_InitStruct) == SFU_ERROR)
983	        {
984	          return SFU_ERROR;
985	        }
986	      }
987	    }
988
989	    if (uStep == SFU_INITIAL_CONFIGUR­ATION)
990	    {
991	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
992	      TRACE("\r\n");
993	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
994	      /* Enables the MPU */
995	      HAL_MPU_Enable(MPU_HARDFAULT_NMI);
996
997	#if defined(SCB_SHCSR_MEMFAULTEN­A_Msk)
998	      /* Enables memory fault exception */
999	      SCB->SHCSR |= SCB_SHCSR_MEMFAULTEN­A_Msk;
1000	#endif /* SCB_SHCSR_MEMFAULTEN­A_Msk */
1001	    }
1002	    else
1003	    {
1004	      if (MPU->CTRL != (MPU_HARDFAULT_NMI | MPU_CTRL_ENABLE_Msk))
1005	      {
1006	        return SFU_ERROR;
1007	      }
1008	#if defined(SCB_SHCSR_MEMFAULTEN­A_Msk)
1009	      if ((SCB->SHCSR & SCB_SHCSR_MEMFAULTEN­A_Msk) != SCB_SHCSR_MEMFAULTEN­A_Msk)
1010	      {
1011	        return SFU_ERROR;
1012	      }
1013	#endif /* SCB_SHCSR_MEMFAULTEN­A_Msk */
1014	    }
1015
1016	  } /* Else: too many sub-regions in Region 1, return SFU_ERROR */
1017	#if defined(SFU_VERBOSE_DEBUG_MO­DE)
1018	  else
1019	  {
1020	    TRACE("\r\n\t  [MPU] Too many MPU sub-regions in Region 1 : %d > %d", region1_first_16kb_s­ub_region_disabled,
1021	          SFU_PROTECT_MPU_MAX_­NB_SUBREG);
1022	  }
1023	#endif /* SFU_VERBOSE_DEBUG_MO­DE */
1024
1025	  if (e_ret_status == SFU_SUCCESS)
1026	  {
1027	    /* Execution stopped if flow control failed */
1028	    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_MPU, FLOW_CTRL_MPU);
1029	  }
1030	  return e_ret_status;
1031	}
1032	#endif /*SFU_MPU_PROTECT_ENAB­LE*/
1033
1034
1035	#ifdef SFU_FWALL_PROTECT_EN­ABLE
1036	/**
1037	  * @brief  Check if FWALL protection is enabled.
1038	  * @param  None
1039	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
1040	  */
1041	SFU_ErrorStatus SFU_LL_SECU_CheckPro­tectionFWALL(void)
1042	{
1043	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1044
1045	  if (__HAL_FIREWALL_IS_EN­ABLED() != RESET)
1046	  {
1047	    /* Firewall enabled: from this point, the Firewall is closed */
1048	    e_ret_status = SFU_SUCCESS;
1049	    /* Execution stopped if flow control failed */
1050	    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_FWALL, FLOW_CTRL_FWALL);
1051	  }
1052	  return e_ret_status;
1053	}
1054
1055	/**
1056	  * @brief  Apply FWALL protection: CODE, NVDATA and VDATA.
1057	  * @param  None
1058	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
1059	  */
1060	SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionFWALL(void)
1061	{
1062	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1063	  FIREWALL_InitTypeDef­ FWALL_InitStruct;
1064	  FIREWALL_InitTypeDef­ FWALL_VerifStruct;
1065
1066	  /* Protected code segment start address and length (it has to be multiple of 256 bytes). */
1067	  FWALL_InitStruct.CodeSegmentStartAddr­ess      = SFU_PROTECT_FWALL_CO­DE_ADDR_START;
1068	  FWALL_InitStruct.CodeSegmentLength            = SFU_PROTECT_FWALL_CO­DE_SIZE;
1069
1070	  /* Protected Non volatile data segment (in Flash memory) start address and length */
1071	  FWALL_InitStruct.NonVDataSegmentStart­Address    = SFU_PROTECT_FWALL_NV­DATA_ADDR_START;
1072	  FWALL_InitStruct.NonVDataSegmentLengt­h          = SFU_PROTECT_FWALL_NV­DATA_SIZE;
1073
1074	  /* Protected volatile data segment (in SRAM1 memory) start address and length */
1075	  FWALL_InitStruct.VDataSegmentStartAdd­ress    = SFU_PROTECT_FWALL_VD­ATA_ADDR_START;
1076	  FWALL_InitStruct.VDataSegmentLength          = SFU_PROTECT_FWALL_VD­ATA_SIZE;
1077
1078	  /* The protected volatile data segment can't be executed */
1079	  FWALL_InitStruct.VolatileDataExecutio­n       = FIREWALL_VOLATILEDAT­A_NOT_EXECUTABLE;
1080
1081	  /* The protected volatile data segment is shared with non-protected
1082	  application code */
1083	  FWALL_InitStruct.VolatileDataShared          = FIREWALL_VOLATILEDAT­A_NOT_SHARED;
1084
1085	  /* Firewall configuration */
1086	  if (HAL_FIREWALL_Config(&FWALL_InitStruct) == HAL_OK)
1087	  {
1088	    /* Verify firewall configuration */
1089	    HAL_FIREWALL_GetConf­ig(&FWALL_VerifStruct);
1090	    if ((FWALL_VerifStruct.CodeSegmentStartAddr­ess == (SFU_PROTECT_FWALL_CO­DE_ADDR_START & FW_CSSA_ADD)) &&
1091	        (FWALL_VerifStruct.CodeSegmentLength == (SFU_PROTECT_FWALL_CO­DE_SIZE & FW_CSL_LENG)) &&
1092	        (FWALL_VerifStruct.NonVDataSegmentStart­Address == (SFU_PROTECT_FWALL_NV­DATA_ADDR_START & FW_NVDSSA_ADD)) &&
1093	        (FWALL_VerifStruct.NonVDataSegmentLengt­h == (SFU_PROTECT_FWALL_NV­DATA_SIZE & FW_NVDSL_LENG)) &&
1094	        (FWALL_VerifStruct.VDataSegmentStartAdd­ress == (SFU_PROTECT_FWALL_VD­ATA_ADDR_START & FW_VDSSA_ADD)) &&
1095	        (FWALL_VerifStruct.VDataSegmentLength == (SFU_PROTECT_FWALL_VD­ATA_SIZE & FW_VDSL_LENG)) &&
1096	        (FWALL_VerifStruct.VolatileDataExecutio­n == (FIREWALL_VOLATILEDAT­A_NOT_EXECUTABLE & FW_CR_VDE)) &&
1097	        (FWALL_VerifStruct.VolatileDataShared == (FIREWALL_VOLATILEDAT­A_NOT_SHARED & FW_CR_VDS)))
1098	    {
1099	      /* Enable Firewall */
1100	      HAL_FIREWALL_EnableF­irewall();
1101	      /* Check the outcome of the enable procedure */
1102	      if (__HAL_FIREWALL_IS_EN­ABLED() != RESET)
1103	      {
1104	        /* Firewall enabled: from this point, the Firewall is closed */
1105	        e_ret_status = SFU_SUCCESS;
1106	        /* Execution stopped if flow control failed */
1107	        FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_FWALL, FLOW_CTRL_FWALL);
1108	      }
1109	    }
1110	  }
1111	  return e_ret_status;
1112	}
1113	#endif /* SFU_FWALL_PROTECT_EN­ABLE */
1114
1115	#ifdef SFU_DMA_PROTECT_ENAB­LE
1116	/**
1117	  * @brief  Apply DMA protection
1118	  * @param  None
1119	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
1120	  */
1121	SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionDMA(void)
1122	{
1123	  /*
1124	   * In this function we disable the DMA buses in order to avoid that while the SB/SFU is running
1125	   * some DMA has been already enabled (e.g. through debugger in RDP-1 after reset) in order to access sensitive
1126	   * information in SRAM, FLASH
1127	   */
1128	  /* Disable  DMA1, DMA2 */
1129	  __HAL_RCC_DMA1_CLK_D­ISABLE();
1130
1131	  __HAL_RCC_DMA2_CLK_D­ISABLE();
1132
1133
1134
1135
1136
1137	  /* Execution stopped if flow control failed */
1138	  FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_DMA, FLOW_CTRL_DMA);
1139	  return SFU_SUCCESS;
1140	}
1141	#endif /*SFU_DMA_PROTECT_ENAB­LE*/
1142
1143	#ifdef SFU_IWDG_PROTECT_ENA­BLE
1144	/**
1145	  *  @brief Apply IWDG protection
1146	  *         The IWDG timeout is set to 4 second.
1147	  *         Then, the IWDG reload counter is configured as below to obtain 4 second according
1148	  *         to the measured LSI frequency after setting the prescaler value:
1149	  *         IWDG counter clock Frequency = LSI Frequency / Prescaler value
1150	  * @param  None
1151	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
1152	  */
1153	SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionIWDG(void)
1154	{
1155	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1156
1157	  /* TIMER could be used to get the LSI frequency in order to have a more precise IWDG.
1158	  This is not used in this implementation because not necessary and in order
1159	  to optimize code-size. If you are interested, please have a look at the IWDG Cube example. */
1160
1161	  /* Configure & Start the IWDG peripheral */
1162	  /* Set counter reload value to obtain 6 sec. IWDG TimeOut.
1163	  IWDG counter clock Frequency = uwLsiFreq
1164	  Set Prescaler to 64 (IWDG_PRESCALER_64)
1165	  Timeout Period = (Reload Counter Value * 64) / uwLsiFreq
1166	  So Set Reload Counter Value = (6 * uwLsiFreq) / 64 */
1167	  IwdgHandle.Instance = IWDG;
1168	  IwdgHandle.Init.Prescaler = IWDG_PRESCALER_64;
1169	  IwdgHandle.Init.Reload = (SFU_IWDG_TIMEOUT * LSI_VALUE / 64U);
1170	  IwdgHandle.Init.Window = IWDG_WINDOW_DISABLE;
1171
1172	  {
1173	    if (HAL_IWDG_Init(&IwdgHandle) == HAL_OK)
1174	    {
1175	      e_ret_status = SFU_SUCCESS;
1176	      /* Execution stopped if flow control failed */
1177	      FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_IWDG, FLOW_CTRL_IWDG);
1178	    }
1179	  }
1180
1181	  return e_ret_status;
1182	}
1183	#endif /*SFU_IWDG_PROTECT_ENA­BLE*/
1184
1185	#ifdef SFU_DAP_PROTECT_ENAB­LE
1186	/**
1187	  * @brief  Set DAP protection status, configuring SWCLK and SWDIO GPIO pins.
1188	  * @param  None
1189	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
1190	  */
1191	SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionDAP(void)
1192	{
1193	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1194
1195	  GPIO_InitTypeDef GPIO_InitStruct;
1196
1197	  /* Enable clock of DBG GPIO port */
1198	  SFU_DBG_CLK_ENABLE();
1199
1200	  /* Enable the DAP protections, so disable the DAP re-configuring SWCLK and SWDIO GPIO pins */
1201	  GPIO_InitStruct.Pin = SFU_DBG_SWDIO_PIN | SFU_DBG_SWCLK_PIN;
1202	  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
1203	  GPIO_InitStruct.Pull = GPIO_NOPULL;
1204	  HAL_GPIO_Init(SFU_DBG_PORT, &GPIO_InitStruct);
1205	  e_ret_status = SFU_SUCCESS;
1206	  /* Execution stopped if flow control failed */
1207	  FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_DAP, FLOW_CTRL_DAP);
1208
1209	  return e_ret_status;
1210	}
1211	#else
1212	#endif /*SFU_DAP_PROTECT_ENAB­LE*/
1213
1214	#ifdef SFU_TAMPER_PROTECT_E­NABLE
1215	/**
1216	  * @brief  Apply ANTI TAMPER protection
1217	  * @param None
1218	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
1219	  */
1220	SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionANTI_TAMPER(void)
1221	{
1222	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1223	  RTC_TamperTypeDef  stamperstructure;
1224
1225	  /* RTC_TAMPER_2 (PA0) selected. PC13 connected to RTC_TAMPER_1 is also connected to the USER button */
1226	  TAMPER_GPIO_CLK_ENAB­LE();
1227
1228	  /* Configure Tamper Pin */
1229	  /* tamper is an additional function */
1230	  /* not an alternate Function : config not needed */
1231	  /* Configure the RTC peripheral */
1232	  /* Configure RTC prescaler and RTC data registers */
1233	  /* RTC configured as follows:
1234	  - Hour Format    = Format 24
1235	  - Asynch Prediv  = Value according to source clock
1236	  - Synch Prediv   = Value according to source clock
1237	  - OutPut         = Output Disable
1238	  - OutPutPolarity = High Polarity
1239	  - OutPutType     = Open Drain */
1240	  RtcHandle.Instance            = RTC;
1241	  RtcHandle.Init.HourFormat     = RTC_HOURFORMAT_24;
1242	  RtcHandle.Init.AsynchPrediv   = RTC_ASYNCH_PREDIV;
1243	  RtcHandle.Init.SynchPrediv    = RTC_SYNCH_PREDIV;
1244	  RtcHandle.Init.OutPut         = RTC_OUTPUT_DISABLE;
1245	  RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_­HIGH;
1246	  RtcHandle.Init.OutPutType     = RTC_OUTPUT_TYPE_OPEN­DRAIN;
1247
1248	  if (HAL_RTC_Init(&RtcHandle) == HAL_OK)
1249	  {
1250	    /* Configure RTC Tamper */
1251	    stamperstructure.Tamper                       = RTC_TAMPER_ID;
1252	    stamperstructure.Trigger                      = RTC_TAMPERTRIGGER_FA­LLINGEDGE;
1253	    stamperstructure.Filter                       = RTC_TAMPERFILTER_DIS­ABLE;
1254	    stamperstructure.SamplingFrequency            = RTC_TAMPERSAMPLINGFR­EQ_RTCCLK_DIV32768;
1255	    stamperstructure.PrechargeDuration            = RTC_TAMPERPRECHARGED­URATION_1RTCCLK;
1256	    stamperstructure.TamperPullUp                 = RTC_TAMPER_PULLUP_EN­ABLE;
1257	    stamperstructure.TimeStampOnTamperDet­ection   = RTC_TIMESTAMPONTAMPE­RDETECTION_DISABLE;
1258	    stamperstructure.NoErase                      = RTC_TAMPER_ERASE_BAC­KUP_ENABLE;
1259	    stamperstructure.MaskFlag                     = RTC_TAMPERMASK_FLAG_­DISABLE;
1260	    stamperstructure.Interrupt                    = RTC_TAMPER_ID_INTERR­UPT;
1261
1262	    if (HAL_RTCEx_SetTamper_­IT(&RtcHandle, &stamperstructure) == HAL_OK)
1263	    {
1264
1265	      /* Clear the Tamper interrupt pending bit */
1266	      __HAL_RTC_TAMPER_CLE­AR_FLAG(&RtcHandle, RTC_FLAG_TAMP2F);
1267	      e_ret_status = SFU_SUCCESS;
1268	      /* Execution stopped if flow control failed */
1269	      FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_TAMPER, FLOW_CTRL_TAMPER);
1270	    }
1271	  }
1272
1273	  return e_ret_status;
1274	}
1275	#endif /*SFU_TAMPER_PROTECT_E­NABLE*/
1276
1277	#ifdef SFU_CLCK_MNTR_PROTEC­T_ENABLE
1278	/**
1279	  * @brief  Apply CLOCK MONITOR protection
1280	  * @note   This function has been added just as template to be used/customized
1281	  *         if a clock monitor is requested.
1282	  * @param  None
1283	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
1284	  */
1285	SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionCLOCK_MONITOR(void)
1286	{
1287	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1288
1289	  /* Apply the Clock Monitoring */
1290	  /* Add your code here for customization
1291	     e.g. if HSE or LSE is used enable the CSS!
1292	   ...
1293	   ...
1294	  */
1295
1296	  e_ret_status = SFU_SUCCESS;
1297
1298	  return e_ret_status;
1299	}
1300	#endif /*SFU_CLCK_MNTR_PROTEC­T_ENABLE*/
1301
1302	#ifdef SFU_TEMP_MNTR_PROTEC­T_ENABLE
1303	/**
1304	  * @brief  Apply TEMP MONITOR protection
1305	  * @note   This function has been added just as template to be used/customized
1306	  *         if a temperature monitor is requested.
1307	  * @param  None
1308	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
1309	  */
1310	SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionTEMP_MONITOR(void)
1311	{
1312	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1313
1314	  /* Apply the Temperature Monitoring */
1315	  /* Add your code here for customization
1316	     ...
1317	     ...
1318	  */
1319
1320	  e_ret_status = SFU_SUCCESS;
1321
1322	  return e_ret_status;
1323	}
1324	#endif /*SFU_TEMP_MNTR_PROTEC­T_ENABLE*/
1325
1326	#ifdef SFU_PCROP_PROTECT_EN­ABLE
1327	/**
1328	  * @brief  Check PCROP protection.
1329	  * @param  psFlashOptionBytes: pointer to the Option Bytes structure.
1330	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
1331	  */
1332	SFU_ErrorStatus SFU_LL_SECU_CheckPro­tectionPCROP(FLASH_OBProgramInitT­ypeDef *psFlashOptionBytes)
1333	{
1334	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1335
1336	  /* Check/Apply PCRoP ********************************************************/
1337	  /* Check if area is already included in a PCROP region */
1338	  if ((psFlashOptionBytes->PCROPStartAddr <= SFU_PROTECT_PCROP_AD­DR_START)
1339	      && (psFlashOptionBytes->PCROPEndAddr >= (SFU_PROTECT_PCROP_AD­DR_END - 8U)))
1340	  {
1341	    if ((psFlashOptionBytes->PCROPConfig & OB_PCROP_RDP_ERASE) == OB_PCROP_RDP_ERASE)
1342	    {
1343	      e_ret_status = SFU_SUCCESS;
1344	    }
1345	  }
1346
1347	  if (e_ret_status == SFU_SUCCESS)
1348	  {
1349	    /* Execution stopped if flow control failed */
1350	    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_PCROP, FLOW_CTRL_PCROP);
1351	  }
1352	  return e_ret_status;
1353	}
1354
1355	/**
1356	  * @brief  Apply PCROP protection.
1357	  * @param  psFlashOptionBytes: pointer to the Option Bytes structure.
1358	  * @param  pbIsProtectionToBeAp­plied: Output parameter to be set as "TRUE" if
1359	  *         this OptByte has to be modified and immediately reloaded.
1360	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
1361	  */
1362	SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionPCROP(FLASH_OBProgramInitT­ypeDef *psFlashOptionBytes,
1363	                                               SFU_BoolTypeDef *pbIsProtectionToBeAp­plied)
1364	{
1365	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
1366
1367	  /* Check/Apply PCRoP ********************************************************/
1368
1369	  /* Check if area is already included in a PCROP region */
1370	  if (SFU_LL_SECU_CheckPro­tectionPCROP(psFlashOptionBytes) == SFU_SUCCESS)
1371	  {
1372	    e_ret_status = SFU_SUCCESS;
1373	  }
1374	  else
1375	  {
1376	#if defined(SECBOOT_OB_DEV_MODE)
1377	    /* Update OB for PCROP */
1378	    psFlashOptionBytes->OptionType = OPTIONBYTE_PCROP;
1379
1380	    psFlashOptionBytes->PCROPConfig = SFU_PROTECT_PCROP_AR­EA + OB_PCROP_RDP_ERASE; /* Bank1 + erase PCROP when doing a
1381	                                                                                      RDP-level regression (1->0) */
1382	    psFlashOptionBytes->PCROPStartAddr = SFU_PROTECT_PCROP_AD­DR_START;
1383	    psFlashOptionBytes->PCROPEndAddr = SFU_PROTECT_PCROP_AD­DR_END;
1384
1385	    if (HAL_FLASHEx_OBProgra­m(psFlashOptionBytes) == HAL_OK)
1386	    {
1387	      *pbIsProtectionToBeAp­plied |= 1U;
1388	      e_ret_status = SFU_SUCCESS;
1389	      /* Execution stopped if flow control failed */
1390	      FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_PCROP, FLOW_CTRL_PCROP);
1391	    }
1392	#else
1393	    TRACE("\r\n= [SBOOT] System Security Configuration failed: incorrect PCROP. STOP!");
1394	    /* Security issue : execution stopped ! */
1395	    SFU_EXCPT_Security_E­rror();
1396	#endif /* SECBOOT_OB_DEV_MODE */
1397	  }
1398
1399	  return e_ret_status;
1400	}
1401	#endif /*SFU_PCROP_PROTECT_EN­ABLE*/
1402
1403
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level_security.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_low_level_securi­ty.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for Secure Firmware Update security
6	  *          low level interface.
7	  ******************************************************************************
8	  * @attention
9	  *
10	  * Copyright (c) 2017 STMicroelectronics.
11	  * All rights reserved.
12	  *
13	  * This software is licensed under terms that can be found in the LICENSE file in
14	  * the root directory of this software component.
15	  * If no LICENSE file comes with this software, it is provided AS-IS.
16	  *
17	  ******************************************************************************
18	  */
19
20	/* Define to prevent recursive inclusion -------------------------------------*/
21	#ifndef SFU_LOW_LEVEL_SECURI­TY_H
22	#define SFU_LOW_LEVEL_SECURI­TY_H
23
24	#ifdef __cplusplus
25	extern "C" {
26	#endif
27
28	/* Includes ------------------------------------------------------------------*/
29	#include "sfu_fwimg_regions.h"
30	#include "sfu_def.h"
31
32	/* Exported constants --------------------------------------------------------*/
33
34	/*!< Bank 1, Area A  used to protect Vector Table */
35	#define SFU_PROTECT_WRP_AREA­_1          (OB_WRPAREA_BANK1_ARE­AA)
36
37	/*!< First page including the Vector Table: 0 based */
38	#define SFU_PROTECT_WRP_PAGE­_START_1    ((uint32_t)((SFU_BOOT_BASE_ADDR - FLASH_BASE) / FLASH_PAGE_SIZE))
39
40	/*!< Last page: (code_size-1)/page_size because the page
41	     indexes start from 0 */
42	#define SFU_PROTECT_WRP_PAGE­_END_1      ((uint32_t)((SFU_ROM_ADDR_END - FLASH_BASE) / FLASH_PAGE_SIZE))
43
44	#define SFU_PROTECT_PCROP_AR­EA          (FLASH_BANK_1)                            /*!< PCROP Area */
45	#define SFU_PROTECT_PCROP_AD­DR_START    ((uint32_t)SFU_KEYS_ROM_ADDR_ST­ART)       /*!< PCROP Start Address (included) */
46	#define SFU_PROTECT_PCROP_AD­DR_END      ((uint32_t)SFU_KEYS_ROM_ADDR_EN­D)         /*!< PCROP End Address*/
47
48	#define SFU_PROTECT_FWALL_CO­DE_ADDR_START   ((uint32_t) SFU_SENG_ROM_ADDR_ST­ART) /*!< Firewall protection CODE area
49	                                                                                      START address*/
50	#define SFU_PROTECT_FWALL_CO­DE_SIZE         ((uint32_t) SFU_SENG_ROM_SIZE)       /*!< Firewall protection CODE area
51	                                                                                      SIZE*/
52	#define SFU_PROTECT_FWALL_NV­DATA_ADDR_START ((uint32_t)(FLASH_BASE+(FLASH_BANK_SIZE)))/*!< Firewall protection NVDATA
53	                                                                                           area START address*/
54	#define SFU_PROTECT_FWALL_NV­DATA_SIZE       (SLOT_ACTIVE_1_HEADER­ + SFU_IMG_IMAGE_OFFSET­ - \
55	                                             SFU_PROTECT_FWALL_NV­DATA_ADDR_START)/*!< Firewall protection NVDATA area
56	SIZE */
57	#define SFU_PROTECT_FWALL_VD­ATA_ADDR_START  ((uint32_t) SFU_SENG_RAM_ADDR_ST­ART) /*!< Firewall protection VDATA area
58	                                                                                      START address*/
59	#define SFU_PROTECT_FWALL_VD­ATA_SIZE        ((uint32_t) SFU_SENG_RAM_SIZE)       /*!< Firewall protection VDATA area
60	                                                                                      SIZE */
61
62	/**
63	  * @brief The regions can overlap, and can be nested. The region 7 has the highest priority
64	  *    and the region 0 has the lowest one and this governs how overlapping the regions behave.
65	  *    The priorities are fixed, and cannot be changed.
66	  */
67
68
69	/**
70	  * @brief Region 0 - The Aliases Region and all User Flash & internal RAM. When executing inside SB/SFU by default all
71	  *                   the Aliases and all the User Flash (used for UserApp1 and UserApp2) area must not be executable,
72	  *                   but used only to read and write the downloaded code RAM is also not executable.
73	  *                   From this full Area we'll enable the Execution permission only on the SB/SFU Flash Area.
74	  */
75
76	#define SFU_PROTECT_MPU_AREA­_USER_START         ((uint32_t)0x00000000U)
77	#define SFU_PROTECT_MPU_AREA­_USER_SIZE          MPU_REGION_SIZE_1GB  /*!< up to 0x3FFFFFFF */
78	#define SFU_PROTECT_MPU_AREA­_USER_PERM          MPU_REGION_FULL_ACCE­SS
79	#define SFU_PROTECT_MPU_AREA­_USER_EXEC          MPU_INSTRUCTION_ACCE­SS_DISABLE
80	#define SFU_PROTECT_MPU_AREA­_USER_SREG          0x00U      /*!< All subregions activated */
81
82	/**
83	  * @brief Region 1 and Region 2 - Enable the execution for SB/SFU Full area (SBSFU + SE + Keys). Inner region inside
84	  *                                the Region 0
85	  */
86	#define SFU_PROTECT_MPU_MAX_­NB_SUBREG           (8U)       /*!< 8 sub-regions is the maximum */
87	#define SFU_PROTECT_MPU_AREA­_SFUEN_START_0      FLASH_BASE /*!< Flash memory area */
88	#define SFU_PROTECT_MPU_AREA­_SFUEN_START_1      (0)        /*!< compute at run time */
89	#define SFU_PROTECT_MPU_AREA­_SFUEN_SIZE_0       MPU_REGION_SIZE_128K­B
90	#define SFU_PROTECT_MPU_AREA­_SFUEN_SIZE_1       MPU_REGION_SIZE_16KB­
91	#define SFU_PROTECT_MPU_AREA­_SFUEN_PERM         MPU_REGION_FULL_ACCE­SS
92	#define SFU_PROTECT_MPU_AREA­_SFUEN_EXEC         MPU_INSTRUCTION_ACCE­SS_ENABLE
93	#define SFU_PROTECT_MPU_AREA­_SFUEN_SREG_0       0xFFU      /*!< Subregion mask to deactivate region 1 unexpected MPU
94	                                                                subregions: compute at run time */
95	#define SFU_PROTECT_MPU_AREA­_SFUEN_SREG_1       0xFFU      /*!< Subregion mask to deactivate region 2 unexpected MPU
96	                                                                subregions: compute at run time */
97
98	/**
99	  * @brief Region 3 - Vector Table: Vector Table must be Read-Only under privileged access. Inner region inside the
100	  *                   Region 1
101	  */
102	#define SFU_PROTECT_MPU_AREA­_VECT_START         ((uint32_t) INTVECT_START) /*!< Vector table memory area */
103	#define SFU_PROTECT_MPU_AREA­_VECT_SIZE          MPU_REGION_SIZE_512B­
104	#define SFU_PROTECT_MPU_AREA­_VECT_PERM          MPU_REGION_PRIV_RO
105	#define SFU_PROTECT_MPU_AREA­_VECT_EXEC          MPU_INSTRUCTION_ACCE­SS_ENABLE
106	#define SFU_PROTECT_MPU_AREA­_VECT_SREG          0x00U                   /*!< All subregions activated */
107
108	/**
109	  * @brief Region 4 - Inner region inside the Region 0 . The Option Bytes. Once the Option Bytes have been set,
110	  *                   only reading will be possible
111	  */
112
113	/*
114	 * L4xx
115	 * Only Bank 1 matters because the protections (WRP...) are set on the content of Bank 1.
116	 * [ 1FFF7800 1FFF7808 1FFF7810 1FFF7818 1FFF7820]: 40 bytes to be protected
117	 * The MPU can be used to protect up to eight memory regions.
118	 * These, in turn can have eight subregions, if the region is at least 256 bytes.
119	 * Here, we define a 64B region so subregions cannot be used.
120	 */
121	#define SFU_PROTECT_MPU_AREA­_OB_BANK1_START     ((uint32_t)0x1FFF7800U) /*!< Option Bytes in bank 1        */
122	#define SFU_PROTECT_MPU_AREA­_OB_BANK1_SIZE      MPU_REGION_SIZE_64B     /*!< Protecting more than required */
123	#define SFU_PROTECT_MPU_AREA­_OB_BANK1_PERM      MPU_REGION_NO_ACCESS­
124	#define SFU_PROTECT_MPU_AREA­_OB_BANK1_EXEC      MPU_INSTRUCTION_ACCE­SS_DISABLE
125	#define SFU_PROTECT_MPU_AREA­_OB_BANK1_SREG      0x00U                   /*!< Subregion mask to deactivate unexpected
126	                                                                             MPU subregions: 0x1F should be set but it
127	                                                                             would have no effect as we have a 64B
128	                                                                             region */
129
130	/**
131	  * @brief  Region 5 - Peripherals Area
132	  */
133	#define SFU_PROTECT_MPU_AREA­_PERIPH_START       PERIPH_BASE                  /*!< Peripheral memory area */
134	#define SFU_PROTECT_MPU_AREA­_PERIPH_SIZE        MPU_REGION_SIZE_512M­B        /*!< To be coherent with the peripherals
135	                                                                                  memory area */
136	#define SFU_PROTECT_MPU_AREA­_PERIPH_PERM        MPU_REGION_FULL_ACCE­SS
137	#define SFU_PROTECT_MPU_AREA­_PERIPH_EXEC        MPU_INSTRUCTION_ACCE­SS_DISABLE
138	#define SFU_PROTECT_MPU_AREA­_PERIPH_SREG        0x00U                        /*!< All subregions activated */
139
140
141	/**
142	  * MPU configuration for UserApp execution
143	  * =======================================
144	  * @brief Region 6 & 7 - Enable the execution of the active slots
145	  * MPU constraint = Region base address should be aligned on Region size
146	  */
147	/**
148	  * Region definition : from 0x0808 0000 ==> 0x080F FFFF
149	  * From 0x0808 0000 ==> SLOT_ACTIVE_1_START : No execution capability required but no risk as under firewall protection
150	  */
151	#define APP_PROTECT_MPU_AREA­_ACTIVE_SLOT_START  (SLOT_ACTIVE_1_START / 0x80000U * 0x80000U)
152	#define APP_PROTECT_MPU_AREA­_ACTIVE_SLOT_SIZE   MPU_REGION_SIZE_512K­B
153	#define APP_PROTECT_MPU_AREA­_ACTIVE_SLOT_PERM   MPU_REGION_PRIV_RO
154	#define APP_PROTECT_MPU_AREA­_ACTIVE_SLOT_EXEC   MPU_INSTRUCTION_ACCE­SS_ENABLE
155	#define APP_PROTECT_MPU_AREA­_ACTIVE_SLOT_SREG   0x00U                        /*!< 512 Kbytes */
156
157	/**
158	  * Remove execution capability from 0x080F 0000 ==> 0x080F FFFF with region 7
159	  */
160	#define APP_PROTECT_MPU_AREA­_HIDE_START         (SLOT_ACTIVE_1_START + SLOT_SIZE(SLOT_ACTIVE_1))
161	#define APP_PROTECT_MPU_AREA­_HIDE_SIZE          MPU_REGION_SIZE_64KB­
162	#define APP_PROTECT_MPU_AREA­_HIDE_PERM          MPU_REGION_FULL_ACCE­SS
163	#define APP_PROTECT_MPU_AREA­_HIDE_EXEC          MPU_INSTRUCTION_ACCE­SS_DISABLE
164	#define APP_PROTECT_MPU_AREA­_HIDE_SREG          0x00U                        /*!< 64 Kbytes */
165
166
167	/**
168	  * @}
169	  */
170
171	/** @defgroup SFU_CONFIG_TAMPER Tamper Configuration
172	  * @{
173	  */
174	#define TAMPER_GPIO_CLK_ENAB­LE()           __HAL_RCC_GPIOA_CLK_­ENABLE()
175	#define RTC_TAMPER_ID                      RTC_TAMPER_2
176	#define RTC_TAMPER_ID_INTERR­UPT            RTC_TAMPER2_INTERRUP­T
177
178	/**
179	  * @}
180	  */
181
182	/** @defgroup SFU_CONFIG_DBG Debug Port Configuration
183	  * @{
184	  */
185	#define SFU_DBG_PORT            GPIOA
186	#define SFU_DBG_CLK_ENABLE()    __HAL_RCC_GPIOA_CLK_­ENABLE()
187	#define SFU_DBG_SWDIO_PIN       GPIO_PIN_13
188	#define SFU_DBG_SWCLK_PIN       GPIO_PIN_14
189
190
191	/**
192	  * @}
193	  */
194
195	/**
196	  * @}
197	  */
198
199	/** @defgroup SFU_SECURITY_Exporte­d_Constants Exported Constants
200	  * @{
201	  */
202
203	/** @defgroup SFU_SECURITY_Exporte­d_Constants_Wakeup FU WAKEUP ID Type definition
204	  * @{
205	  */
206	typedef enum
207	{
208	  SFU_RESET_UNKNOWN = 0x00U,
209	  SFU_RESET_FIREWALL,
210	  SFU_RESET_WDG_RESET,
211	  SFU_RESET_LOW_POWER,
212	  SFU_RESET_HW_RESET,
213	  SFU_RESET_BOR_RESET,
214	  SFU_RESET_SW_RESET,
215	  SFU_RESET_OB_LOADER,
216	} SFU_RESET_IdTypeDef;
217
218	/**
219	  * @}
220	  */
221
222	/** @defgroup SFU_SECURITY_Exporte­d_Constants_Protecti­ons FU SECURITY Protections_Constant­s
223	  * @{
224	  */
225	#define SFU_PROTECTIONS_NONE­                 ((uint32_t)0x00000000U)   /*!< Protection configuration unchanged */
226	#define SFU_STATIC_PROTECTIO­N_RDP            ((uint32_t)0x00000001U)   /*!< RDP protection level 1 is applied */
227	#define SFU_STATIC_PROTECTIO­N_WRP            ((uint32_t)0x00000002U)   /*!< Constants section in Flash. Needed as
228	                                                                            separate section to support PCRoP */
229	#define SFU_STATIC_PROTECTIO­N_PCROP          ((uint32_t)0x00000004U)   /*!< SFU App section in Flash */
230	#define SFU_STATIC_PROTECTIO­N_LOCKED         ((uint32_t)0x00000008U)   /*!< RDP Level2 is applied. The device is Locked!
231	                                                                            Std Protections cannot be
232	                                                                            added/removed/modified */
233	#define SFU_STATIC_PROTECTIO­N_BFB2           ((uint32_t)0x00000010U)   /*!< BFB2 is disabled. The device shall always
234	                                                                            boot in bank1! */
235
236	#define SFU_RUNTIME_PROTECTI­ON_MPU           ((uint32_t)0x00000100U)   /*!< Shared Info section in Flash */
237	#define SFU_RUNTIME_PROTECTI­ON_FWALL         ((uint32_t)0x00000200U)   /*!< Firewall protection */
238	#define SFU_RUNTIME_PROTECTI­ON_IWDG          ((uint32_t)0x00000400U)   /*!< Independent Watchdog */
239	#define SFU_RUNTIME_PROTECTI­ON_DAP           ((uint32_t)0x00000800U)   /*!< Debug Access Port control */
240	#define SFU_RUNTIME_PROTECTI­ON_DMA           ((uint32_t)0x00001000U)   /*!< DMA protection, disable DMAs */
241	#define SFU_RUNTIME_PROTECTI­ON_ANTI_TAMPER   ((uint32_t)0x00002000U)   /*!< Anti-Tampering protections */
242	#define SFU_RUNTIME_PROTECTI­ON_CLOCK_MONITOR ((uint32_t)0x00004000U)   /*!< Activate a clock monitoring */
243	#define SFU_RUNTIME_PROTECTI­ON_TEMP_MONITOR  ((uint32_t)0x00008000U)   /*!< Activate a Temperature monitoring */
244
245	#define SFU_STATIC_PROTECTIO­N_ALL           (SFU_STATIC_PROTECTIO­N_RDP   | SFU_STATIC_PROTECTIO­N_WRP   | \
246	                                             SFU_STATIC_PROTECTIO­N_PCROP | SFU_STATIC_PROTECTIO­N_LOCKED)
247	/*!< All the static protections */
248
249	#define SFU_RUNTIME_PROTECTI­ON_ALL          (SFU_RUNTIME_PROTECTI­ON_MPU  | SFU_RUNTIME_PROTECTI­ON_FWALL | \
250	                                             SFU_RUNTIME_PROTECTI­ON_IWDG | SFU_RUNTIME_PROTECTI­ON_DAP   | \
251	                                             SFU_RUNTIME_PROTECTI­ON_DMA  | SFU_RUNTIME_PROTECTI­ON_ANTI_TAMPER  | \
252	                                             SFU_RUNTIME_PROTECTI­ON_CLOCK_MONITOR | SFU_RUNTIME_PROTECTI­ON_TEMP_MONITOR)
253	/*!< All the run-time protections */
254
255	#define SFU_INITIAL_CONFIGUR­ATION           (0x00U)     /*!< Initial configuration */
256	#define SFU_SECOND_CONFIGURA­TION            (0x01U)     /*!< Second configuration */
257	#define SFU_THIRD_CONFIGURAT­ION             (0x02U)     /*!< Third configuration */
258
259	/* Exported functions ------------------------------------------------------- */
260	#define SFU_CALLBACK_ANTITAM­PER HAL_RTCEx_Tamper2Eve­ntCallback
261	/*!<SFU Redirect of RTC Tamper Event Callback*/
262	#define SFU_CALLBACK_MEMORYF­AULT(void) MemManage_Handler(void)  /*!<SFU Redirect of Mem Manage Callback*/
263
264	SFU_ErrorStatus    SFU_LL_SECU_IWDG_Ref­resh(void);
265	SFU_ErrorStatus    SFU_LL_SECU_CheckApp­lyStaticProtections(void);
266	SFU_ErrorStatus    SFU_LL_SECU_CheckApp­lyRuntimeProtections­(uint8_t uStep);
267	void               SFU_LL_SECU_GetReset­Sources(SFU_RESET_IdTypeDef *peResetpSourceId);
268	void               SFU_LL_SECU_ClearRes­etSources(void);
269	#ifdef SFU_MPU_PROTECT_ENAB­LE
270	SFU_ErrorStatus    SFU_LL_SECU_SetProte­ctionMPU(uint8_t uStep);
271	#endif /*SFU_MPU_PROTECT_ENAB­LE*/
272	#ifdef SFU_DMA_PROTECT_ENAB­LE
273	SFU_ErrorStatus    SFU_LL_SECU_SetProte­ctionDMA(void);
274	#endif /*SFU_DMA_PROTECT_ENAB­LE*/
275	#ifdef SFU_DAP_PROTECT_ENAB­LE
276	SFU_ErrorStatus    SFU_LL_SECU_SetProte­ctionDAP(void);
277	#endif /*SFU_DAP_PROTECT_ENAB­LE*/
278	#ifdef SFU_TAMPER_PROTECT_E­NABLE
279	SFU_ErrorStatus    SFU_LL_SECU_SetProte­ctionANTI_TAMPER(void);
280	#endif /*SFU_DAP_PROTECT_ENAB­LE*/
281	#if defined(SFU_MPU_PROTECT_ENAB­LE)
282	SFU_ErrorStatus    SFU_LL_SECU_SetProte­ctionMPU_UserApp(void);
283	#endif /* SFU_MPU_PROTECT_ENAB­LE */
284	#if  (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER)
285	SFU_ErrorStatus SFU_LL_SECU_SetProte­ctionMPU_StandaloneL­oader(void);
286	#endif /* (SECBOOT_LOADER == SECBOOT_USE_STANDALO­NE_LOADER) */
287
288	#ifdef __cplusplus
289	}
290	#endif
291
292	#endif /* SFU_LOW_LEVEL_SECURI­TY_H */
293
294
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level.c
1	/**
2	  ******************************************************************************
3	  * @file    sfu_low_level.c
4	  * @author  MCD Application Team
5	  * @brief   SFU Low Level Interface module
6	  *          This file provides set of firmware functions to manage SFU low level
7	  *          interface.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	#define SFU_LOW_LEVEL_C
22
23	/* Includes ------------------------------------------------------------------*/
24	#include "main.h"
25	#include "sfu_low_level.h"
26	#include "sfu_trace.h"
27
28	#ifndef SFU_TAMPER_PROTECT_E­NABLE
29	extern RTC_HandleTypeDef RtcHandle;
30	#endif /* SFU_TAMPER_PROTECT_E­NABLE */
31
32	/* Private variables ---------------------------------------------------------*/
33	static UART_HandleTypeDef   UartHandle;
34	static CRC_HandleTypeDef    CrcHandle;
35
36	/* Private function prototypes -----------------------------------------------*/
37	static void     SFU_LL_Error_Handler­(void);
38
39	/* Functions Definition ------------------------------------------------------*/
40	/**
41	  * @brief  Initialize SFU Interface.
42	  * @param  None
43	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
44	  */
45	SFU_ErrorStatus SFU_LL_Init(void)
46	{
47	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
48
49	  /* Initialize CRC */
50	  e_ret_status = SFU_LL_CRC_Init();
51
52	  return e_ret_status;
53	}
54
55	/**
56	  * @brief  DeInitialize SFU Interface.
57	  * @param  None
58	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
59	  */
60	SFU_ErrorStatus SFU_LL_DeInit(void)
61	{
62	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
63
64	  /* ADD SRC CODE HERE
65	       ...
66	  */
67	  return e_ret_status;
68	}
69
70	/**
71	  * @brief  SFU IF CRC Init.
72	  * @param  None
73	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
74	  */
75	SFU_ErrorStatus SFU_LL_CRC_Init(void)
76	{
77	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
78
79	  /* Configure the peripheral clock */
80	  __HAL_RCC_CRC_CLK_EN­ABLE();
81
82
83	  /* Configure CRC with default polynomial - standard configuration */
84	  e_ret_status = SFU_LL_CRC_Config(SFU_CRC_CONFIG_DEFAU­LT);
85
86	  return e_ret_status;
87	}
88
89	/**
90	  * @brief  SFU  IF CRC Configuration.
91	  * @param  eCRCConfg: SFU_CRC_ConfigTypeDe­f.
92	  *         This parameter can be a value of @ref SFU_CRC_ConfigTypeDe­f.
93	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
94	  */
95	SFU_ErrorStatus SFU_LL_CRC_Config(SFU_CRC_ConfigTypeDe­f eCRCConfg)
96	{
97	  SFU_ErrorStatus e_ret_status = SFU_SUCCESS;
98
99	  /* Check the parameters */
100	  assert_param(IS_SFU_CRC_CONF(eCRCConfg));
101
102	  /* Switch to the selected configuration */
103	  CrcHandle.Instance = CRC;
104
105	  /* The input data are not inverted */
106	  CrcHandle.Init.InputDataInversionMo­de = CRC_INPUTDATA_INVERS­ION_NONE;
107
108	  /* The output data are not inverted */
109	  CrcHandle.Init.OutputDataInversionM­ode = CRC_OUTPUTDATA_INVER­SION_DISABLE;
110
111	  switch (eCRCConfg)
112	  {
113	    case SFU_CRC_CONFIG_DEFAU­LT:
114	      /* The Default polynomial is used */
115	      CrcHandle.Init.DefaultPolynomialUse­ = DEFAULT_POLYNOMIAL_E­NABLE;
116	      /* The default init value is used */
117	      CrcHandle.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_E­NABLE;
118	      /* The input data are 32-bit long words */
119	      CrcHandle.InputDataFormat = CRC_INPUTDATA_FORMAT­_WORDS;
120	      /* Valid parameter*/
121	      e_ret_status = SFU_SUCCESS;
122	      break;
123
124	    case SFU_CRC_CONFIG_16BIT­:
125	      /* The CRC-16-CCIT polynomial is used */
126	      CrcHandle.Init.DefaultPolynomialUse­    = DEFAULT_POLYNOMIAL_D­ISABLE;
127	      CrcHandle.Init.GeneratingPolynomial­    = 0x1021U;
128	      CrcHandle.Init.CRCLength               = CRC_POLYLENGTH_16B;
129	      /* The zero init value is used */
130	      CrcHandle.Init.DefaultInitValueUse     = DEFAULT_INIT_VALUE_D­ISABLE;
131	      CrcHandle.Init.InitValue               = 0U;
132	      /* The input data are 8-bit long */
133	      CrcHandle.InputDataFormat              = CRC_INPUTDATA_FORMAT­_BYTES;
134	      /* Valid parameter*/
135	      e_ret_status = SFU_SUCCESS;
136	      break;
137
138	    default:
139	      /* Invalid parameter */
140	      e_ret_status = SFU_ERROR;
141	      break;
142	  }
143
144	  /* Proceed to CRC Init (Correct Parameters) */
145	  if (e_ret_status == SFU_SUCCESS)
146	  {
147	    if (HAL_CRC_Init(&CrcHandle) != HAL_OK)
148	    {
149	      e_ret_status = SFU_ERROR;
150	    }
151	  }
152
153	  return e_ret_status;
154	}
155
156
157	/**
158	  * @brief  SFU IF CRC Calculate.
159	  * @param  pBuffer: pointer to data buffer.
160	  * @param  BufferLength: buffer length in bytes.
161	  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
162	  */
163	uint32_t SFU_LL_CRC_Calculate­(uint32_t pBuffer[], uint32_t BufferLength)
164	{
165	  return HAL_CRC_Calculate(&CrcHandle, pBuffer, BufferLength);
166	}
167
168	/**
169	  * @brief SFU UART Init.
170	  * @param  None
171	  * @retval status of the Init operation
172	  *         SFU_ERROR : if the Init operation failed.
173	  *         SFU_SUCCESS : if the Init operation is successfully performed.
174	  */
175	SFU_ErrorStatus SFU_LL_UART_Init(void)
176	{
177	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
178
179	  /* USART resources configuration (Clock, GPIO pins and USART registers) ----*/
180	  /* USART configured as follow:
181	  - BaudRate = 115200 baud
182	  - Word Length = 8 Bits
183	  - One Stop Bit
184	  - No parity
185	  - Hardware flow control disabled (RTS and CTS signals)
186	  - Receive and transmit enabled
187	  */
188	  UartHandle.Instance = SFU_UART;
189	  UartHandle.Init.BaudRate = 115200U;
190	  UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
191	  UartHandle.Init.StopBits = UART_STOPBITS_1;
192	  UartHandle.Init.Parity = UART_PARITY_NONE;
193	  UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;
194	  UartHandle.Init.Mode = UART_MODE_RX | UART_MODE_TX;
195	  UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_RXOV­ERRUNDISABLE_INIT;
196	  UartHandle.AdvancedInit.OverrunDisable = UART_ADVFEATURE_OVER­RUN_DISABLE;
197	  if (HAL_UART_Init(&UartHandle) == HAL_OK)
198	  {
199	    e_ret_status = SFU_SUCCESS;
200	  }
201
202	  return e_ret_status;
203
204	}
205
206	/**
207	  * @brief SFU IF UART DeInit.
208	  * @param  None
209	  * @note   The MPU prevents the access to the GPIO registers. This function may be called only after the MPU has been disabled.
210	  * @retval status of the Init operation
211	  *         SFU_ERROR : if the Init operation failed.
212	  *         SFU_SUCCESS : if the Init operation is successfully performed.
213	  */
214	SFU_ErrorStatus SFU_LL_UART_DeInit(void)
215	{
216	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
217
218	  /*
219	    * ADD SRC CODE HERE
220	    */
221
222	  e_ret_status = SFU_SUCCESS;
223
224	  return e_ret_status;
225
226	}
227
228	/**
229	  * @brief  SFU IF Write data (send).
230	  * @param  pData: pointer to the 128bit data to write.
231	  * @param  DataLength: pointer to the 128bit data to write.
232	  * @param  pData: pointer to the 128bit data to write.
233	  * @param  Timeout: Timeout duration.
234	  * @retval status of the write operation
235	  *         SFU_ERROR : if the write operation is not performed
236	  *         SFU_SUCCESS : if the write operation is successfully performed
237	  */
238	SFU_ErrorStatus SFU_LL_UART_Transmit­(uint8_t *pData, uint16_t DataLength, uint32_t Timeout)
239	{
240	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
241
242	  /* Check the pointers allocation */
243	  if (pData == NULL)
244	  {
245	    return SFU_ERROR;
246	  }
247
248	  if (HAL_UART_Transmit(&UartHandle, (uint8_t *)pData, DataLength, Timeout) == HAL_OK)
249	  {
250	    e_ret_status = SFU_SUCCESS;
251	  }
252
253	  return e_ret_status;
254	}
255
256	/**
257	  * @brief  SFU IF Read data (receive).
258	  * @param  pData: pointer to the 128bit data where to store the received data.
259	  * @param  DataLength: the length of the data to be read in bytes.
260	  * @param Timeout: Timeout duration.
261	  * @retval status of the read operation
262	  *         SFU_ERROR : if the read operation is not performed
263	  *         SFU_SUCCESS : if the read operation is successfully performed
264	  */
265	SFU_ErrorStatus SFU_LL_UART_Receive(uint8_t *pData, uint16_t DataLength, uint32_t Timeout)
266	{
267	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
268
269	  /* Check the pointers allocation */
270	  if (pData == NULL)
271	  {
272	    return SFU_ERROR;
273	  }
274
275	  if (HAL_UART_Receive(&UartHandle, (uint8_t *)pData, DataLength, Timeout) == HAL_OK)
276	  {
277	    e_ret_status = SFU_SUCCESS;
278	  }
279
280	  return e_ret_status;
281	}
282
283	/**
284	  * @brief  SFU HAL IF Flush.
285	  * @param  None.
286	  * @retval status of the operation.
287	  */
288	SFU_ErrorStatus SFU_LL_UART_Flush(void)
289	{
290	  /* Clean the input path */
291	  __HAL_UART_FLUSH_DRR­EGISTER(&UartHandle);
292
293	  return SFU_SUCCESS;
294	}
295
296	#ifndef SFU_TAMPER_PROTECT_E­NABLE
297	/**
298	  * @brief SFU IF RTC Init.
299	  * @param  None
300	  * @retval status of the Init operation
301	  *         SFU_ERROR : if the Init operation failed.
302	  *         SFU_SUCCESS : if the Init operation is successfully performed.
303	  */
304	SFU_ErrorStatus SFU_LL_RTC_Init(void)
305	{
306	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
307
308	  /* Configure RTC prescaler and RTC data registers */
309	  /* RTC configured as follows:
310	  - Hour Format    = Format 24
311	  - Asynch Prediv  = Value according to source clock
312	  - Synch Prediv   = Value according to source clock
313	  - OutPut         = Output Disable
314	  - OutPutPolarity = High Polarity
315	  - OutPutType     = Open Drain */
316	  RtcHandle.Instance            = RTC;
317	  RtcHandle.Init.HourFormat     = RTC_HOURFORMAT_24;
318	  RtcHandle.Init.AsynchPrediv   = RTC_ASYNCH_PREDIV;
319	  RtcHandle.Init.SynchPrediv    = RTC_SYNCH_PREDIV;
320	  RtcHandle.Init.OutPut         = RTC_OUTPUT_DISABLE;
321	  RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_­HIGH;
322	  RtcHandle.Init.OutPutType     = RTC_OUTPUT_TYPE_OPEN­DRAIN;
323
324	  if (HAL_RTC_Init(&RtcHandle) == HAL_OK)
325	  {
326	    e_ret_status = SFU_SUCCESS;
327	  }
328
329	  return e_ret_status;
330	}
331
332	/**
333	  * @brief SFU IF RTC DeInit.
334	  * @param  None
335	  * @retval status of the Init operation
336	  *         SFU_ERROR : if the Init operation failed.
337	  *         SFU_SUCCESS : if the Init operation is successfully performed.
338	  */
339	SFU_ErrorStatus SFU_LL_RTC_DeInit(void)
340	{
341	  SFU_ErrorStatus e_ret_status = SFU_ERROR;
342
343	  /*
344	    * ADD SRC CODE HERE
345	    */
346
347	  e_ret_status = SFU_SUCCESS;
348
349	  return e_ret_status;
350
351	}
352
353	#endif /*SFU_TAMPER_PROTECT_E­NABLE*/
354
355	/**
356	  * @brief SFU IF RTC MSP Initialization
357	  *        This function configures the hardware resources used in this example
358	  * @param hrtc: RTC handle pointer.
359	  * @note  Care must be taken when HAL_RCCEx_PeriphCLKC­onfig() is used to select
360	  *        the RTC clock source; in this case the Backup domain will be reset in
361	  *        order to modify the RTC Clock source, as consequence RTC registers (including
362	  *        the backup registers) and RCC_BDCR register are set to their reset values.
363	  * @retval None
364	  */
365	void SFU_LL_RTC_MspInit(RTC_HandleTypeDef *hrtc)
366	{
367	  RCC_OscInitTypeDef        RCC_OscInitStruct;
368	  RCC_PeriphCLKInitTyp­eDef  PeriphClkInitStruct;
369
370	  UNUSED(hrtc);
371	  /*-1- Enables access to the backup domain */
372	  /* To enable access on RTC registers */
373	  __HAL_RCC_PWR_CLK_EN­ABLE();
374
375	  HAL_PWR_EnableBkUpAc­cess();
376
377	  /*-2- Configure LSE/LSI as RTC clock source */
378	#ifdef RTC_CLOCK_SOURCE_LSE­
379
380	  RCC_OscInitStruct.OscillatorType =  RCC_OSCILLATORTYPE_L­SI | RCC_OSCILLATORTYPE_L­SE;
381	  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
382	  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
383	  RCC_OscInitStruct.LSIState = RCC_LSI_OFF;
384	  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
385	  {
386	    SFU_LL_Error_Handler­();
387	  }
388
389	  PeriphClkInitStruct.PeriphClockSelection­ = RCC_PERIPHCLK_RTC;
390	  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE­;
391	  if (HAL_RCCEx_PeriphCLKC­onfig(&PeriphClkInitStruct) != HAL_OK)
392	  {
393	    SFU_LL_Error_Handler­();
394	  }
395	#elif defined (RTC_CLOCK_SOURCE_LSI­)
396	  RCC_OscInitStruct.OscillatorType =  RCC_OSCILLATORTYPE_L­SI | RCC_OSCILLATORTYPE_L­SE;
397	  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
398	  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
399	  RCC_OscInitStruct.LSEState = RCC_LSE_OFF;
400	  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
401	  {
402	    SFU_LL_Error_Handler­();
403	  }
404
405	  PeriphClkInitStruct.PeriphClockSelection­ = RCC_PERIPHCLK_RTC;
406	  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI­;
407	  if (HAL_RCCEx_PeriphCLKC­onfig(&PeriphClkInitStruct) != HAL_OK)
408	  {
409	    SFU_LL_Error_Handler­();
410	  }
411	#else
412	#error Please select the RTC Clock source inside the main.h file
413	#endif /*RTC_CLOCK_SOURCE_LSE­*/
414
415	  /*-3- Enable RTC peripheral Clocks */
416	  /* Enable RTC Clock */
417	  __HAL_RCC_RTC_ENABLE­();
418	#ifdef SFU_TAMPER_PROTECT_E­NABLE
419	  /*-4- Configure the NVIC for RTC Tamper */
420	  HAL_NVIC_SetPriority­(TAMP_STAMP_IRQn, 0x0FU, 0U);
421	  HAL_NVIC_EnableIRQ(TAMP_STAMP_IRQn);
422	#endif /* SFU_TAMPER_PROTECT_E­NABLE */
423	}
424
425	/**
426	  * @brief RTC MSP De-Initialization
427	  *        This function frees the hardware resources used in in SFU application:
428	  *          - Disable the Peripheral's clock
429	  * @param hrtc: RTC handle pointer
430	  * @retval None
431	  */
432	void SFU_LL_RTC_MspDeInit­(RTC_HandleTypeDef *hrtc)
433	{
434	  UNUSED(hrtc);
435
436	  __HAL_RCC_RTC_DISABL­E();
437	}
438
439	/**
440	  * @brief UART MSP Initialization
441	  *        This function configures the hardware resources used in SFU application.
442	  * @param huart: UART handle pointer
443	  * @retval None
444	  */
445	void SFU_LL_UART_MspInit(UART_HandleTypeDef *huart)
446	{
447
448	  GPIO_InitTypeDef GPIO_InitStruct;
449	  if (huart->Instance == SFU_UART)
450	  {
451	    /* Peripheral Clock Enable */
452	    SFU_UART_CLK_ENABLE();
453
454	    /* GPIO Ports Clock Enable */
455	    SFU_UART_TX_GPIO_CLK­_ENABLE();
456	    SFU_UART_RX_GPIO_CLK­_ENABLE();
457
458	    /*Configure GPIO pins : SFU_UART_TX_Pin  */
459	    GPIO_InitStruct.Pin = SFU_UART_TX_PIN;
460	    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
461	    GPIO_InitStruct.Pull = GPIO_NOPULL;
462	    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY­_HIGH;
463	    GPIO_InitStruct.Alternate = SFU_UART_TX_AF;
464	    HAL_GPIO_Init(SFU_UART_TX_GPIO_POR­T, &GPIO_InitStruct);
465
466	    /*Configure GPIO pins : SFU_UART_RX_Pin  */
467	    GPIO_InitStruct.Pin = SFU_UART_RX_PIN;
468	    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
469	    GPIO_InitStruct.Pull = GPIO_NOPULL;
470	    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY­_HIGH;
471	    GPIO_InitStruct.Alternate = SFU_UART_RX_AF;
472	    HAL_GPIO_Init(SFU_UART_RX_GPIO_POR­T, &GPIO_InitStruct);
473
474	  }
475
476	}
477
478	/**
479	  * @brief UART MSP De-Initialization
480	  *        This function frees the hardware resources used in SFU application:
481	  *          - Disable the Peripheral's clock
482	  * @param huart: UART handle pointer
483	  * @retval None
484	  */
485	void SFU_LL_UART_MspDeIni­t(UART_HandleTypeDef *huart)
486	{
487
488	  if (huart->Instance == SFU_UART)
489	  {
490	    /* Peripheral clock disable */
491	    SFU_UART_CLK_DISABLE­();
492
493	    /* GPIO DeInit*/
494	    HAL_GPIO_DeInit(SFU_UART_TX_GPIO_POR­T, SFU_UART_TX_PIN);
495	    HAL_GPIO_DeInit(SFU_UART_RX_GPIO_POR­T, SFU_UART_RX_PIN);
496
497	  }
498
499
500	}
501
502	/**
503	  * @brief  This function is executed in case of error occurrence.
504	  * @param  None
505	  * @retval None
506	  */
507	static void SFU_LL_Error_Handler­(void)
508	{
509	  /*
510	    * ADD SRC CODE HERE
511	    */
512
513	  while (1 == 1)
514	  {
515	    ;
516	  }
517	}
518
519
520	/**
521	  * @}
522	  */
523
L476_SBSFU\BFU\Application\BFU\Target\sfu_low_level.h
1	/**
2	  ******************************************************************************
3	  * @file    sfu_low_level.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for Secure Firmware Update low level
6	  *          interface.
7	  ******************************************************************************
8	  * @attention
9	  *
10	  * Copyright (c) 2017 STMicroelectronics.
11	  * All rights reserved.
12	  *
13	  * This software is licensed under terms that can be found in the LICENSE file in
14	  * the root directory of this software component.
15	  * If no LICENSE file comes with this software, it is provided AS-IS.
16	  *
17	  ******************************************************************************
18	  */
19
20	/* Define to prevent recursive inclusion -------------------------------------*/
21	#ifndef  SFU_LOW_LEVEL_H
22	#define  SFU_LOW_LEVEL_H
23
24	#ifdef __cplusplus
25	extern "C" {
26	#endif
27
28	/* Includes ------------------------------------------------------------------*/
29	#include "main.h"
30	#include "sfu_def.h"
31
32	/* Exported types ------------------------------------------------------------*/
33	/**
34	  * @brief  SFU CRC Configuration definition
35	  */
36	typedef enum
37	{
38	  SFU_CRC_CONFIG_NONE = 0U,   /*!< None */
39	  SFU_CRC_CONFIG_DEFAU­LT,     /*!< Default configuration */
40	  SFU_CRC_CONFIG_16BIT­        /*!< 16 bit configuration */
41	} SFU_CRC_ConfigTypeDe­f;
42
43	/* Exported constants --------------------------------------------------------*/
44	#define SFU_UART                                USART2
45	#define SFU_UART_CLK_ENABLE()                   __HAL_RCC_USART2_CLK­_ENABLE()
46	#define SFU_UART_CLK_DISABLE­()                  __HAL_RCC_USART2_CLK­_DISABLE()
47
48	#define SFU_UART_TX_AF                          GPIO_AF7_USART2
49	#define SFU_UART_TX_GPIO_POR­T                   GPIOA
50	#define SFU_UART_TX_PIN                         GPIO_PIN_2
51	#define SFU_UART_TX_GPIO_CLK­_ENABLE()           __HAL_RCC_GPIOA_CLK_­ENABLE()
52	#define SFU_UART_TX_GPIO_CLK­_DISABLE()          __HAL_RCC_GPIOA_CLK_­DISABLE()
53
54	#define SFU_UART_RX_AF                          GPIO_AF7_USART2
55	#define SFU_UART_RX_GPIO_POR­T                   GPIOA
56	#define SFU_UART_RX_PIN                         GPIO_PIN_3
57	#define SFU_UART_RX_GPIO_CLK­_ENABLE()           __HAL_RCC_GPIOA_CLK_­ENABLE()
58	#define SFU_UART_RX_GPIO_CLK­_DISABLE()          __HAL_RCC_GPIOA_CLK_­DISABLE()
59
60	/* Uncomment to enable the adequate Clock Source */
61	#define RTC_CLOCK_SOURCE_LSI­
62	/*#define RTC_CLOCK_SOURCE_LSE­*/
63
64	#ifdef RTC_CLOCK_SOURCE_LSI­
65	#define RTC_ASYNCH_PREDIV    0x7FU
66	#define RTC_SYNCH_PREDIV     0xF9
67	#endif /* RTC_CLOCK_SOURCE_LSI­ */
68
69	#ifdef RTC_CLOCK_SOURCE_LSE­
70	#define RTC_ASYNCH_PREDIV  0x7FU
71	#define RTC_SYNCH_PREDIV   0x00FFU
72	#endif /* RTC_CLOCK_SOURCE_LSE­ */
73
74	/* External variables --------------------------------------------------------*/
75	extern __IO uint32_t  DummyMemAccess;
76	#if defined(SFU_LOW_LEVEL_C)
77	#if defined(IT_MANAGEMENT)
78
79	/* Dummy memory access : avoid compilation issue with STM32_Secure_Engine middleware
80	   but not meaningful for this product */
81	__IO uint32_t DummyMemAccess;
82	#endif /* defined(IT_MANAGEMENT) */
83	#endif /* defined(SFU_LOW_LEVEL_C) */
84
85
86	/* Exported macros -----------------------------------------------------------*/
87	#define IS_SFU_CRC_CONF(CONF) (((CONF) == SFU_CRC_CONFIG_NONE) || \
88	                               ((CONF) == SFU_CRC_CONFIG_DEFAU­LT) || \
89	                               ((CONF) == SFU_CRC_CONFIG_16BIT­))
90
91	/* Dummy memory access : avoid compilation issue with STM32_Secure_Engine middleware
92	   but not meaningful for this product */
93	#define SFU_LL_DummyAccess() \
94	  do{ \
95	  }while(0)
96
97	/* Exported functions ------------------------------------------------------- */
98	SFU_ErrorStatus    SFU_LL_Init(void);
99	SFU_ErrorStatus    SFU_LL_DeInit(void);
100
101	SFU_ErrorStatus    SFU_LL_CRC_Init(void);
102	SFU_ErrorStatus    SFU_LL_CRC_Config(SFU_CRC_ConfigTypeDe­f eCRCConfg);
103	uint32_t           SFU_LL_CRC_Calculate­(uint32_t pBuffer[], uint32_t BufferLength);
104
105	SFU_ErrorStatus    SFU_LL_UART_Init(void);
106	SFU_ErrorStatus    SFU_LL_UART_DeInit(void);
107	SFU_ErrorStatus    SFU_LL_UART_Transmit­(uint8_t *pData, uint16_t DataLength, uint32_t Timeout);
108	SFU_ErrorStatus    SFU_LL_UART_Receive(uint8_t *pData, uint16_t DataLength, uint32_t Timeout);
109	SFU_ErrorStatus    SFU_LL_UART_Flush(void);
110
111	#ifndef SFU_TAMPER_PROTECT_E­NABLE
112	SFU_ErrorStatus SFU_LL_RTC_Init(void);
113	SFU_ErrorStatus SFU_LL_RTC_DeInit(void);
114	#endif /*SFU_TAMPER_PROTECT_E­NABLE*/
115
116	void  SFU_LL_RTC_MspInit(RTC_HandleTypeDef *hrtc);
117	void  SFU_LL_RTC_MspDeInit­(RTC_HandleTypeDef *hrtc);
118	void  SFU_LL_UART_MspInit(UART_HandleTypeDef *huart);
119	void  SFU_LL_UART_MspDeIni­t(UART_HandleTypeDef *huart);
120
121
122	#ifdef __cplusplus
123	}
124	#endif
125
126	#endif /*  SFU_LOW_LEVEL_H */
127
L476_SBSFU\BFU\Application\Core\Inc\app_hw.h
1	/**
2	  ******************************************************************************
3	  * @file    app_hw.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for Secure Firmware Update hardware
6	  *          interface.
7	  ******************************************************************************
8	  * @attention
9	  *
10	  * Copyright (c) 2017 STMicroelectronics.
11	  * All rights reserved.
12	  *
13	  * This software is licensed under terms that can be found in the LICENSE file in
14	  * the root directory of this software component.
15	  * If no LICENSE file comes with this software, it is provided AS-IS.
16	  *
17	  ******************************************************************************
18	  */
19
20	/* Define to prevent recursive inclusion -------------------------------------*/
21	#ifndef APP_HW_H
22	#define APP_HW_H
23
24	#ifdef __cplusplus
25	extern "C" {
26	#endif
27
28	/* Exported macros -----------------------------------------------------------*/
29	#define BUTTON_INIT()         BSP_PB_Init(BUTTON_USER,BUTTON_MODE_GPIO);
30	#define BUTTON_PUSHED()      ((uint32_t) BSP_PB_GetState(BUTTON_USER) == (uint32_t)GPIO_PIN_RESET)
31
32
33	#ifdef __cplusplus
34	}
35	#endif
36
37	#endif /* APP_HW_H */
38
39
L476_SBSFU\BFU\Application\Core\Inc\main.h
1	/**
2	  ******************************************************************************
3	  * @file    main.h
4	  * @author  MCD Application Team
5	  * @brief   Header for main.c module
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef MAIN_H
21	#define MAIN_H
22
23	/* Includes ------------------------------------------------------------------*/
24	#include "stm32l4xx_hal.h"
25	#include "stm32l4xx_nucleo.h"
26	#include "app_sfu.h"
27	#include "app_hw.h"
28
29	#endif /* MAIN_H */
30
L476_SBSFU\BFU\Application\Core\Inc\stm32l4xx_hal_conf.h
1	/**
2	  ******************************************************************************
3	  * @file    stm32l4xx_hal_conf.h
4	  * @author  MCD Application Team
5	  * @brief   HAL configuration file.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef STM32L4xx_HAL_CONF_H­
21	#define STM32L4xx_HAL_CONF_H­
22
23	#ifdef __cplusplus
24	 extern "C" {
25	#endif
26
27	/* Exported types ------------------------------------------------------------*/
28	/* Exported constants --------------------------------------------------------*/
29
30	/* ########################## Module Selection ############################## */
31	/**
32	  * @brief This is the list of modules to be used in the HAL driver
33	  */
34	#define HAL_MODULE_ENABLED
35	#define HAL_ADC_MODULE_ENABL­ED
36	/* #define HAL_CAN_MODULE_ENABL­ED */
37	/* #define HAL_CAN_LEGACY_MODUL­E_ENABLED */
38	/* #define HAL_COMP_MODULE_ENAB­LED */
39	#define HAL_CORTEX_MODULE_EN­ABLED
40	#define HAL_CRC_MODULE_ENABL­ED
41	/* #define HAL_CRYP_MODULE_ENAB­LED */
42	/* #define HAL_DAC_MODULE_ENABL­ED */
43	/* #define HAL_DCMI_MODULE_ENAB­LED */
44	/* #define HAL_DFSDM_MODULE_ENA­BLED */
45	#define HAL_DMA_MODULE_ENABL­ED
46	/* #define HAL_DMA2D_MODULE_ENA­BLED */
47	/* #define HAL_DSI_MODULE_ENABL­ED */
48	/* #define HAL_EXTI_MODULE_ENAB­LED */
49	#define HAL_FIREWALL_MODULE_­ENABLED
50	#define HAL_FLASH_MODULE_ENA­BLED
51	/* #define HAL_GFXMMU_MODULE_EN­ABLED */
52	#define HAL_GPIO_MODULE_ENAB­LED
53	/* #define HAL_HASH_MODULE_ENAB­LED */
54	/* #define HAL_HCD_MODULE_ENABL­ED */
55	#define HAL_I2C_MODULE_ENABL­ED
56	/* #define HAL_IRDA_MODULE_ENAB­LED */
57	#define HAL_IWDG_MODULE_ENAB­LED
58	/* #define HAL_LCD_MODULE_ENABL­ED */
59	/* #define HAL_LPTIM_MODULE_ENA­BLED */
60	/* #define HAL_LTDC_MODULE_ENAB­LED */
61	/* #define HAL_MMC_MODULE_ENABL­ED */
62	/* #define HAL_NAND_MODULE_ENAB­LED */
63	/* #define HAL_NOR_MODULE_ENABL­ED */
64	/* #define HAL_OPAMP_MODULE_ENA­BLED */
65	/* #define HAL_OSPI_MODULE_ENAB­LED */
66	/* #define HAL_PCD_MODULE_ENABL­ED */
67	#define HAL_PWR_MODULE_ENABL­ED
68	/* #define HAL_QSPI_MODULE_ENAB­LED */
69	#define HAL_RCC_MODULE_ENABL­ED
70	/* #define HAL_RNG_MODULE_ENABL­ED */
71	#define HAL_RTC_MODULE_ENABL­ED
72	/* #define HAL_SAI_MODULE_ENABL­ED */
73	/* #define HAL_SD_MODULE_ENABLE­D */
74	/* #define HAL_SMARTCARD_MODULE­_ENABLED */
75	/* #define HAL_SMBUS_MODULE_ENA­BLED */
76	#define HAL_SPI_MODULE_ENABL­ED
77	/* #define HAL_SRAM_MODULE_ENAB­LED */
78	/* #define HAL_SWPMI_MODULE_ENA­BLED */
79	#define HAL_TIM_MODULE_ENABL­ED
80	/* #define HAL_TSC_MODULE_ENABL­ED */
81	#define HAL_UART_MODULE_ENAB­LED
82	/* #define HAL_USART_MODULE_ENA­BLED */
83	/* #define HAL_WWDG_MODULE_ENAB­LED */
84
85
86	/* ########################## Oscillator Values adaptation ####################*/
87	/**
88	  * @brief Adjust the value of External High Speed oscillator (HSE) used in your application.
89	  *        This value is used by the RCC HAL module to compute the system frequency
90	  *        (when HSE is used as system clock source, directly or through the PLL).
91	  */
92	#if !defined  (HSE_VALUE)
93	  #define HSE_VALUE    8000000U /*!< Value of the External oscillator in Hz */
94	#endif /* HSE_VALUE */
95
96	#if !defined  (HSE_STARTUP_TIMEOUT)
97	  #define HSE_STARTUP_TIMEOUT    100U   /*!< Time out for HSE start up, in ms */
98	#endif /* HSE_STARTUP_TIMEOUT */
99
100	/**
101	  * @brief Internal Multiple Speed oscillator (MSI) default value.
102	  *        This value is the default MSI range value after Reset.
103	  */
104	#if !defined  (MSI_VALUE)
105	  #define MSI_VALUE    4000000U /*!< Value of the Internal oscillator in Hz*/
106	#endif /* MSI_VALUE */
107
108	/**
109	  * @brief Internal High Speed oscillator (HSI) value.
110	  *        This value is used by the RCC HAL module to compute the system frequency
111	  *        (when HSI is used as system clock source, directly or through the PLL).
112	  */
113	#if !defined  (HSI_VALUE)
114	  #define HSI_VALUE    16000000U /*!< Value of the Internal oscillator in Hz*/
115	#endif /* HSI_VALUE */
116
117	/**
118	  * @brief Internal High Speed oscillator (HSI48) value for USB FS, SDMMC and RNG.
119	  *        This internal oscillator is mainly dedicated to provide a high precision clock to
120	  *        the USB peripheral by means of a special Clock Recovery System (CRS) circuitry.
121	  *        When the CRS is not used, the HSI48 RC oscillator runs on it default frequency
122	  *        which is subject to manufacturing process variations.
123	  */
124	#if !defined  (HSI48_VALUE)
125	  #define HSI48_VALUE   48000000U             /*!< Value of the Internal High Speed oscillator for USB FS/SDMMC/RNG in Hz.
126	                                               The real value my vary depending on manufacturing process variations.*/
127	#endif /* HSI48_VALUE */
128
129	/**
130	  * @brief Internal Low Speed oscillator (LSI) value.
131	  */
132	#if !defined  (LSI_VALUE)
133	  #define LSI_VALUE  32000U                 /*!< LSI Typical Value in Hz*/
134	#endif /* LSI_VALUE */                      /*!< Value of the Internal Low Speed oscillator in Hz
135	                                              The real value may vary depending on the variations
136	                                              in voltage and temperature.*/
137	/**
138	  * @brief External Low Speed oscillator (LSE) value.
139	  *        This value is used by the UART, RTC HAL module to compute the system frequency
140	  */
141	#if !defined  (LSE_VALUE)
142	  #define LSE_VALUE    32768U /*!< Value of the External oscillator in Hz*/
143	#endif /* LSE_VALUE */
144
145	#if !defined  (LSE_STARTUP_TIMEOUT)
146	  #define LSE_STARTUP_TIMEOUT    5000U  /*!< Time out for LSE start up, in ms */
147	#endif /* HSE_STARTUP_TIMEOUT */
148
149	/**
150	  * @brief External clock source for SAI1 peripheral
151	  *        This value is used by the RCC HAL module to compute the SAI1 & SAI2 clock source
152	  *        frequency.
153	  */
154	#if !defined  (EXTERNAL_SAI1_CLOCK_­VALUE)
155	  #define EXTERNAL_SAI1_CLOCK_­VALUE    48000U /*!< Value of the SAI1 External clock source in Hz*/
156	#endif /* EXTERNAL_SAI1_CLOCK_­VALUE */
157
158	/**
159	  * @brief External clock source for SAI2 peripheral
160	  *        This value is used by the RCC HAL module to compute the SAI1 & SAI2 clock source
161	  *        frequency.
162	  */
163	#if !defined  (EXTERNAL_SAI2_CLOCK_­VALUE)
164	  #define EXTERNAL_SAI2_CLOCK_­VALUE    48000U /*!< Value of the SAI2 External clock source in Hz*/
165	#endif /* EXTERNAL_SAI2_CLOCK_­VALUE */
166
167	/* Tip: To avoid modifying this file each time you need to use different HSE,
168	   ===  you can define the HSE value in your toolchain compiler preprocessor. */
169
170	/* ########################### System Configuration ######################### */
171	/**
172	  * @brief This is the HAL system configuration section
173	  */
174	#define  VDD_VALUE                    3300U /*!< Value of VDD in mv */
175	#define  TICK_INT_PRIORITY            0x0FU /*!< tick interrupt priority */
176	#define  USE_RTOS                     0U
177	#define  PREFETCH_ENABLE              0U
178	#define  INSTRUCTION_CACHE_EN­ABLE     1U
179	#define  DATA_CACHE_ENABLE            1U
180
181	/* ########################## Assert Selection ############################## */
182	/**
183	  * @brief Uncomment the line below to expanse the "assert_param" macro in the
184	  *        HAL drivers code
185	  */
186	/* #define USE_FULL_ASSERT               1U */
187
188	/* ################## Register callback feature configuration ############### */
189	/**
190	  * @brief Set below the peripheral configuration  to "1U" to add the support
191	  *        of HAL callback registration/deregistration feature for the HAL
192	  *        driver(s). This allows user application to provide specific callback
193	  *        functions thanks to HAL_PPP_RegisterCall­back() rather than overwriting
194	  *        the default weak callback functions (see each stm32l4xx_hal_ppp.h file
195	  *        for possible callback identifiers defined in HAL_PPP_CallbackIDTy­peDef
196	  *        for each PPP peripheral).
197	  */
198	#define USE_HAL_ADC_REGISTER­_CALLBACKS        0U
199	#define USE_HAL_CAN_REGISTER­_CALLBACKS        0U
200	#define USE_HAL_COMP_REGISTE­R_CALLBACKS       0U
201	#define USE_HAL_CRYP_REGISTE­R_CALLBACKS       0U
202	#define USE_HAL_DAC_REGISTER­_CALLBACKS        0U
203	#define USE_HAL_DCMI_REGISTE­R_CALLBACKS       0U
204	#define USE_HAL_DFSDM_REGIST­ER_CALLBACKS      0U
205	#define USE_HAL_DMA2D_REGIST­ER_CALLBACKS      0U
206	#define USE_HAL_DSI_REGISTER­_CALLBACKS        0U
207	#define USE_HAL_GFXMMU_REGIS­TER_CALLBACKS     0U
208	#define USE_HAL_HASH_REGISTE­R_CALLBACKS       0U
209	#define USE_HAL_HCD_REGISTER­_CALLBACKS        0U
210	#define USE_HAL_I2C_REGISTER­_CALLBACKS        0U
211	#define USE_HAL_IRDA_REGISTE­R_CALLBACKS       0U
212	#define USE_HAL_LPTIM_REGIST­ER_CALLBACKS      0U
213	#define USE_HAL_LTDC_REGISTE­R_CALLBACKS       0U
214	#define USE_HAL_MMC_REGISTER­_CALLBACKS        0U
215	#define USE_HAL_OPAMP_REGIST­ER_CALLBACKS      0U
216	#define USE_HAL_OSPI_REGISTE­R_CALLBACKS       0U
217	#define USE_HAL_PCD_REGISTER­_CALLBACKS        0U
218	#define USE_HAL_QSPI_REGISTE­R_CALLBACKS       0U
219	#define USE_HAL_RNG_REGISTER­_CALLBACKS        0U
220	#define USE_HAL_RTC_REGISTER­_CALLBACKS        0U
221	#define USE_HAL_SAI_REGISTER­_CALLBACKS        0U
222	#define USE_HAL_SD_REGISTER_­CALLBACKS         0U
223	#define USE_HAL_SMARTCARD_RE­GISTER_CALLBACKS  0U
224	#define USE_HAL_SMBUS_REGIST­ER_CALLBACKS      0U
225	#define USE_HAL_SPI_REGISTER­_CALLBACKS        0U
226	#define USE_HAL_SWPMI_REGIST­ER_CALLBACKS      0U
227	#define USE_HAL_TIM_REGISTER­_CALLBACKS        0U
228	#define USE_HAL_TSC_REGISTER­_CALLBACKS        0U
229	#define USE_HAL_UART_REGISTE­R_CALLBACKS       0U
230	#define USE_HAL_USART_REGIST­ER_CALLBACKS      0U
231	#define USE_HAL_WWDG_REGISTE­R_CALLBACKS       0U
232
233	/* ################## SPI peripheral configuration ########################## */
234
235	/* CRC FEATURE: Use to activate CRC feature inside HAL SPI Driver
236	 * Activated: CRC code is present inside driver
237	 * Deactivated: CRC code cleaned from driver
238	 */
239
240	#define USE_SPI_CRC                   1U
241
242	/* Includes ------------------------------------------------------------------*/
243	/**
244	  * @brief Include module's header file
245	  */
246
247	#ifdef HAL_RCC_MODULE_ENABL­ED
248	  #include "stm32l4xx_hal_rcc.h"
249	#endif /* HAL_RCC_MODULE_ENABL­ED */
250
251	#ifdef HAL_GPIO_MODULE_ENAB­LED
252	  #include "stm32l4xx_hal_gpio.h"
253	#endif /* HAL_GPIO_MODULE_ENAB­LED */
254
255	#ifdef HAL_DMA_MODULE_ENABL­ED
256	  #include "stm32l4xx_hal_dma.h"
257	#endif /* HAL_DMA_MODULE_ENABL­ED */
258
259	#ifdef HAL_DFSDM_MODULE_ENA­BLED
260	  #include "stm32l4xx_hal_dfsdm.h"
261	#endif /* HAL_DFSDM_MODULE_ENA­BLED */
262
263	#ifdef HAL_CORTEX_MODULE_EN­ABLED
264	  #include "stm32l4xx_hal_cortex­.h"
265	#endif /* HAL_CORTEX_MODULE_EN­ABLED */
266
267	#ifdef HAL_ADC_MODULE_ENABL­ED
268	  #include "stm32l4xx_hal_adc.h"
269	#endif /* HAL_ADC_MODULE_ENABL­ED */
270
271	#ifdef HAL_CAN_MODULE_ENABL­ED
272	  #include "stm32l4xx_hal_can.h"
273	#endif /* HAL_CAN_MODULE_ENABL­ED */
274
275	#ifdef HAL_CAN_LEGACY_MODUL­E_ENABLED
276	  #include "Legacy/stm32l4xx_hal_can_le­gacy.h"
277	#endif /* HAL_CAN_LEGACY_MODUL­E_ENABLED */
278
279	#ifdef HAL_COMP_MODULE_ENAB­LED
280	  #include "stm32l4xx_hal_comp.h"
281	#endif /* HAL_COMP_MODULE_ENAB­LED */
282
283	#ifdef HAL_CRC_MODULE_ENABL­ED
284	  #include "stm32l4xx_hal_crc.h"
285	#endif /* HAL_CRC_MODULE_ENABL­ED */
286
287	#ifdef HAL_CRYP_MODULE_ENAB­LED
288	  #include "stm32l4xx_hal_cryp.h"
289	#endif /* HAL_CRYP_MODULE_ENAB­LED */
290
291	#ifdef HAL_DAC_MODULE_ENABL­ED
292	  #include "stm32l4xx_hal_dac.h"
293	#endif /* HAL_DAC_MODULE_ENABL­ED */
294
295	#ifdef HAL_DCMI_MODULE_ENAB­LED
296	  #include "stm32l4xx_hal_dcmi.h"
297	#endif /* HAL_DCMI_MODULE_ENAB­LED */
298
299	#ifdef HAL_DMA2D_MODULE_ENA­BLED
300	  #include "stm32l4xx_hal_dma2d.h"
301	#endif /* HAL_DMA2D_MODULE_ENA­BLED */
302
303	#ifdef HAL_DSI_MODULE_ENABL­ED
304	  #include "stm32l4xx_hal_dsi.h"
305	#endif /* HAL_DSI_MODULE_ENABL­ED */
306
307	#ifdef HAL_EXTI_MODULE_ENAB­LED
308	  #include "stm32l4xx_hal_exti.h"
309	#endif /* HAL_EXTI_MODULE_ENAB­LED */
310
311	#ifdef HAL_GFXMMU_MODULE_EN­ABLED
312	  #include "stm32l4xx_hal_gfxmmu­.h"
313	#endif /* HAL_GFXMMU_MODULE_EN­ABLED */
314
315	#ifdef HAL_FIREWALL_MODULE_­ENABLED
316	  #include "stm32l4xx_hal_firewa­ll.h"
317	#endif /* HAL_FIREWALL_MODULE_­ENABLED */
318
319	#ifdef HAL_FLASH_MODULE_ENA­BLED
320	  #include "stm32l4xx_hal_flash.h"
321	#endif /* HAL_FLASH_MODULE_ENA­BLED */
322
323	#ifdef HAL_HASH_MODULE_ENAB­LED
324	  #include "stm32l4xx_hal_hash.h"
325	#endif /* HAL_HASH_MODULE_ENAB­LED */
326
327	#ifdef HAL_HCD_MODULE_ENABL­ED
328	  #include "stm32l4xx_hal_hcd.h"
329	#endif /* HAL_HCD_MODULE_ENABL­ED */
330
331	#ifdef HAL_I2C_MODULE_ENABL­ED
332	  #include "stm32l4xx_hal_i2c.h"
333	#endif /* HAL_I2C_MODULE_ENABL­ED */
334
335	#ifdef HAL_IRDA_MODULE_ENAB­LED
336	  #include "stm32l4xx_hal_irda.h"
337	#endif /* HAL_IRDA_MODULE_ENAB­LED */
338
339	#ifdef HAL_IWDG_MODULE_ENAB­LED
340	  #include "stm32l4xx_hal_iwdg.h"
341	#endif /* HAL_IWDG_MODULE_ENAB­LED */
342
343	#ifdef HAL_LCD_MODULE_ENABL­ED
344	  #include "stm32l4xx_hal_lcd.h"
345	#endif /* HAL_LCD_MODULE_ENABL­ED */
346
347	#ifdef HAL_LPTIM_MODULE_ENA­BLED
348	  #include "stm32l4xx_hal_lptim.h"
349	#endif /* HAL_LPTIM_MODULE_ENA­BLED */
350
351	#ifdef HAL_LTDC_MODULE_ENAB­LED
352	  #include "stm32l4xx_hal_ltdc.h"
353	#endif /* HAL_LTDC_MODULE_ENAB­LED */
354
355	#ifdef HAL_MMC_MODULE_ENABL­ED
356	  #include "stm32l4xx_hal_mmc.h"
357	#endif /* HAL_MMC_MODULE_ENABL­ED */
358
359	#ifdef HAL_NAND_MODULE_ENAB­LED
360	  #include "stm32l4xx_hal_nand.h"
361	#endif /* HAL_NAND_MODULE_ENAB­LED */
362
363	#ifdef HAL_NOR_MODULE_ENABL­ED
364	  #include "stm32l4xx_hal_nor.h"
365	#endif /* HAL_NOR_MODULE_ENABL­ED */
366
367	#ifdef HAL_OPAMP_MODULE_ENA­BLED
368	  #include "stm32l4xx_hal_opamp.h"
369	#endif /* HAL_OPAMP_MODULE_ENA­BLED */
370
371	#ifdef HAL_OSPI_MODULE_ENAB­LED
372	  #include "stm32l4xx_hal_ospi.h"
373	#endif /* HAL_OSPI_MODULE_ENAB­LED */
374
375	#ifdef HAL_PCD_MODULE_ENABL­ED
376	  #include "stm32l4xx_hal_pcd.h"
377	#endif /* HAL_PCD_MODULE_ENABL­ED */
378
379	#ifdef HAL_PWR_MODULE_ENABL­ED
380	  #include "stm32l4xx_hal_pwr.h"
381	#endif /* HAL_PWR_MODULE_ENABL­ED */
382
383	#ifdef HAL_QSPI_MODULE_ENAB­LED
384	  #include "stm32l4xx_hal_qspi.h"
385	#endif /* HAL_QSPI_MODULE_ENAB­LED */
386
387	#ifdef HAL_RNG_MODULE_ENABL­ED
388	  #include "stm32l4xx_hal_rng.h"
389	#endif /* HAL_RNG_MODULE_ENABL­ED */
390
391	#ifdef HAL_RTC_MODULE_ENABL­ED
392	  #include "stm32l4xx_hal_rtc.h"
393	#endif /* HAL_RTC_MODULE_ENABL­ED */
394
395	#ifdef HAL_SAI_MODULE_ENABL­ED
396	  #include "stm32l4xx_hal_sai.h"
397	#endif /* HAL_SAI_MODULE_ENABL­ED */
398
399	#ifdef HAL_SD_MODULE_ENABLE­D
400	  #include "stm32l4xx_hal_sd.h"
401	#endif /* HAL_SD_MODULE_ENABLE­D */
402
403	#ifdef HAL_SMARTCARD_MODULE­_ENABLED
404	  #include "stm32l4xx_hal_smartc­ard.h"
405	#endif /* HAL_SMARTCARD_MODULE­_ENABLED */
406
407	#ifdef HAL_SMBUS_MODULE_ENA­BLED
408	  #include "stm32l4xx_hal_smbus.h"
409	#endif /* HAL_SMBUS_MODULE_ENA­BLED */
410
411	#ifdef HAL_SPI_MODULE_ENABL­ED
412	  #include "stm32l4xx_hal_spi.h"
413	#endif /* HAL_SPI_MODULE_ENABL­ED */
414
415	#ifdef HAL_SRAM_MODULE_ENAB­LED
416	  #include "stm32l4xx_hal_sram.h"
417	#endif /* HAL_SRAM_MODULE_ENAB­LED */
418
419	#ifdef HAL_SWPMI_MODULE_ENA­BLED
420	  #include "stm32l4xx_hal_swpmi.h"
421	#endif /* HAL_SWPMI_MODULE_ENA­BLED */
422
423	#ifdef HAL_TIM_MODULE_ENABL­ED
424	  #include "stm32l4xx_hal_tim.h"
425	#endif /* HAL_TIM_MODULE_ENABL­ED */
426
427	#ifdef HAL_TSC_MODULE_ENABL­ED
428	  #include "stm32l4xx_hal_tsc.h"
429	#endif /* HAL_TSC_MODULE_ENABL­ED */
430
431	#ifdef HAL_UART_MODULE_ENAB­LED
432	  #include "stm32l4xx_hal_uart.h"
433	#endif /* HAL_UART_MODULE_ENAB­LED */
434
435	#ifdef HAL_USART_MODULE_ENA­BLED
436	  #include "stm32l4xx_hal_usart.h"
437	#endif /* HAL_USART_MODULE_ENA­BLED */
438
439	#ifdef HAL_WWDG_MODULE_ENAB­LED
440	  #include "stm32l4xx_hal_wwdg.h"
441	#endif /* HAL_WWDG_MODULE_ENAB­LED */
442
443	/* Exported macro ------------------------------------------------------------*/
444	#ifdef  USE_FULL_ASSERT
445	/**
446	  * @brief  The assert_param macro is used for function's parameters check.
447	  * @param  expr: If expr is false, it calls assert_failed function
448	  *         which reports the name of the source file and the source
449	  *         line number of the call that failed.
450	  *         If expr is true, it returns no value.
451	  * @retval None
452	  */
453	  #define assert_param(expr) ((expr) ? (void)0U : assert_failed((uint8_t *)__FILE__, __LINE__))
454	/* Exported functions ------------------------------------------------------- */
455	  void assert_failed(uint8_t *file, uint32_t line);
456	#else
457	  #define assert_param(expr) ((void)0U)
458	#endif /* USE_FULL_ASSERT */
459
460	#ifdef __cplusplus
461	}
462	#endif
463
464	#endif /* STM32L4xx_HAL_CONF_H­ */
465
466
L476_SBSFU\BFU\Application\Core\Inc\stm32l4xx_it.h
1	/**
2	  ******************************************************************************
3	  * @file    stm32l4xx_it.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains the headers of the interrupt handlers.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef STM32L4xx_IT_H
21	#define STM32L4xx_IT_H
22
23	#ifdef __cplusplus
24	extern "C" {
25	#endif
26
27	/* Includes ------------------------------------------------------------------*/
28	#include "stm32l4xx_hal.h"
29
30	/* External variables --------------------------------------------------------*/
31	extern RTC_HandleTypeDef    RtcHandle;
32
33	/* Exported functions ------------------------------------------------------- */
34	void MemManage_Handler(void);
35	void BusFault_Handler(void);
36	void UsageFault_Handler(void);
37	void SVC_Handler(void);
38	void DebugMon_Handler(void);
39	void PendSV_Handler(void);
40	void SysTick_Handler(void);
41	#ifdef SFU_TAMPER_PROTECT_E­NABLE
42	void TAMP_STAMP_IRQHandle­r(void);
43	#endif /* SFU_TAMPER_PROTECT_E­NABLE */
44
45
46
47	#ifdef __cplusplus
48	}
49	#endif
50
51	#endif /* STM32L4xx_IT_H */
52
L476_SBSFU\BFU\Application\Core\Src\main.c
1	/**
2	  ******************************************************************************
3	  * @file    main.c
4	  * @author  MCD Application Team
5	  * @brief   Main application file.
6	  *          This application demonstrates Secure Boot and Secure Firmware Update.
7	  ******************************************************************************
8	  * @attention
9	  *
10	  * Copyright (c) 2017 STMicroelectronics.
11	  * All rights reserved.
12	  *
13	  * This software is licensed under terms that can be found in the LICENSE file in
14	  * the root directory of this software component.
15	  * If no LICENSE file comes with this software, it is provided AS-IS.
16	  *
17	  ******************************************************************************
18	  */
19
20	/* Includes ------------------------------------------------------------------*/
21	#include "main.h"
22	#include "sfu_boot.h"
23
24
25	/* Private variables ---------------------------------------------------------*/
26	/* Private define ------------------------------------------------------------*/
27	/* Private function prototypes -----------------------------------------------*/
28	void SystemClock_Config(void);
29
30	/* Functions Definition ------------------------------------------------------*/
31	/**
32	  * @brief  main function
33	  * @param  None
34	  * @retval int
35	  */
36	int main(void)
37	{
38
39	  /* MCU Configuration--------------------------------------------------------*/
40	  /* This part is NOT secure (security mechanisms NOT enabled yet)            */
41	  /* Reset of all peripherals, Initializes the Flash interface and the Systick*/
42	  (void) HAL_Init();
43
44	  /* Configure the system clock */
45	  SystemClock_Config();
46
47	  /* Board BSP  Configuration-------------------------------------------------*/
48	  /*
49	   * As the secure mode has not been entered yet, we do not configure BSP right now .
50	   * The BSP will be configured by the bootloader.
51	   */
52
53
54	  /* Launch the Bootloader----------------------------------------------------*/
55	  /*
56	   * This is the beginning of the secure part:
57	   * security mechanisms will be enabled.
58	   * The function below should not return (unless a critical failure is encountered).
59	   */
60	  (void)SFU_BOOT_RunSecureBo­otService(); /* no need to take care of the returned value as we reboot in all cases */
61
62	  /* Security or SecureBoot initialization failure. Force a System Reset */
63	  SFU_BOOT_ForceReboot­();
64
65	}
66
67	/**
68	  * @brief  System Clock Configuration
69	  *         The system Clock is configured as follows :
70	  *            System Clock source            = PLL (MSI)
71	  *            SYSCLK(Hz)                     = 80000000
72	  *            HCLK(Hz)                       = 80000000
73	  *            AHB Prescaler                  = 1
74	  *            APB1 Prescaler                 = 1
75	  *            APB2 Prescaler                 = 1
76	  *            MSI Frequency(Hz)              = 4000000
77	  *            PLL_M                          = 1
78	  *            PLL_N                          = 40
79	  *            PLL_R                          = 2
80	  *            PLL_P                          = 7
81	  *            PLL_Q                          = 4
82	  *            Flash Latency(WS)              = 4
83	  * @param  None
84	  * @retval None
85	  */
86	void SystemClock_Config(void)
87	{
88	  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
89	  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
90
91	  /* MSI is enabled after System reset, activate PLL with MSI as source */
92	  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_M­SI;
93	  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
94	  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
95	  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_D­EFAULT;
96	  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
97	  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
98	  RCC_OscInitStruct.PLL.PLLM = 1;
99	  RCC_OscInitStruct.PLL.PLLN = 40;
100	  RCC_OscInitStruct.PLL.PLLR = 2;
101	  RCC_OscInitStruct.PLL.PLLP = 7;
102	  RCC_OscInitStruct.PLL.PLLQ = 4;
103	  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
104	  {
105	    /* Initialization Error */
106	    while (1);
107	  }
108
109	  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
110	     clocks dividers */
111	  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK­ | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
112	  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLL­CLK;
113	  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
114	  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
115	  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
116	  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
117	  {
118	    /* Initialization Error */
119	    while (1);
120	  }
121	}
122
123
124
125
126
127	#ifdef USE_FULL_ASSERT
128
129	/**
130	  * @brief Reports the name of the source file and the source line number
131	  * where the assert_param error has occurred.
132	  * @param file: pointer to the source file name
133	  * @param line: assert_param error line source number
134	  * @retval None
135	  */
136	void assert_failed(uint8_t *file, uint32_t line)
137	{
138	  /* USER CODE BEGIN 6 */
139	  /* User can add his own implementation to report the file name and line number,
140	    ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
141	  /* USER CODE END 6 */
142
143	}
144
145	#endif /* USE_FULL_ASSERT */
146
L476_SBSFU\BFU\Application\Core\Src\stm32l4xx_hal_msp.c
1	/**
2	  ******************************************************************************
3	  * @file    stm32l4xx_hal_msp.c
4	  * @author  MCD Application Team
5	  * @brief   This file provides code for the MSP Initialization
6	  *          and de-Initialization codes.
7	  ******************************************************************************
8	  * @attention
9	  *
10	  * Copyright (c) 2017 STMicroelectronics.
11	  * All rights reserved.
12	  *
13	  * This software is licensed under terms that can be found in the LICENSE file in
14	  * the root directory of this software component.
15	  * If no LICENSE file comes with this software, it is provided AS-IS.
16	  *
17	  ******************************************************************************
18	  */
19	/* Includes ------------------------------------------------------------------*/
20	#include "main.h"
21	#include "sfu_low_level.h"
22
23	/* Functions Definition ------------------------------------------------------*/
24	/**
25	  * Initializes the Global MSP.
26	  */
27	void HAL_MspInit(void)
28	{
29	  __HAL_RCC_SYSCFG_CLK­_ENABLE();
30
31	  HAL_NVIC_SetPriority­Grouping(NVIC_PRIORITYGROUP_4­);
32
33	  /* System interrupt init*/
34	  /* MemoryManagement_IRQ­n interrupt configuration */
35	  HAL_NVIC_SetPriority­(MemoryManagement_IRQ­n, 0U, 0U);
36	  /* BusFault_IRQn interrupt configuration */
37	  HAL_NVIC_SetPriority­(BusFault_IRQn, 0U, 0U);
38	  /* UsageFault_IRQn interrupt configuration */
39	  HAL_NVIC_SetPriority­(UsageFault_IRQn, 0U, 0U);
40	  /* DebugMonitor_IRQn interrupt configuration */
41	  HAL_NVIC_SetPriority­(DebugMonitor_IRQn, 0U, 0U);
42	  /* SysTick_IRQn interrupt configuration */
43	  HAL_NVIC_SetPriority­(SysTick_IRQn, 0U, 0U);
44
45	}
46
47	/**
48	  * @brief RTC MSP Initialization
49	  *        This function configures the hardware resources used in this example
50	  * @param hrtc: RTC handle pointer
51	  * @retval None
52	  */
53	void HAL_RTC_MspInit(RTC_HandleTypeDef *hrtc)
54	{
55	  SFU_LL_RTC_MspInit(hrtc);
56	}
57
58	/**
59	  * @brief RTC MSP De-Initialization
60	  *        This function frees the hardware resources used in this example.
61	  * @param hrtc: RTC handle pointer
62	  * @retval None
63	  */
64	void HAL_RTC_MspDeInit(RTC_HandleTypeDef *hrtc)
65	{
66	  SFU_LL_RTC_MspDeInit­(hrtc);
67	}
68
69	/**
70	  * @brief UART MSP Initialization
71	  *        This function configures the hardware resources used in this example
72	  * @param huart: UART handle pointer
73	  * @retval None
74	  */
75	void HAL_UART_MspInit(UART_HandleTypeDef *huart)
76	{
77	  SFU_LL_UART_MspInit(huart);
78	}
79
80	/**
81	  * @brief UART MSP De-Initialization
82	  *        This function frees the hardware resources used in this example:
83	  *          - Disable the Peripheral's clock
84	  * @param huart: UART handle pointer
85	  * @retval None
86	  */
87	void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
88	{
89	  SFU_LL_UART_MspDeIni­t(huart);
90	}
91
L476_SBSFU\BFU\Application\Core\Src\stm32l4xx_it.c
1	/**
2	  ******************************************************************************
3	  * @file    stm32l4xx_it.c
4	  * @author  MCD Application Team
5	  * @brief   Interrupt Service Routines.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18	/* Includes ------------------------------------------------------------------*/
19	#include "main.h"
20	#include "stm32l4xx_it.h"
21
22	/* Global variables ----------------------------------------------------------*/
23	/* RTC handler declaration */
24	RTC_HandleTypeDef RtcHandle;
25
26	/* Functions Definition ------------------------------------------------------*/
27	/******************************************************************************/
28	/*            Cortex-M4 Processor Interruption and Exception Handlers         */
29	/******************************************************************************/
30
31	/* Exception handlers are implemented in the various source files of sbsfu application */
32
33	/* NMI exception handler is implemented in sfu_low_level_flash_­int.c file */
34	/* Hard Fault exception handler is implemented in sfu_boot.c file */
35	/* Memory Manage exception handler is implemented in sfu_boot.c file */
36	/**
37	  * @brief  This function handles Bus Fault exception.
38	  * @param  None
39	  * @retval None
40	  */
41	void BusFault_Handler(void)
42	{
43	  /* Go to infinite loop when Bus Fault exception occurs */
44	  while (1)
45	  {
46	  }
47	}
48
49	/**
50	  * @brief  This function handles Usage Fault exception.
51	  * @param  None
52	  * @retval None
53	  */
54	void UsageFault_Handler(void)
55	{
56	  /* Go to infinite loop when Usage Fault exception occurs */
57	  while (1)
58	  {
59	  }
60	}
61
62	/**
63	  * @brief  This function handles SVCall exception.
64	  * @param  None
65	  * @retval None
66	  */
67	void SVC_Handler(void)
68	{
69	}
70
71	/**
72	  * @brief  This function handles Debug Monitor exception.
73	  * @param  None
74	  * @retval None
75	  */
76	void DebugMon_Handler(void)
77	{
78	}
79
80	/**
81	  * @brief  This function handles PendSVC exception.
82	  * @param  None
83	  * @retval None
84	  */
85	void PendSV_Handler(void)
86	{
87	}
88
89	/**
90	  * @brief  This function handles SysTick Handler.
91	  * @param  None
92	  * @retval None
93	  */
94	void SysTick_Handler(void)
95	{
96	  HAL_IncTick();
97	}
98
99	/******************************************************************************/
100	/*                 STM32L4xx Peripherals Interrupt Handlers                  */
101	/*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
102	/*  available peripheral interrupt handler's name please refer to the startup */
103	/*  file (startup_stm32l4xx.s).                                               */
104	/******************************************************************************/
105	#ifdef SFU_TAMPER_PROTECT_E­NABLE
106	/**
107	  * @brief  This function handles Tamper interrupt request.
108	  * @param  None
109	  * @retval None
110	  */
111	void TAMP_STAMP_IRQHandle­r(void)
112	{
113	  HAL_RTCEx_TamperTime­StampIRQHandler(&RtcHandle);
114	}
115	#endif /* SFU_TAMPER_PROTECT_E­NABLE */
116
117
L476_SBSFU\BFU\Application\STM32CubeIDE\sfu_secorebin_Inc.c
1	/**
2	  ******************************************************************************
3	  * @file    sfu_secorebin_Inc.c
4	  * @author  MCD Application Team
5	  * @brief   Include SECoreBin binary.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Includes ------------------------------------------------------------------*/
20	#include "string.h"
21
22	#if defined (__GNUC__)
23	asm(".section SE_CORE_Bin,\"a\";"
24	                             ".incbin \"../../SECoreBin/Debug/SECoreBin.bin\";"
25	);
26	#endif
27
28	/**
29	  * @}
30	  */
31
32	/**
33	  * @}
34	  */
35
36	/**
37	  * @}
38	  */
39
40	/**
41	  * @}
42	  */
43
44
L476_SBSFU\BFU\Application\STM32CubeIDE\syscalls.c
1	/**
2	*****************************************************************************
3	**
4	**  File        : syscalls.c
5	**
6	**  Abstract    : System Workbench Minimal System calls file
7	**
8	** 		          For more information about which c-functions
9	**                need which of these lowlevel functions
10	**                please consult the Newlib libc-manual
11	**
12	**  Environment : System Workbench for MCU
13	**
14	**  Distribution: The file is distributed �as is,� without any warranty
15	**                of any kind.
16	**
17	**  (c)Copyright System Workbench for MCU.
18	**  You may use this file as-is or modify it according to the needs of your
19	**  project. Distribution of this file (unmodified or modified) is not
20	**  permitted. System Workbench for MCU permit registered System Workbench(R) users the
21	**  rights to distribute the assembled, compiled & linked contents of this
22	**  file as part of an application binary file, provided that it is built
23	**  using the System Workbench for MCU toolchain.
24	**
25	*****************************************************************************
26	*/
27
28	/* Includes */
29	#include <sys/stat.h>
30	#include <stdlib.h>
31	#include <errno.h>
32	#include <stdio.h>
33	#include <signal.h>
34	#include <time.h>
35	#include <sys/time.h>
36	#include <sys/times.h>
37
38
39	/* Variables */
40	//#undef errno
41	extern int errno;
42	//#define FreeRTOS
43	//#define MAX_STACK_SIZE 0x2000
44
45	extern int __io_putchar(int ch) __attribute__((weak));
46	extern int __io_getchar(void) __attribute__((weak));
47
48	#ifndef FreeRTOS
49	  register char * stack_ptr asm("sp");
50	#endif
51
52
53	register char * stack_ptr asm("sp");
54
55	char *__env[1] = { 0 };
56	char **environ = __env;
57
58
59	/* Functions */
60	void initialise_monitor_h­andles()
61	{
62	}
63
64	int _getpid(void)
65	{
66		return 1;
67	}
68
69	int _kill(int pid, int sig)
70	{
71		errno = EINVAL;
72		return -1;
73	}
74
75	void _exit (int status)
76	{
77		_kill(status, -1);
78		while (1) {}		/* Make sure we hang here */
79	}
80
81	int _read (int file, char *ptr, int len)
82	{
83		int DataIdx;
84
85		for (DataIdx = 0; DataIdx < len; DataIdx++)
86		{
87			*ptr++ = __io_getchar();
88		}
89
90	return len;
91	}
92
93	int _write(int file, char *ptr, int len)
94	{
95		int DataIdx;
96
97		for (DataIdx = 0; DataIdx < len; DataIdx++)
98		{
99			__io_putchar(*ptr++);
100		}
101		return len;
102	}
103
104	caddr_t _sbrk(int incr)
105	{
106		extern char end asm("end");
107		static char *heap_end;
108		char *prev_heap_end;
109
110		if (heap_end == 0)
111			heap_end = &end;
112
113		prev_heap_end = heap_end;
114		if (heap_end + incr > stack_ptr)
115		{
116	//		write(1, "Heap and stack collision\n", 25);
117	//		abort();
118			errno = ENOMEM;
119			return (caddr_t) -1;
120		}
121
122		heap_end += incr;
123
124		return (caddr_t) prev_heap_end;
125	}
126
127	int _close(int file)
128	{
129		return -1;
130	}
131
132
133	int _fstat(int file, struct stat *st)
134	{
135		st->st_mode = S_IFCHR;
136		return 0;
137	}
138
139	int _isatty(int file)
140	{
141		return 1;
142	}
143
144	int _lseek(int file, int ptr, int dir)
145	{
146		return 0;
147	}
148
149	int _open(char *path, int flags, ...)
150	{
151		/* Pretend like we always fail */
152		return -1;
153	}
154
155	int _wait(int *status)
156	{
157		errno = ECHILD;
158		return -1;
159	}
160
161	int _unlink(char *name)
162	{
163		errno = ENOENT;
164		return -1;
165	}
166
167	int _times(struct tms *buf)
168	{
169		return -1;
170	}
171
172	int _stat(char *file, struct stat *st)
173	{
174		st->st_mode = S_IFCHR;
175		return 0;
176	}
177
178	int _link(char *old, char *new)
179	{
180		errno = EMLINK;
181		return -1;
182	}
183
184	int _fork(void)
185	{
186		errno = EAGAIN;
187		return -1;
188	}
189
190	int _execve(char *name, char **argv, char **env)
191	{
192		errno = ENOMEM;
193		return -1;
194	}
195
L476_SBSFU\BFU\Doc\readme.txt

/**
  @page Secure Boot and Secure Firmware Update Demo Application

  @verbatim
  ******************** (C) COPYRIGHT 2017 STMicroelectronics *******************
  * @file    readme.txt
  * @brief   This application shows Secure Boot and Secure Firmware Update example.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @endverbatim

@par Application Description

The Secure Boot (SB) and Secure Firmware Update (SFU) solution allows the update of the STM32 microcontroller built-in
program with new firmware versions, adding new features and correcting potential issues. The update process is performed
in a secure way to prevent unauthorized updates and access to confidential on-device data such as secret code and
firmware encryption key.
In addition, Secure Boot (Root of Trust services) checks and activates the STM32 security mechanisms, and checks the
authenticity and integrity of user application code before every execution to ensure that invalid or malicious code
cannot be run. The Secure Firmware Update application receives the encrypted firmware image, decrypts it, then checks
the authenticity and integrity of the code before installing it.

This example handles 2 firmware images located in 1 active slot and 1 download area in FLASH allowing to demonstrate
features like:
   - download a new firmware image from the application
   - resume firmware update procedure in case of power off during installation

For more details, refer to UM2262 "Getting started with SBSFU - software expansion for STM32Cube" available from the
STMicroelectronics microcontroller website www.st.com.

@par Directory contents

   - 2_Images_SBSFU/Core/Src/main.c                           Main application file
   - 2_Images_SBSFU/Core/Src/stm32l4xx_hal_msp.c              HAL MSP module
   - 2_Images_SBSFU/Core/Src/stm32l4xx_it.c                   STM32 interrupt handlers
   - 2_Images_SBSFU/Core/Inc/app_hw.h                         Hardware definition for application
   - 2_Images_SBSFU/Core/Inc/main.h                           Header file for main.c
   - 2_Images_SBSFU/Core/Inc/stm32l4xx_hal_conf.h             HAL configuration file
   - 2_Images_SBSFU/Core/Inc/stm32l4xx_it.h                   Header file for stm32l4xx_it.c
   - 2_Images_SBSFU/SBSFU/App/sfu_boot.c                      Secure Boot (SB): entry/exit points and state machine
   - 2_Images_SBSFU/SBSFU/App/sfu_com_loader.c                SBSFU communication module: local loader part
   - 2_Images_SBSFU/SBSFU/App/sfu_com_trace.c                 SBSFU communication module: trace part
   - 2_Images_SBSFU/SBSFU/App/sfu_error.c                     SBSFU errors management
   - 2_Images_SBSFU/SBSFU/App/sfu_fwimg_common.c              SBSFU image handling: common functionalities/services
   - 2_Images_SBSFU/SBSFU/App/sfu_fwimg_swap.c                SBSFU image handling: FW upgrade without swap area services
   - 2_Images_SBSFU/SBSFU/App/sfu_fwimg_no_swap.c             SBSFU image handling: FW upgrade with swap area services
   - 2_Images_SBSFU/SBSFU/App/sfu_loader.c                    SBSFU Local Loader
   - 2_Images_SBSFU/SBSFU/App/sfu_new_image.c                 SBSFU image handling: new image storage and installation request
   - 2_Images_SBSFU/SBSFU/App/sfu_test.c                      SBSFU security protection automatic test
   - 2_Images_SBSFU/SBSFU/App/app_sfu.h                       Software configuration of SBSFU application
   - 2_Images_SBSFU/SBSFU/App/sfu_boot.h                      Header file for sfu_boot.c
   - 2_Images_SBSFU/SBSFU/App/sfu_com_loader.h                Header file for sfu_com_loader.c
   - 2_Images_SBSFU/SBSFU/App/sfu_com_trace.h                 Header file for sfu_com_trace.c
   - 2_Images_SBSFU/SBSFU/App/sfu_def.h                       General definition for SBSFU application
   - 2_Images_SBSFU/SBSFU/App/sfu_error.h                     Header file for sfu_error.c file
   - 2_Images_SBSFU/SBSFU/App/sfu_fsm_states.h                SBSFU FSM states definitions
   - 2_Images_SBSFU/SBSFU/App/sfu_fwimg_internal.h            Internal definitions for firmware image handling
   - 2_Images_SBSFU/SBSFU/App/sfu_fwimg_regions.h             FLASH regions definitions for image handling
   - 2_Images_SBSFU/SBSFU/App/sfu_fwimg_services.h            Header file for sfu_fwimg_services.c
   - 2_Images_SBSFU/SBSFU/App/sfu_loader.h                    Header file for sfu_loader.c
   - 2_Images_SBSFU/SBSFU/App/sfu_new_image.h                 Header file for sfu_new_image.c
   - 2_Images_SBSFU/SBSFU/App/sfu_standalone_loader.h         Interface through shared memory with standalone loader
   - 2_Images_SBSFU/SBSFU/App/sfu_test.h                      Header file for sfu_test.c
   - 2_Images_SBSFU/SBSFU/App/sfu_trace.h                     Header file for sfu_trace.c
   - 2_Images_SBSFU/SBSFU/Target/sfu_low_level.c              SBSFU general low level interface
   - 2_Images_SBSFU/SBSFU/Target/sfu_low_level_flash.c        SBSFU flash low level interface (wrapper)
   - 2_Images_SBSFU/SBSFU/Target/sfu_low_level_flash_int.c    SBSFU internal flash low level interface
   - 2_Images_SBSFU/SBSFU/Target/sfu_low_level_flash_ext.c    SBSFU external flash low level interface
   - 2_Images_SBSFU/SBSFU/Target/sfu_low_level_security.c     SBSFU security low level interface
   - 2_Images_SBSFU/SBSFU/Target/sfu_low_level.h              Header file for general low level interface
   - 2_Images_SBSFU/SBSFU/Target/sfu_low_level_flash.h        Header file for flash low level interface (wrapper)
   - 2_Images_SBSFU/SBSFU/Target/sfu_low_level_flash_int.h    Header file for internal flash low level interface
   - 2_Images_SBSFU/SBSFU/Target/sfu_low_level_flash_ext.h    Header file for external flash low level interface
   - 2_Images_SBSFU/SBSFU/Target/sfu_low_level_security.h     Header file for security low level interface

@par Hardware and Software environment

   - This example runs on STM32L476xx devices.
   - This example has been tested with STM32L476RG-Nucleo Rev C board and can be easily tailored to any other supported device and
     development board.
   - An up-to-date version of ST-LINK firmware is required. Upgrading ST-LINK firmware is a feature provided by
     STM32Cube programmer available on www.st.com.
   - This example is linked with SE_Core binary generated by Secure Engine Core binary generation project.
   - This example needs a terminal emulator.
   - By default, SBSFU is configured in development mode. To switch in production mode, refer to AN5056 "Integration
     guide - software expansion for STM32Cube" available from the STMicroelectronics microcontroller website
     www.st.com.
   - Microsoft Windows has a limitation whereby paths to files and directories cannot be longer than 256 characters.
     Paths to files exceeding that limits cause tools (e.g. compilers, shell scripts) to fail reading from or writing
     to such files.
     As a workaround, it is advised to use the subst.exe command from within a command prompt to set up a local drive
     out of an existing directory on the hard drive, such as:
     C:\> subst X: <PATH_TO_CUBEFW>\Firmware

@par How to use it ?

Severals steps to run SBSFU application :

1. Compile projects in the following order. This is mandatory as each project requests some objects generated by the
   compilation of the previous one:
   - 2_Images_SECoreBin (see also SECoreBin/readme.txt)
   - 2_Images_SBSFU
   - 2_Images_UserApp (see also UserApp/readme.txt)

2. Before loading SBSFU image into the target, please ensure with STM32CubeProgammer available on www.st.com that the
   following are valid for the device:
   - RDP Level 0
   - PCROP disabled
   - Write Protection disabled on all FLASH pages
   - BFB2 bit disabled
   - Chip has been erased

3. Use a terminal emulator (Tera Term for example, open source free software terminal emulator that can be downloaded
   from https://osdn.net/projects/ttssh2/) for UART connection with the board.
   Support of YMODEM protocol is required. Serial port configuration should be :
   - Baud rate = 115200
   - Data = 8 bits
   - Parity = none
   - Stop = 1 bit
   - Flow control = none

4. Load SBSFU image into target memory with your preferred toolchain or STM32CubeProgammer.

5. Once the SB_SFU software is downloaded, power cycle the board (unplug/plug USB cable) : the SBSFU application starts
   and configures the security mechanisms.

6. Power cycle the board a second time (unplug/plug the USB cable): the SBSFU application starts with the configured
   securities turned on and the Tera Term connection is possible.
   Caution: Make sure to use an up-to-date version of ST-LINK firmware else SBSFU may not start.

7. At startup (Power On or Reset button pushed) welcome information are displayed on terminal emulator.
   Green LED blinks every 3 seconds when a local download is waited.
   Green LED blinks every 250 ms in case of error in option bytes configuration.

8. Send the user encrypted firmware file (\2_Images\2_Images_UserApp\Binary\UserApp.sfb) with Tera Term by using menu
   "File > Transfer > YMODEM > Send..."

Note1 : Press User push-button at reset to force a local download if an application is already installed.
Note2 : TAMPER detection can be very sensitive. Protection may be disabled if too many reset occur during tests.
Note3 : for Linux users Minicom can be used but to do so you need to compile the SBSFU project with the MINICOM_YMODEM
        switch enabled (app_sfu.h)


L476_SBSFU\BFU\Scripts\postbuild.sh
1	#!/bin/bash -
2	echo "Extract SE interface symbols"
3	arm-none-eabi-nm $1 > ../Scripts/nm.txt
4	case "$(uname -s)" in
5	    Linux*|Darwin*)
6	      tr -d '\015' <../Scripts/se_interface.txt > ../Scripts/se_interface_unix.txt
7	      grep -F -f ../Scripts/se_interface_unix.txt nm.txt > ../Scripts/symbol.list
8	      rm ../Scripts/se_interface_unix.txt
9	      ;;
10	    *)
11	      grep -F -f ../Scripts//se_interface.txt ../Scripts/nm.txt > ../Scripts/symbol.list
12	      ;;
13	esac
14	wc -l ../Scripts/symbol.list
15	cat ../Scripts/symbol.list | awk '{split($0,a,/[ \r]/); print a[3]" = 0x"a[1]";"}' > "$2"/Linker/se_interface_app.ld
16	rm ../Scripts/nm.txt
17	rm ../Scripts/symbol.list
18
L476_SBSFU\BFU\Scripts\se_interface.txt

SE_APP_GetActiveFwInfo

L476_SBSFU\BFU\.cproject
1	<?xml version="1.0" encoding="UTF-8" standalone="no"?>
2	<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptio­nStorage">
3		<storageModule moduleId="org.eclipse.cdt.core.settings">
4			<cconfiguration id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.201050759">
5				<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataPro­vider" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.201050759" moduleId="org.eclipse.cdt.core.settings" name="Debug">
6					<externalSettings/>
7					<extensions>
8						<extension id="org.eclipse.cdt.core.ELF" point="org.eclipse.cdt.core.BinaryParser"/>
9						<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
10						<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
11						<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
12						<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
13						<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
14					</extensions>
15				</storageModule>
16				<storageModule moduleId="cdtBuildSystem" version="4.0.0">
17					<configuration artifactExtension="elf" artifactName="SBSFU" buildArtefactType="org.eclipse.cdt.build.core.buildArtefactType.exe" buildProperties="org.eclipse.cdt.build.core.buildArtefactType=org.eclipse.cdt.build.core.buildArtefactType.exe,org.eclipse.cdt.build.core.buildType=org.eclipse.cdt.build.core.buildType.debug" cleanCommand="rm -rf" description="" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.201050759" name="Debug" parent="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug" postbuildStep="&quot;../Scripts/postbuild.sh&quot; &quot;${BuildArtifactFileNam­e}&quot; &quot;../../Common&quot;">
18						<folderInfo id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.201050759." name="/" resourcePath="">
19							<toolChain id="com.st.stm32cube.ide.mcu.gnu.managedbuild.toolchain.exe.debug.1168780828" name="MCU ARM GCC" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.toolchain.exe.debug">
20								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_mcu.1436170708" name="MCU" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_mcu" useByScannerDiscover­y="true" value="STM32L476RGTx" valueType="string"/>
21								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_board.2054864669" name="Board" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_board" useByScannerDiscover­y="false" value="NUCLEO-L476RG" valueType="string"/>
22								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.instructionset.950355077" name="Instruction set" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.instructionset" useByScannerDiscover­y="true" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.instructionset.value.thumb2" valueType="enumerated"/>
23								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.floatabi.269603079" name="Floating-point ABI" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.floatabi" useByScannerDiscover­y="true" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.floatabi.value.hard" valueType="enumerated"/>
24								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.fpu.746973064" name="Floating-point unit" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.fpu" useByScannerDiscover­y="true" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.fpu.value.fpv4-sp-d16" valueType="enumerated"/>
25								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_cpuid.1412013964" name="CPU" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_cpuid" useByScannerDiscover­y="false" value="0" valueType="string"/>
26								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_coreid.803753052" name="Core" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_coreid" useByScannerDiscover­y="false" value="0" valueType="string"/>
27								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.runtimelibrary_c.2084706293" name="Runtime library" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.runtimelibrary_c" useByScannerDiscover­y="true" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.runtimelibrary_c.value.nano_c" valueType="enumerated"/>
28								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.convertbinary.928222933" name="Convert to binary file (-O binary)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.convertbinary" useByScannerDiscover­y="false" value="true" valueType="boolean"/>
29								<targetPlatform archList="all" binaryParser="org.eclipse.cdt.core.ELF" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.targetplatform.2131042267" isAbstract="false" osList="all" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.targetplatform"/>
30								<builder buildPath="${workspace_loc:/STM32L476RG_NUCLEO_2­_Images_SBSFU}/Debug" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.builder.2061082021" keepEnvironmentInBui­ldfile="false" name="Gnu Make Builder" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.builder"/>
31								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.2061403294" name="MCU GCC Assembler" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler">
32									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.debuglevel.930033006" name="Debug level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.debuglevel" useByScannerDiscover­y="false" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.debuglevel.value.g3" valueType="enumerated"/>
33									<inputType id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.input.380640178" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.input"/>
34								</tool>
35								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.1944458139" name="MCU GCC Compiler" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler">
36									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.debuglevel.1155173292" name="Debug level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.debuglevel" useByScannerDiscover­y="false" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.debuglevel.value.g3" valueType="enumerated"/>
37									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level.1278777176" name="Optimization level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level" useByScannerDiscover­y="false" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level.value.os" valueType="enumerated"/>
38									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.ffunction.1183762596" name="Place functions in their own sections (-ffunction-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.ffunction" useByScannerDiscover­y="false" value="true" valueType="boolean"/>
39									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.fdata.718209217" name="Place data in their own sections (-fdata-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.fdata" useByScannerDiscover­y="false" value="false" valueType="boolean"/>
40									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.includepaths.1855031248" name="Include paths (-I)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.includepaths" useByScannerDiscover­y="false" valueType="includePath">
41										<listOptionValue builtIn="false" value="../Application/Core/Inc"/>
42										<listOptionValue builtIn="false" value="../Application/BFU/App"/>
43										<listOptionValue builtIn="false" value="../Application/BFU/Target"/>
44										<listOptionValue builtIn="false" value="../../SECoreBin/Application/Core/Inc"/>
45										<listOptionValue builtIn="false" value="../../Linker_Common/STM32CubeIDE"/>
46										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/BSP/STM32L4xx_Nucleo"/>
47										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/BSP/Components/Common"/>
48										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/CMSIS/Include"/>
49										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/CMSIS/Device/ST/STM32L4xx/Include"/>
50										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Inc"/>
51										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Core"/>
52										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Interface"/>
53									</option>
54									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.definedsymbols.1407238522" name="Define symbols (-D)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.definedsymbols" useByScannerDiscover­y="false" valueType="definedSymbols">
55										<listOptionValue builtIn="false" value="STM32L476xx"/>
56										<listOptionValue builtIn="false" value="USE_HAL_DRIVER"/>
57										<listOptionValue builtIn="false" value="USE_STM32L4XX_NUCLEO­"/>
58									</option>
59									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.otherflags.983391170" name="Other flags" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.otherflags" useByScannerDiscover­y="true" valueType="stringList">
60										<listOptionValue builtIn="false" value="-Wno-format -Wno-strict-aliasing"/>
61									</option>
62									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.languagestandard.1585454215" name="Language standard" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.languagestandard" useByScannerDiscover­y="true" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.languagestandard.value.gnu11" valueType="enumerated"/>
63									<inputType id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.input.c.131292184" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.input.c"/>
64								</tool>
65								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.70207076" name="MCU G++ Compiler" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler">
66									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.debuglevel.324549917" name="Debug level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.debuglevel" useByScannerDiscover­y="false" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.debuglevel.value.g3" valueType="enumerated"/>
67									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.optimization.level.929649824" name="Optimization level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.optimization.level" useByScannerDiscover­y="false" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.optimization.level.value.os" valueType="enumerated"/>
68									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.ffunction.186814919" name="Place functions in their own sections (-ffunction-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.ffunction" useByScannerDiscover­y="false" value="true" valueType="boolean"/>
69									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.fdata.28798079" name="Place data in their own sections (-fdata-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.fdata" useByScannerDiscover­y="false" value="false" valueType="boolean"/>
70									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.noexceptions.1578374321" name="Disable handling exceptions (-fno-exceptions)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.noexceptions" useByScannerDiscover­y="false" value="true" valueType="boolean"/>
71									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.nortti.833076143" name="Disable generation of information about every class with virtual functions (-fno-rtti)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.nortti" useByScannerDiscover­y="false" value="true" valueType="boolean"/>
72									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.includepaths.742763624" name="Include paths (-I)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.includepaths" useByScannerDiscover­y="false" valueType="includePath">
73										<listOptionValue builtIn="false" value="../Application/Core/Inc"/>
74										<listOptionValue builtIn="false" value="../Application/BFU/App"/>
75										<listOptionValue builtIn="false" value="../Application/BFU/Target"/>
76										<listOptionValue builtIn="false" value="../../SECoreBin/Application/Core/Inc"/>
77										<listOptionValue builtIn="false" value="../../Linker_Common/STM32CubeIDE"/>
78										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/BSP/STM32L4xx_Nucleo"/>
79										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/BSP/Components/Common"/>
80										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/CMSIS/Include"/>
81										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/CMSIS/Device/ST/STM32L4xx/Include"/>
82										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Inc"/>
83										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Core"/>
84										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Interface"/>
85									</option>
86									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.definedsymbols.1187492209" name="Define symbols (-D)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.definedsymbols" useByScannerDiscover­y="false" valueType="definedSymbols">
87										<listOptionValue builtIn="false" value="STM32L476xx"/>
88										<listOptionValue builtIn="false" value="USE_HAL_DRIVER"/>
89										<listOptionValue builtIn="false" value="USE_STM32L4XX_NUCLEO­"/>
90									</option>
91									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="true" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.otherflags.1934538424" name="Other flags" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.otherflags" useByScannerDiscover­y="true" valueType="stringList"/>
92								</tool>
93								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.2014903164" name="MCU GCC Linker" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker">
94									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.script.358230755" name="Linker Script (-T)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.script" value="../STM32L476RGTx.ld" valueType="string"/>
95									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.gcsections.1799903718" name="Discard unused sections (-Wl,--gc-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.gcsections" value="true" valueType="boolean"/>
96									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.systemcalls.233049550" name="System calls" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.systemcalls" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.systemcalls.value.minimalimplementatio­n" valueType="enumerated"/>
97									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.otherflags.97986988" name="Other flags" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.otherflags" valueType="stringList">
98										<listOptionValue builtIn="false" value="-Xlinker -L ../../Common/Linker"/>
99									</option>
100									<inputType id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.input.1351923304" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.input">
101										<additionalInput kind="additionalinputdepen­dency" paths="$(USER_OBJS)"/>
102										<additionalInput kind="additionalinput" paths="$(LIBS)"/>
103									</inputType>
104								</tool>
105								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.995053281" name="MCU G++ Linker" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker">
106									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.script.515763128" name="Linker Script (-T)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.script" value="../STM32L476RGTx.ld" valueType="string"/>
107									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.gcsections.1772760474" name="Discard unused sections (-Wl,--gc-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.gcsections" value="true" valueType="boolean"/>
108									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.otherflags.1812971631" name="Other flags" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.otherflags"/>
109								</tool>
110								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.archiver.398615112" name="MCU GCC Archiver" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.archiver"/>
111								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.size.385258338" name="MCU Size" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.size"/>
112								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objdump.listfile.1444959112" name="MCU Output Converter list file" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objdump.listfile"/>
113								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.hex.1026017450" name="MCU Output Converter Hex" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.hex"/>
114								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.binary.1223898031" name="MCU Output Converter Binary" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.binary"/>
115								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.verilog.523649636" name="MCU Output Converter Verilog" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.verilog"/>
116								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.srec.1284615879" name="MCU Output Converter Motorola S-rec" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.srec"/>
117								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.symbolsrec.380561657" name="MCU Output Converter Motorola S-rec with symbols" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.symbolsrec"/>
118							</toolChain>
119						</folderInfo>
120						<sourceEntries>
121							<entry flags="VALUE_WORKSPACE_PATH­" kind="sourcePath" name=""/>
122						</sourceEntries>
123					</configuration>
124				</storageModule>
125				<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
126			</cconfiguration>
127		</storageModule>
128		<storageModule moduleId="cdtBuildSystem" version="4.0.0">
129			<project id="STM32L476RG_NUCLEO_2­_Images_SBSFU.fr.ac6.managedbuild.target.gnu.cross.exe.1277511080" name="Executable"/>
130		</storageModule>
131		<storageModule moduleId="scannerConfiguration­">
132			<autodiscovery enabled="true" problemReportingEnab­led="true" selectedProfileId=""/>
133			<scannerConfigBuildIn­fo instanceId="fr.ac6.managedbuild.config.gnu.cross.exe.debug.6853191;fr.ac6.managedbuild.config.gnu.cross.exe.debug.6853191.;fr.ac6.managedbuild.tool.gnu.cross.c.compiler.919332610;fr.ac6.managedbuild.tool.gnu.cross.c.compiler.input.c.1934159291">
134				<autodiscovery enabled="false" problemReportingEnab­led="true" selectedProfileId=""/>
135			</scannerConfigBuildIn­fo>
136		</storageModule>
137		<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProv­iders"/>
138		<storageModule moduleId="refreshScope" versionNumber="2">
139			<configuration configurationName="Debug">
140				<resource resourceType="PROJECT" workspacePath="/L476_SBSFU_BFU"/>
141			</configuration>
142		</storageModule>
143		<storageModule moduleId="org.eclipse.cdt.make.core.buildtargets"/>
144		<storageModule moduleId="org.eclipse.cdt.internal.ui.text.commentOwnerProjectM­appings"/>
145	</cproject>
L476_SBSFU\BFU\.project
1	<?xml version="1.0" encoding="UTF-8"?>
2	<projectDescription>
3		<name>L476_SBSFU_BFU</name>
4		<comment></comment>
5		<projects>
6		</projects>
7		<buildSpec>
8			<buildCommand>
9				<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
10				<triggers>clean,full,incremental,</triggers>
11				<arguments>
12				</arguments>
13			</buildCommand>
14			<buildCommand>
15				<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder­</name>
16				<triggers>full,incremental,</triggers>
17				<arguments>
18				</arguments>
19			</buildCommand>
20		</buildSpec>
21		<natures>
22			<nature>com.st.stm32cube.ide.mcu.MCUProjectNature</nature>
23			<nature>org.eclipse.cdt.core.cnature</nature>
24			<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
25			<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
26		</natures>
27		<linkedResources>
28			<link>
29				<name>Drivers/CMSIS/system_stm32l4xx.c</name>
30				<type>1</type>
31				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/CMSIS/Device/ST/STM32L4xx/Source/Templates/system_stm32l4xx.c</locationURI>
32			</link>
33			<link>
34				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal.c</name>
35				<type>1</type>
36				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal.c</locationURI>
37			</link>
38			<link>
39				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_adc.c</name>
40				<type>1</type>
41				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_adc.c</locationURI>
42			</link>
43			<link>
44				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_adc_ex­.c</name>
45				<type>1</type>
46				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_adc_ex­.c</locationURI>
47			</link>
48			<link>
49				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_cortex­.c</name>
50				<type>1</type>
51				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_cortex­.c</locationURI>
52			</link>
53			<link>
54				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_crc.c</name>
55				<type>1</type>
56				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_crc.c</locationURI>
57			</link>
58			<link>
59				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_crc_ex­.c</name>
60				<type>1</type>
61				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_crc_ex­.c</locationURI>
62			</link>
63			<link>
64				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_dma.c</name>
65				<type>1</type>
66				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_dma.c</locationURI>
67			</link>
68			<link>
69				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_dma_ex­.c</name>
70				<type>1</type>
71				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_dma_ex­.c</locationURI>
72			</link>
73			<link>
74				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_firewa­ll.c</name>
75				<type>1</type>
76				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_firewa­ll.c</locationURI>
77			</link>
78			<link>
79				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_flash.c</name>
80				<type>1</type>
81				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_flash.c</locationURI>
82			</link>
83			<link>
84				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_flash_­ex.c</name>
85				<type>1</type>
86				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_flash_­ex.c</locationURI>
87			</link>
88			<link>
89				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_gpio.c</name>
90				<type>1</type>
91				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_gpio.c</locationURI>
92			</link>
93			<link>
94				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_i2c.c</name>
95				<type>1</type>
96				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_i2c.c</locationURI>
97			</link>
98			<link>
99				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_i2c_ex­.c</name>
100				<type>1</type>
101				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_i2c_ex­.c</locationURI>
102			</link>
103			<link>
104				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_iwdg.c</name>
105				<type>1</type>
106				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_iwdg.c</locationURI>
107			</link>
108			<link>
109				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_pwr.c</name>
110				<type>1</type>
111				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_pwr.c</locationURI>
112			</link>
113			<link>
114				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_pwr_ex­.c</name>
115				<type>1</type>
116				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_pwr_ex­.c</locationURI>
117			</link>
118			<link>
119				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_rcc.c</name>
120				<type>1</type>
121				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_rcc.c</locationURI>
122			</link>
123			<link>
124				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_rcc_ex­.c</name>
125				<type>1</type>
126				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_rcc_ex­.c</locationURI>
127			</link>
128			<link>
129				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_rtc.c</name>
130				<type>1</type>
131				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_rtc.c</locationURI>
132			</link>
133			<link>
134				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_rtc_ex­.c</name>
135				<type>1</type>
136				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_rtc_ex­.c</locationURI>
137			</link>
138			<link>
139				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_spi.c</name>
140				<type>1</type>
141				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_spi.c</locationURI>
142			</link>
143			<link>
144				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_spi_ex­.c</name>
145				<type>1</type>
146				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_spi_ex­.c</locationURI>
147			</link>
148			<link>
149				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_tim.c</name>
150				<type>1</type>
151				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_tim.c</locationURI>
152			</link>
153			<link>
154				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_tim_ex­.c</name>
155				<type>1</type>
156				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_tim_ex­.c</locationURI>
157			</link>
158			<link>
159				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_uart.c</name>
160				<type>1</type>
161				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_uart.c</locationURI>
162			</link>
163			<link>
164				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_uart_e­x.c</name>
165				<type>1</type>
166				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_uart_e­x.c</locationURI>
167			</link>
168			<link>
169				<name>Middlewares/STM32_Secure_Engine/se_interface_applica­tion.c</name>
170				<type>1</type>
171				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Core/se_interface_applica­tion.c</locationURI>
172			</link>
173			<link>
174				<name>Middlewares/STM32_Secure_Engine/se_interface_bootloa­der.c</name>
175				<type>1</type>
176				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Core/se_interface_bootloa­der.c</locationURI>
177			</link>
178			<link>
179				<name>Middlewares/STM32_Secure_Engine/se_interface_common.c</name>
180				<type>1</type>
181				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Core/se_interface_common.c</locationURI>
182			</link>
183			<link>
184				<name>Drivers/BSP/STM32L4xx_Nucleo/stm32l4xx_nucleo.c</name>
185				<type>1</type>
186				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/BSP/STM32L4xx_Nucleo/stm32l4xx_nucleo.c</locationURI>
187			</link>
188		</linkedResources>
189	</projectDescription>
190
L476_SBSFU\BFU\STM32L476RGTx.ld

/*
*****************************************************************************
**
**  File        : LinkerScript.ld
**
**  Abstract    : Linker script for STM32L476RGTx Device with
**                1024KByte FLASH, 96KByte RAM
**
**                Set heap size, stack size and stack location according
**                to application requirements.
**
**                Set memory bank area and size if external memory is used.
**
**  Target      : STMicroelectronics STM32
**
**
**  Distribution: The file is distributed as is, without any warranty
**                of any kind.
**
**  (c)Copyright Ac6.
**  You may use this file as-is or modify it according to the needs of your
**  project. Distribution of this file (unmodified or modified) is not
**  permitted. Ac6 permit registered System Workbench for MCU users the
**  rights to distribute the assembled, compiled & linked contents of this
**  file as part of an application binary file, provided that it is built
**  using the System Workbench for MCU toolchain.
**
*****************************************************************************
*/

/* Entry Point */
ENTRY(Reset_Handler)

/* Highest address of the user mode stack */
_estack = 0x20018000;    /* end of SB_SRAM1 */

/* Generate a link error if heap and stack don't fit into RAM */
_Min_Heap_Size = 0;      /* required amount of heap  */
_Min_Stack_Size = 0x2000; /* required amount of stack */

INCLUDE mapping_fwimg.ld
INCLUDE mapping_sbsfu.ld

/* Specific SBSFU definition */
__ICFEDIT_intvec_start__    = 0x08000000;
SE_Binary_region_ROM_Length = __ICFEDIT_SE_Code_region_ROM_end__ - __ICFEDIT_SE_CallGate_region_ROM_start__ + 1;

/* Specify the memory areas */
MEMORY
{
 ISR_VECTOR (rx)               : ORIGIN = __ICFEDIT_intvec_start__, LENGTH = VECTOR_SIZE
 SE_Binary_region_ROM (rx)     : ORIGIN = __ICFEDIT_SE_CallGate_region_ROM_start__, LENGTH = SE_Binary_region_ROM_Length
}

/* Define output sections */
SECTIONS
{
  /* The startup code goes first into FLASH */
  .isr_vector :
  {
    . = ALIGN(8);
    KEEP(*(.isr_vector)) /* Startup code */
    . = ALIGN(8);
  } >ISR_VECTOR
  .text.SE_CORE_Bin :
  {
    SE_CORE_Bin_start = .;
    KEEP(*(SE_CORE_Bin));
    SE_CORE_Bin_end = .;
  } > SE_Binary_region_ROM
  .SE_IF_Code : { KEEP(*se_interface_application.o (.text .text*))
                  KEEP(*se_interface_bootloader.o (.text .text*))
                  KEEP(*se_interface_common.o (.text .text*))
  } >SE_IF_region_ROM
  .text :
  {
    . = ALIGN(8);
    *(.text)           /* .text sections (code) */
    *(.text*)          /* .text* sections (code) */
    *(.glue_7)         /* glue arm to thumb code */
    *(.glue_7t)        /* glue thumb to arm code */
    *(.eh_frame)

    KEEP (*(.init))
    KEEP (*(.fini))

    . = ALIGN(8);
    _etext = .;        /* define a global symbols at end of code */
  } >SB_ROM_region

  /* Constant data goes into FLASH */
  .rodata :
  {
    . = ALIGN(8);
    *(.rodata)         /* .rodata sections (constants, strings, etc.) */
    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */
    . = ALIGN(8);
  } >SB_ROM_region

  .ARM.extab (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
  . = ALIGN(8);
  *(.ARM.extab* .gnu.linkonce.armextab.*)
  . = ALIGN(8);
  } >SB_ROM_region

  .ARM (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
	. = ALIGN(8);
    __exidx_start = .;
    *(.ARM.exidx*)
    __exidx_end = .;
	. = ALIGN(8);
  } >SB_ROM_region

  .preinit_array (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
	. = ALIGN(8);
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP (*(.preinit_array*))
    PROVIDE_HIDDEN (__preinit_array_end = .);
	. = ALIGN(8);
  } >SB_ROM_region

  .init_array (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
	. = ALIGN(8);
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP (*(SORT(.init_array.*)))
    KEEP (*(.init_array*))
    PROVIDE_HIDDEN (__init_array_end = .);
	. = ALIGN(8);
  } >SB_ROM_region

  .fini_array (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
	. = ALIGN(8);
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP (*(SORT(.fini_array.*)))
    KEEP (*(.fini_array*))
    PROVIDE_HIDDEN (__fini_array_end = .);
	. = ALIGN(8);
  } >SB_ROM_region

  /* used by the startup to initialize data */
  _sidata = LOADADDR(.data);

  /* Initialized data sections goes into RAM, load LMA copy after code */
  .data :
  {
    . = ALIGN(8);
    _sdata = .;        /* create a global symbol at data start */
    *(.data)           /* .data sections */
    *(.data*)          /* .data* sections */

    . = ALIGN(8);
    _edata = .;        /* define a global symbol at data end */
  } >SB_RAM_region AT>SB_ROM_region


  /* Uninitialized data section */
  . = ALIGN(4);
  .bss :
  {
    /* This is used by the startup in order to initialize the .bss section */
    _sbss = .;         /* define a global symbol at bss start */
    __bss_start__ = _sbss;
    *(.bss)
    *(.bss*)
    *(COMMON)

    . = ALIGN(4);
    _ebss = .;         /* define a global symbol at bss end */
    __bss_end__ = _ebss;
  } >SB_RAM_region

  /* User_heap_stack section, used to check that there is enough RAM left */
  ._user_heap_stack :
  {
    . = ALIGN(8);
    PROVIDE ( end = . );
    PROVIDE ( _end = . );
    . = . + _Min_Heap_Size;
    . = . + _Min_Stack_Size;
    . = ALIGN(8);
  } >SB_RAM_region



  /* Remove information from the standard libraries */
  /DISCARD/ :
  {
    libc.a ( * )
    libm.a ( * )
    libgcc.a ( * )
  }

  .ARM.attributes 0 : { *(.ARM.attributes) }
}



L476_SBSFU\Common\Binary_Keys\ECCKEY1.txt

-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIIEobnAEKh92mvSE+X70hQMvFb8LOg+TGB9Dqu4dyvO8oAoGCCqGSM49
AwEHoUQDQgAEuvKX+D7jB9wWw3F4HfGwPvCVsERUEoFI+yxmuVQ9pUroJgR2tzeL
PEbY/WpjYXxGw33pRkQxbtfhbbpw7US6Ag==
-----END EC PRIVATE KEY-----

L476_SBSFU\Common\KeysAndImages_Util\keys.py
1	# Copyright(c) 2018 STMicroelectronics International N.V.
2	# Copyright 2017 Linaro Limited
3	#
4	# Licensed under the Apache License, Version 2.0 (the "License");
5	# you may not use this file except in compliance with the License.
6	# You may obtain a copy of the License at
7	#
8	#     http://www.apache.org/licenses/LICENSE-2.0
9	#
10	# Unless required by applicable law or agreed to in writing, software
11	# distributed under the License is distributed on an "AS IS" BASIS,
12	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13	# See the License for the specific language governing permissions and
14	# limitations under the License.
15
16	import os
17	from Cryptodome.Cipher import AES
18	from Cryptodome.Hash import SHA256
19	from ecdsa import SigningKey, NIST256p, util
20	import hashlib
21	from struct import pack
22	import translate_key
23	import numpy
24	#for AES_CBC lambda pad to 16 bytes by adding the padded value
25	#(i.e 24 bytes : 0x08 is added  8 times
26	BS = 16
27	pad = lambda s: s + (BS - len(s) % BS) * pack("B", 0)
28
29	class AES_CBC():
30	    def __init__(self, key):
31	        """Construct an AES_CBC private key with the given key data"""
32	        self.key = key
33	        self.nonce = []
34	    @staticmethod
35	    def generate():
36	        #use random from platform
37	        return AES_CBC(os.urandom(16))
38	    def export_private(self, path):
39	        if "AES_CBC" not in path:
40	          print("path does not contains AES_CBC : AES_CBC key should contain AES_CBC string!!!")
41	          exit(1)
42	        else:
43	          with open(path, 'wb') as f:
44	             f.write(self.key)
45	    def encrypt(self, payload, nonce=[]):
46	        if payload == []:
47	            print("error")
48	        #Fix me AES CBC is possibly 12 bytes
49	        if nonce == []:
50	            nonce = os.urandom(16)
51	        m = hashlib.sha256()
52	        print("block size ="+str(AES.block_size))
53	        encryptor = AES.new(self.key, AES.MODE_CBC, nonce)
54	        encrypted = ""
55	        #check if buffer size is aligned on BS size
56	        if (0 == (len(payload) % BS)):
57	          # we do not need to pad
58	          buffer=payload
59	          encrypted =  encryptor.encrypt(buffer)
60	        else:
61	          # Buffer size is not correct (and we do not support ciphertext stealing mode "CBC-CS2" specified in NIST SP 800-38A any more)
62	          raise Exception("AES CBC encryption requires the Firmware Image size to be a multiple of the AES block size (16 bytes)")
63	        #compute sh256 on clear buffer without padding
64	        m.update(payload)
65	        signature = m.digest()
66	        #swap the last two block and truncate if required
67	        return encrypted,signature, nonce
68	    def trans(self,section, name, end, assembly, version):
69	        outcode = translate_key.function(section, name,assembly)
70	        outcode += translate_key.translate(self.key,end,assembly, version)
71	        return outcode
72	    def has_nonce(self):
73	        return True
74	    def has_sign(self):
75	        return False
76	    def has_encrypt(self):
77	        return True
78	    def get_key(self, type):
79	        return self.key
80
81	class AES_CTR():
82	    def __init__(self, key):
83	        """Construct an AES_CTR private key with the given key data"""
84	        self.key = key
85	        self.nonce = []
86	    @staticmethod
87	    def generate():
88	        #use random from platform
89	        return AES_CTR(os.urandom(16))
90	    def export_private(self, path):
91	        if "AES_CTR" not in path:
92	          print("path does not contains AES_CTR : AES_CTR key should contain AES_CTR string!!!")
93	          exit(1)
94	        else:
95	          with open(path, 'wb') as f:
96	             f.write(self.key)
97	    def encrypt(self, payload, address, nonce=[]):
98	        if payload == []:
99	          print("error")
100	        m = hashlib.sha256()
101	        #Swap bytes inside 16 bytes block
102	        inarr = numpy.asarray(list(payload), numpy.int8).reshape(-1, 16)
103	        outarr = numpy.fliplr(inarr)
104	        payload = bytearray(outarr)
105	        print("block size ="+str(AES.block_size))
106	        #Encryption
107	        if nonce == []:
108	          encryptor = AES.new(self.key, AES.MODE_CTR, initial_value=address);
109	        else:
110	          encryptor = AES.new(self.key, AES.MODE_CTR, nonce=nonce, initial_value=address);
111	        encrypted = ""
112	        #check if buffer size is aligned on BS size
113	        if (0 == (len(payload) % BS)):
114	          # we do not need to pad
115	          buffer=payload
116	          encrypted =  encryptor.encrypt(buffer)
117	          nonce = encryptor.nonce
118	        else:
119	          raise Exception("AES CTR encryption requires the Firmware Image size to be a multiple of the AES block size (16 bytes)")
120	        #Swap bytes inside 16 bytes block
121	        inarr = numpy.asarray(list(encrypted), numpy.int8).reshape(-1, 16)
122	        outarr = numpy.fliplr(inarr)
123	        encrypted = bytearray(outarr)
124	        #compute sh256 on encrypted buffer without padding
125	        m.update(encrypted)
126	        signature = m.digest()
127	        #swap the last two block and truncate if required
128	        return encrypted,signature,nonce
129	    def trans(self,section, name, end, assembly, version):
130	        outcode = translate_key.function(section, name,assembly)
131	        outcode += translate_key.translate(self.key,end,assembly, version)
132	        return outcode
133	    def has_nonce(self):
134	        return True
135	    def has_sign(self):
136	        return False
137	    def has_encrypt(self):
138	        return True
139	    def get_key(self, type):
140	        return self.key
141
142	class AES_GCM():
143	    def __init__(self, key):
144	        """Construct an AES_GCM private key with the given key data"""
145	        self.key = key
146	        self.nonce = []
147	    @staticmethod
148	    def generate():
149	        #use random from platform
150	        return AES_GCM(os.urandom(16))
151	    def export_private(self, path):
152	        if "AES_CBC" in path:
153	          print("path contains AES_CBC : AES_GCM key should not contain AES_CBC!!!")
154	          exit(1)
155	        else:
156	          with open(path, 'wb') as f:
157	              f.write(self.key)
158	    def encrypt(self, payload, nonce=[]):
159	        if payload == []:
160	            print("error")
161
162	        if nonce == []:
163	            nonce = os.urandom(12)
164	        encryptor = AES.new(self.key, AES.MODE_GCM, nonce)
165	        encrypted = encryptor.encrypt(payload)
166	        signature = encryptor.digest()
167	        return encrypted,signature, nonce
168	    def sign(self,payload, nonce):
169	        encryptor = AES.new(self.key, AES.MODE_GCM, nonce)
170	        encryptor.update(payload)
171	        signature =  encryptor.digest()
172	        return signature, nonce
173	    def trans(self,section, name, end, assembly, version):
174	        outcode = translate_key.function(section, name,assembly)
175	        outcode += translate_key.translate(self.key,end,assembly, version)
176	        return outcode
177	    def has_nonce(self):
178	        return True
179	    def has_sign(self):
180	        return True
181	    def has_encrypt(self):
182	        return True
183	    def get_key(self, type):
184	        return self.key
185
186
187	class ECDSA256P1():
188	    def __init__(self, key):
189	        """Construct an ECDSA P-256 private key"""
190	        self.key = key
191
192	    @staticmethod
193	    def generate():
194	        return ECDSA256P1(SigningKey.generate(curve=NIST256p))
195
196	    def export_private(self, path):
197	        with open(path, 'wb') as f:
198	            f.write(self.key.to_pem())
199	    def trans(self,section, name, end, assembly, version):
200	        vk = self.key.get_verifying_key()
201	        binarykey = vk.to_string()
202	        #generate asm code
203	        outcode = translate_key.function(section, name,assembly)
204	        outcode += translate_key.translate(binarykey,end,assembly, version )
205	        return outcode
206
207	    def sign(self, payload):
208	        # To make this fixed length, possibly pad with zeros.
209	        sig = self.key.sign(payload, hashfunc=hashlib.sha256)
210	        return sig
211
212	    def has_nonce(self):
213	        return False
214	    def has_sign(self):
215	        return True
216
217	    def has_encrypt(self):
218	        return False
219
220	    def get_key(self, type):
221	        if (type == "public"):
222	            vk = self.key.get_verifying_key()
223	            return vk.to_string()
224	        else:
225	            return self.key.to_pem()
226
227	class PAIRING():
228	    def __init__(self, key):
229	        """Construct an PAIRING private key with the given key data"""
230	        self.key = key
231	        self.nonce = []
232	    @staticmethod
233	    def generate():
234	        print("Pairing class unsupported !!")
235	        exit(1)
236	    def export_private(self, path):
237	        print("Pairing class unsupported !!")
238	        exit(1)
239	    def encrypt(self, payload, nonce=[]):
240	        print("Pairing class unsupported !!")
241	        exit(1)
242	    def sign(self,payload, nonce):
243	        print("Pairing class unsupported !!")
244	        exit(1)
245	    def trans(self,section, name, end, assembly, version):
246	        outcode = translate_key.function(section, name,assembly)
247	        outcode += translate_key.translate(self.key,end,assembly, version)
248	        return outcode
249	    def has_nonce(self):
250	        print("Pairing class unsupported !!")
251	        exit(1)
252	    def has_sign(self):
253	        print("Pairing class unsupported !!")
254	        exit(1)
255	    def has_encrypt(self):
256	        print("Pairing class unsupported !!")
257	        exit(1)
258	    def get_key(self, type):
259	        return self.key
260
261	def load(path):
262	    with open(path, 'rb') as f:
263	        pem = f.read()
264	    if len(pem) == 16:
265	        if "AES_CBC" in path:
266	          return AES_CBC(pem)
267	        elif "AES_CTR" in path:
268	          return AES_CTR(pem)
269	        else:
270	          return AES_GCM(pem)
271	    elif len(pem) == 32:
272	        return PAIRING(pem)
273	    else:
274	        key = SigningKey.from_pem(pem)
275	        if key.curve.name == 'NIST256p':
276	            return ECDSA256P1(key)
277	        else:
278	            raise Exception("Unsupported")
279
280
281
L476_SBSFU\Common\KeysAndImages_Util\prepareimage.py
1	# Copyright(c) 2018 STMicroelectronics International N.V.
2	# Copyright 2017 Linaro Limited
3	#
4	# Licensed under the Apache License, Version 2.0 (the "License");
5	# you may not use this file except in compliance with the License.
6	# You may obtain a copy of the License at
7	#
8	#     http://www.apache.org/licenses/LICENSE-2.0
9	#
10	# Unless required by applicable law or agreed to in writing, software
11	# distributed under the License is distributed on an "AS IS" BASIS,
12	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13	# See the License for the specific language governing permissions and
14	# limitations under the License.
15	#
16	import keys
17	import sys
18	import argparse
19	import os
20	import hashlib
21	import numpy
22	import elftools
23	#import string
24	from elftools.elf.elffile import ELFFile
25	from struct import pack
26
27	def gen_ecdsa_p256(args):
28	    keys.ECDSA256P1.generate().export_private(args.key)
29
30	def gen_aes_gcm(args):
31	    keys.AES_GCM.generate().export_private(args.key)
32
33	def gen_aes_cbc(args):
34	    keys.AES_CBC.generate().export_private(args.key)
35
36	def gen_aes_ctr(args):
37	    keys.AES_CTR.generate().export_private(args.key)
38
39
40	keygens = {
41	        'aes-gcm': gen_aes_gcm,
42	        'aes-cbc': gen_aes_cbc,
43	        'aes-ctr': gen_aes_ctr,
44	        'ecdsa-p256': gen_ecdsa_p256,
45	        }
46
47	def do_keygen(args):
48	    if args.type not in keygens:
49	        msg = "Unexpected key type: {}".format(args.type)
50	        raise argparse.ArgumentTypeError(msg)
51	    keygens[args.type](args)
52
53	def do_trans(args):
54	    key = keys.load(args.key)
55	    end = False
56	    if args.end:
57	        end = True
58	    if args.assembly=="ARM" or args.assembly=="IAR" or args.assembly=="GNU":
59	        if args.version=="V6M" or args.version=="V7M":
60	          out = key.trans(args.section, args.function, end, args.assembly, args.version)
61	          print (str(out))
62	        else:
63	          print ("-v option : Cortex M architecture not supported")
64	          exit(1)
65	    else:
66	        print ("-a option : assembly option not supported")
67	        exit(1)
68
69	def do_getpub(args):
70	    key = keys.load(args.key)
71	    key.emit_c()
72
73	def do_sign(args):
74	    payload = []
75	    with open(args.infile, 'rb') as f:
76	        payload = f.read()
77	    # Removing the padding because the hashlib pads properly (512 bit alignment) for SHA256
78	    # payload = pad(payload)
79	    key = keys.load(args.key) if args.key else None
80	    if key.has_sign():
81	        if key.has_nonce():
82	            nonce = []
83	            try:
84	                with open(args.nonce, 'rb') as f:
85	                    nonce = f.read()
86	            except:
87	                nonce= []
88	            encrytpted, signature , nonce_used = key.encrypt( payload, nonce)
89	            if nonce !=nonce_used:
90	                try:
91	                    f = open(args.nonce, 'wb')
92	                    f.write(nonce_used)
93	                    f.close()
94	                except:
95	                    print("nonce filename required")
96	                    exit(1)
97	        else:
98	            signature  = key.sign(payload)
99	        f = open(args.outfile,"wb")
100	        f.write(signature)
101	        f.close()
102	    else:
103	        print("Provided Key is not usable to sign ")
104	        exit(1)
105
106
107	def do_sha(args):
108	    payload = []
109	    with open(args.infile, 'rb') as f:
110	        payload = f.read()
111	    m = hashlib.sha256()
112	    buffer=payload
113	    m.update(buffer)
114	    signature = m.digest()
115	    f = open(args.outfile, "wb")
116	    f.write(signature)
117	    f.close()
118
119	def do_encrypt(args):
120	    payload = []
121	    with open(args.infile, 'rb') as f:
122	        payload = f.read()
123	        f.close()
124	    key = keys.load(args.key) if args.key else None
125	    if key.has_encrypt():
126	        if key.has_nonce():
127	            nonce = []
128	            if args.nonce and args.iv:
129	                print("either IV or Nonce Required for this key!!!")
130	                exit(1)
131	            if args.nonce:
132	                iv_nonce=args.nonce
133	            elif args.iv:
134	                iv_nonce=args.iv
135	            else:
136	                print("either IV or Nonce Required for this key!!!")
137	                exit(1)
138	            if os.path.isfile(iv_nonce):
139	                with open(iv_nonce, 'rb') as f:
140	                    nonce = f.read()
141	            if args.poffset:
142	                with open(args.poffset, 'r') as f:
143	                  offset = int(f.read())
144	                # AES CTR : remove 4 LSB bits to the address
145	                offset = int(offset / 16)
146	            else:
147	                offset = 0
148	            if args.address:
149	                address = args.address + offset
150	                encrypted , signature , nonce_used = key.encrypt(payload, address, nonce)
151	            else:
152	                encrypted , signature , nonce_used = key.encrypt(payload, nonce)
153	            if nonce !=nonce_used:
154	                f = open(iv_nonce, 'wb')
155	                f.write(nonce_used)
156	                f.close()
157	        else:
158	            encrypted ,signature = key.encrypt(payload)
159
160	        f=open(args.outfile,"wb")
161	        f.write(encrypted)
162	        f.close()
163	    else:
164	        print("Key does not support encrypt")
165	        exit(1)
166
167	def do_header_lib(args):
168	    if (os.path.isfile(args.firmware)):
169	        size = os.path.getsize(args.firmware)
170	    else:
171	        print("no fw file")
172	        exit(1)
173	    if os.path.isfile(args.tag):
174	        f=open(args.tag, 'rb')
175	        tag = f.read()
176	    if args.cert_fw_leaf :
177	      if os.path.isfile(args.cert_fw_leaf):
178	          print("Loading cert: "+args.cert_fw_leaf)
179	          f=open(args.cert_fw_leaf, 'rb')
180	          cert_fw_leaf = f.read()
181	    if args.cert_fw_inter :
182	      if os.path.isfile(args.cert_fw_inter):
183	          print("Loading cert: "+args.cert_fw_inter)
184	          f=open(args.cert_fw_inter, 'rb')
185	          cert_fw_inter = f.read()
186
187	    key = keys.load(args.key) if args.key else None
188	    #empty nonce
189	    nonce = b''
190	    protocol = args.protocol
191	    magic = args.magic.encode()
192	    version = args.version
193	    reserved = b'\0'*args.reserved
194	    if args.nonce and args.iv:
195	        print("either IV or Nonce Required !!!")
196	        exit(1)
197	    iv_nonce=""
198	    if args.nonce:
199	        iv_nonce=args.nonce
200	    elif args.iv:
201	        iv_nonce=args.iv
202	    if iv_nonce:
203	        with open(iv_nonce, 'rb') as f:
204	            nonce = f.read()
205	    if args.pfw:
206	        pfwsize = os.path.getsize(args.pfw)
207	    else:
208	        pfwsize = size
209	    if args.poffset:
210	        with open(args.poffset, 'r') as f:
211	            pfwoffset = int(f.read())
212	    else:
213	        pfwoffset = 0
214	    if args.ptag:
215	        f=open(args.ptag, 'rb')
216	        pfwtag = f.read()
217	        f.close()
218	    else:
219	        pfwtag=tag
220	    print("Magic: "+str(magic)+"!!")
221	    header = pack('<'+str(len(magic))+'sHHIII'+str(len(tag))+'s'+str(len(pfwtag))+'s'+str(len(nonce))+'s'+str(args.reserved)+'s',
222	                    magic, protocol, version, size, pfwoffset, pfwsize, tag, pfwtag, nonce, reserved)
223	    #add certs
224	    # Add certificates
225	    if args.cert_fw_leaf :
226	        print("adding leaf cert of length "+str(str(len(cert_fw_leaf))))
227	        header +=pack(str(len(cert_fw_leaf))+'s',cert_fw_leaf)
228	    if args.cert_fw_inter :
229	        print("adding intermediate cert of length "+str(str(len(cert_fw_inter))))
230	        header +=pack(str(len(cert_fw_inter))+'s',cert_fw_inter)
231	    # Pad, leaving 64 bytes for signature + 3*32 bytes for image state + 32 Fingerprint
232	    if (args.cert_fw_leaf or args.cert_fw_inter):
233	        if 'pack' in args.subcmd:
234	            padding = args.offset - (len(header) + 3*32 + 32 + 64)
235	        else:
236	            padding = args.offset - (len(header) + 3*32 + 32 + 64)
237	        if (padding<0):
238	            print("Invalid padding: "+str(padding))
239	            exit(1)
240	        else:
241	            print("Adding padding: "+str(padding))
242	        header += b'\0'*padding
243	    #GCM needs Nonce to sign
244	    #AES cannot sign
245	    if key.has_sign():
246	        if key.has_nonce() and iv_nonce=="":
247	            print("sign key required nonce, provide nonce")
248	            exit(1)
249	        if key.has_nonce():
250	            if nonce != b'':
251	                signature , nonce_used = key.sign(header, nonce)
252	                if nonce_used !=nonce:
253	                    print("error nonce used differs")
254	                    exit(1)
255	            else:
256	                print("nonce required for this key")
257	                exit(1)
258	        else:
259	            signature = key.sign(header)
260	        header +=pack(str(len(signature))+'s',signature)
261	    else:
262	        print("Provided Key is not usable to sign header")
263	        exit(1)
264
265	    if 'pack' in args.subcmd:
266	        # image state = new
267	        header += b'\xFF'*96
268	    else:
269	        # image state = valid
270	        header += b'\xFF'*32
271	        header += b'\x00'*64
272	    # UpdateSourceFingerpr­int - init to 0x00
273	    header += b'\x00'*32
274	    return header, signature
275
276	#header is used only to build install header for merge .elf tool
277	def do_header(args):
278	    header ,signature  = do_header_lib(args)
279	    f=open(args.outfile,"wb")
280	    if len(signature) == 16:
281	        signature = 2*signature
282	    elif len(signature) == 64:
283	        signature = signature[0:32]
284	    else:
285	        print("Unexpected signature size : "+str(len(signature))+"!!")
286	    f.write(header)
287	    padding = args.offset - (len(header))
288	    while (padding != 0):
289	        f.write(b'\xff')
290	        padding = padding - 1
291	    f.close()
292
293	def do_conf(args):
294	    if (os.path.isfile(args.infile)):
295	        f = open(args.infile)
296	        for myline in f:
297	            if args.define in myline:
298	                myword = myline.split()
299	                if myword[1] == args.define:
300	                    print(myword[2])
301	                    f.close()
302	                    return
303	        f.close()
304	        print("#DEFINE "+args.define+" not found")
305	        exit(1)
306
307	def do_extract(args):
308	    if (os.path.isfile(args.infile)):
309	        f = open(args.infile)
310	        for myline in f:
311	            if args.define in myline:
312	                myword = myline.split('0x')
313	                print('0x'+ myword[1][:8])
314	                f.close()
315	                return
316	        f.close()
317	        print(args.define+" not found")
318	        exit(1)
319
320	def do_pack(args):
321	    header,signature = do_header_lib(args)
322	    f=open(args.outfile,"wb")
323	    f.write(header)
324	    if len(header) > args.offset:
325	        print("error header is larger than offset before binary")
326	        sys.exit(1)
327
328	    #create the string to padd
329	    tmp = (args.offset-len(header))*b'\xff'
330	    #write to file
331	    f.write(tmp)
332	    if args.pfw:
333	        #recopy encrypted partial file
334	        binary=open(args.pfw,'rb')
335	    else:
336	        #recopy encrypted complete file
337	        binary=open(args.firmware,'rb')
338	    tmp=binary.read()
339	    f.write(tmp)
340	    binary.close()
341	#find lowest sction to fix base address not matching
342	def find_lowest_section(elffile):
343	     lowest_addr = 0
344	     lowest_size = 0
345	     for s in elffile.iter_sections():
346	        if (s.header['sh_flags'] & elftools.elf.constants.SH_FLAGS.SHF_ALLOC) and (s.header.sh_type != 'SHT_NOBITS'):
347	            sh_addr =  s.header['sh_addr'];
348	            if lowest_addr == 0:
349	                lowest_addr = sh_addr
350	            elif sh_addr < lowest_addr:
351	                lowest_addr = sh_addr
352	                lowest_size = s.header['sh_size']
353	     return lowest_addr, lowest_size
354
355	#return base address of segment, and a binary array,
356	#add padding pattern
357	def get_binary(elffile,pad=0xff, elftype=0):
358	    num = elffile.num_segments()
359	    print("number of segment :"+str(num))
360	    for i in range(0,num):
361	        segment= elffile.get_segment(i)
362	        if segment['p_type'] == 'PT_LOAD':
363	          if i!=0:
364	            print(hex(nextaddress))
365	            if (len(segment.data())):
366	                padd_size=segment.__getitem__("p_paddr")- nextaddress
367	                binary+=padd_size*pack("B",pad)
368	                binary+=segment.data()
369	                nextaddress = segment.__getitem__("p_paddr") + len(segment.data())
370	          else:
371	            binary=segment.data()
372	            if elftype == 0:
373	              base_address =  segment.__getitem__("p_paddr")
374	            else:
375	              base_address , lowest_size =  find_lowest_section(elffile)
376	              offset = base_address - segment.__getitem__("p_paddr")
377	              binary = binary[offset:]
378	            nextaddress = base_address + len(binary)
379	    return binary, base_address
380
381	def do_merge(args):
382	    #get the different element to compute the big binary
383	    if args.userapp:
384	      with open(args.userapp, 'rb') as f:
385	          # get the data
386	          my_elffile = ELFFile(f)
387	          appli_binary, appli_base = get_binary(my_elffile, args.value,args.elf)
388	    with open(args.sbsfu, 'rb') as f:
389	        my_elffile = ELFFile(f)
390	        sbsfu_binary, sbsfu_base = get_binary(my_elffile, args.value, args.elf)
391	    with open(args.install, 'rb') as f:
392	        header_binary = f.read()
393	    if args.loader:
394	        with open(args.loader, 'rb') as f:
395	            # get the data
396	            my_elffile = ELFFile(f)
397	            loader_binary, loader_base = get_binary(my_elffile, args.value,args.elf)
398	    #merge the three or four elements and padd in between , add some extra byte to
399	    #appli for aes cbc support
400	    address_just_after_s­bsfu = len(sbsfu_binary)+sbsfu_base
401	    if args.loader:
402	        beginaddress_loader = loader_base
403	        address_just_after_l­oader = len(loader_binary)+loader_base
404	    if args.header:
405	      beginaddress_header = args.header
406	    else:
407	      beginaddress_header = appli_base - len(header_binary)
408	    if args.loader and (beginaddress_loader < address_just_after_s­bsfu):
409	        print("sbsfu is too large to merge with loader !!")
410	        exit(2)
411	    elif args.loader and (beginaddress_header < address_just_after_l­oader):
412	        print("loader is too large to merge with appli !!")
413	        exit(3)
414	    else:
415	        print("Merging")
416	        print("SBSFU Base = "+hex(sbsfu_base))
417	        if args.loader:
418	            print("Loader Base = "+hex(loader_base))
419	        print("Writing header = "+hex(beginaddress_header))
420	        if args.userapp:
421	            print("APPLI Base = "+hex(appli_base))
422	        if args.loader:
423	            padd_before_loader = beginaddress_loader - address_just_after_s­bsfu
424	            padd_before_header =   beginaddress_header - address_just_after_l­oader
425	            big_binary = sbsfu_binary + padd_before_loader * pack("B",args.value)+ loader_binary + padd_before_header * pack("B",args.value) + header_binary + appli_binary
426	        elif args.header:
427	            if args.userapp:
428	                # header not contiguous : SBSFU + pad + header + pad + header(fake) + UserApp
429	                padd_before_header = beginaddress_header - address_just_after_s­bsfu
430	                padd_before_appli = appli_base - len(header_binary) - padd_before_header - len(header_binary) - address_just_after_s­bsfu
431	                big_binary = sbsfu_binary + padd_before_header * pack("B",args.value) + header_binary + padd_before_appli * pack("B",args.value) + header_binary + appli_binary
432	            else:
433	                # header not contiguous : SBSFU + header + SBSFU (loader part)
434	                offset_header = beginaddress_header - sbsfu_base
435	                big_binary = sbsfu_binary[:offset_header] + header_binary + sbsfu_binary[offset_header + len(header_binary):]
436	        else:
437	            padd_before_header =   beginaddress_header - address_just_after_s­bsfu
438	            big_binary = sbsfu_binary + padd_before_header * pack("B",args.value) + header_binary + appli_binary
439
440	    print("Writing to "+str(args.outfile)+" "+str(len(big_binary)))
441	    with open(args.outfile, 'wb') as f:
442	        f.write(big_binary)
443
444	def sub_mergev2(args, bb_dict, bin, bin_base, bin_end):
445	    #print("Current BB : "+hex(bb_dict["bb_base"])+" > "+hex(bb_dict["bb_end"]))
446	    #print("Add segment: "+hex(bin_base)+" > "+hex(bin_end))
447	    # injection
448	    # 6 cases:
449	    #  Elf is strictly inside BB range  => First check there is no useful data in BB range that will be erased by elf file, then copy elf contents into BB
450	    if (bin_base > bb_dict["bb_base"]) and (bin_end < bb_dict["bb_end"]):
451	        # Check overlap data
452	        overlapzone = bb_dict["big_binary"][bin_base-bb_dict["bb_base"]+1:(bin_base-bb_dict["bb_base"])+len(bin)-1]
453	        for b in overlapzone:
454	          if b != args.value:
455	            print("ERROR: overlapped zone is not empty")
456	            exit(3)
457	        # Create new BB
458	        bb_dict["big_binary"] = bb_dict["big_binary"][:bin_base-bb_dict["bb_base"]] + bin + bb_dict["big_binary"][(bin_base-bb_dict["bb_base"])+len(bin):]
459	        # bb_dict["bb_base"] and bb_dict["bb_end"] do not change
460	    #  Elf is before BB range  => No issue, paste both with padding in between
461	    elif (bin_end <= bb_dict["bb_base"]):
462	        bb_dict["big_binary"] = bin + (bb_dict["bb_base"] - bin_end) * pack("B",args.value) + bb_dict["big_binary"]
463	        bb_dict["bb_base"] = bin_base
464	        # bb_dict["bb_end"] do not change
465	    #  Elf is after BB range   => No issue, paste both with padding in between
466	    elif (bin_base >= bb_dict["bb_end"]):
467	        bb_dict["big_binary"] = bb_dict["big_binary"] + (bin_base - bb_dict["bb_end"]) * pack("B",args.value) + bin
468	        bb_dict["bb_end"] = bin_end
469	        # bb_start do not change
470	    #  Elf starts before BB start and ends inside BB range => !!! abnormal case not supported !!!
471	    elif (bin_base <= bb_dict["bb_base"]) and (bin_end <= bb_dict["bb_end"]):
472	        print("ERROR current binary is overlapping with previously aggregated binaries !!")
473	        exit(2)
474	    #  Elf starts inside BB range and ends after BB end    => !!! abnormal case not supported !!!
475	    elif (bin_base >= bb_dict["bb_base"]) and (bin_end >= bb_dict["bb_end"]):
476	        print("ERROR current binary is overlapping with previously aggregated binaries !!")
477	        exit(2)
478	    #  Elf starts before BB start and ends after BB end  => First check there is no useful data in ELF file range that will be erased by BB, then copy BB contents into elf file binary that becomes new BB
479	    elif (bin_base < bb_dict["bb_base"]) and (bin_end > bb_dict["bb_end"]):
480	        # Check overlap data
481	        overlapzone = bin[bb_dict["bb_base"]-bin_base+1:(bb_dict["bb_base"]-bin_base)+len(bb_dict["big_binary"])-1]
482	        for b in overlapzone:
483	          if b != args.value:
484	            print("ERROR: overlapped zone is not empty")
485	            exit(3)
486	        # Create new BB
487	        bb_dict["big_binary"] = bin[:bb_dict["bb_base"]-bin_base] + bb_dict["big_binary"] + bin[(bb_dict["bb_base"]-bin_base)+len(bb_dict["big_binary"]):]
488	        bb_dict["bb_base"] = bin_base
489	        bb_dict["bb_end"] = bin_end
490	    else:
491	        print("ERROR segment configuration is generating not managed case !!")
492	        exit(99)
493
494	def do_mergev2(args):
495	    bb_dict=dict()
496	    # loop on elf files
497	    if args.files:
498	      elffiles = args.files.split(';')
499	      for ef in elffiles:
500	        with open(ef, 'rb') as f:
501	            # get the data
502	            my_elffile = ELFFile(f)
503	            elf_binary, elf_base = get_binary(my_elffile, args.value,args.elf)
504	            elf_end = elf_base + len(elf_binary)
505	            print("Adding ELF file: "+ef+" from "+hex(elf_base)+" to "+hex(elf_end))
506	            # check if first file or injection needed
507	            if 'big_binary' in bb_dict:
508	              sub_mergev2(args, bb_dict, elf_binary, elf_base, elf_end)
509	            else:
510	              # first copy
511	              bb_dict['big_binary'] = elf_binary
512	              bb_dict['bb_base'] = elf_base
513	              bb_dict['bb_end'] = elf_end
514	    # loop on binary files
515	    binfiles = args.binaries.split(';')
516	    for bf in binfiles:
517	      #print(bf)
518	      _bf, _add = bf.split('@')
519	      with open(_bf, 'rb') as f:
520	          # get the data
521	          bin_binary = f.read()
522	          bin_base = auto_int(_add) & 0xffffffff
523	          bin_end = bin_base + len(bin_binary)
524	          print("Adding BIN file: "+_bf+" from "+hex(bin_base)+" to "+hex(bin_end))
525	          # check if first file or injection needed
526	          if 'big_binary' in bb_dict:
527	            sub_mergev2(args, bb_dict, bin_binary, bin_base, bin_end)
528	          else:
529	            # first copy
530	            bb_dict['big_binary'] = bin_binary
531	            bb_dict['bb_base'] = bin_base
532	            bb_dict['bb_end'] = bin_end
533
534	    print("Writing to "+str(args.outfile)+" "+str(len(bb_dict['big_binary'])))
535	    with open(args.outfile, 'wb') as f:
536	        f.write(bb_dict['big_binary'])
537	    with open(args.outfile+".baseadd", 'w') as f:
538	        f.write(hex(bb_dict['bb_base']))
539
540
541	def do_append(args):
542	    #get the different element to compute the binary
543	    with open(args.userapp, 'rb') as f:
544	        my_elffile = ELFFile(f)
545	        appli_binary, appli_base = get_binary(my_elffile, args.value,args.elf)
546	    with open(args.binary, 'rb') as f:
547	        input_binary = f.read()
548	    with open(args.install, 'rb') as f:
549	        header_binary = f.read()
550
551	    #Add header + user application to the existing binary and padd in between
552	    input_binary_base = args.address
553	    address_just_after_i­nput_binary = len(input_binary) + input_binary_base
554	    if args.header:
555	      beginaddress_header = args.header
556	    else:
557	      beginaddress_header = appli_base - len(header_binary)
558	    print("Merging")
559	    print("Binary base = "+hex(input_binary_base))
560	    print("Writing header = "+hex(beginaddress_header))
561	    print("APPLI base = "+hex(appli_base))
562	    if beginaddress_header < address_just_after_i­nput_binary:
563	        # header not contiguous : input binary + header + input binary (remaining part) + pad + header(fake) + UserApp
564	         padd_before_appli = appli_base - len(header_binary) - address_just_after_i­nput_binary
565	         offset_header = beginaddress_header - input_binary_base
566	         output_binary = input_binary[:offset_header] + header_binary + input_binary[offset_header + len(header_binary):] + padd_before_appli * pack("B",args.value) + header_binary + appli_binary
567	    else:
568	        # header not contiguous : input binary + pad + header + UserApp
569	         padd_before_appli = appli_base - len(header_binary) - address_just_after_i­nput_binary
570	         output_binary = input_binary + + padd_before_appli * pack("B",args.value) + header_binary + appli_binary
571	    print("Writing to "+str(args.outfile)+" "+str(len(output_binary)))
572	    with open(args.outfile, 'wb') as f:
573	        f.write(output_binary)
574
575	def do_diff(args):
576	    # Check args
577	    if args.align == 0:
578	        msg = "Wrong alignment value, must be greater than 0"
579	        raise argparse.ArgumentTypeError(msg)
580	    if args.begin % args.align > 0:
581	        msg = "Wrong begin value ({}), must be a modulo of the specified alignment ({})".format(args.begin, args.align)
582	        raise argparse.ArgumentTypeError(msg)
583	    if args.end > 0 and (args.end + 1) % args.align > 0:
584	        msg = "Wrong end value ({}), must be last offset of a block defined by alignment ({})".format(args.end, args.align)
585	        raise argparse.ArgumentTypeError(msg)
586
587	    # Append the file 1 to get a size modulo alignment
588	    arr1 = numpy.fromfile(args.file1, numpy.int8)
589	    size = args.align - (arr1.size % args.align)
590	    for ite in range(0, size):
591	        arr1 = numpy.append(arr1, [0])
592	    arr1 = arr1.reshape(-1, args.align)
593
594	    # Append the file 2 to get a size modulo alignment
595	    arr2 = numpy.fromfile(args.file2, numpy.int8)
596	    arr2size = arr2.size
597	    size = args.align - (arr2.size % args.align)
598	    for ite in range(0, size):
599	        arr2 = numpy.append(arr2, [0])
600	    arr2 = arr2.reshape(-1, args.align)
601
602	    if args.end > 0 and args.end >= arr2.size:
603	        msg = "Wrong end set ({}), must be a within secondary binary file range ({})".format(args.end, arr2.size)
604	        raise argparse.ArgumentTypeError(msg)
605
606	    if arr1.size == arr2.size:
607	        # Both files to compare have same size
608	        if args.end > 0 and args.end < arr1.size:
609	            # args.end is specified within file size
610	            end_cmp = args.end
611	        else:
612	            # args.end is not specified or is out of file size
613	            end_cmp = arr1.size - 1
614	        # No additional data, copy stops at end of comparison
615	        end_cpy = -1
616	    elif arr1.size > arr2.size:
617	        # Primary file bigger than secondary
618	        if args.end > 0 and args.end < arr2.size:
619	            # args.end is specified within secondary file size
620	            end_cmp = args.end
621	        else:
622	            # args.end is not specified or is out of secondary file size
623	            end_cmp = arr2.size - 1
624	        # No additional data, copy stops at end of comparison
625	        end_cpy = -1
626	    else:  # arr2.size > arr1.size
627	        if args.end > 0 and args.end < arr1.size:
628	            # args.end is specified within primary file size
629	            end_cmp = args.end
630	            # No additional data, copy stops at end of comparison
631	            end_cpy = -1
632	        else:
633	            # args.end is not specified or is out of primary file size
634	            end_cmp = arr1.size - 1
635	            if args.end > 0 and args.end < arr2.size:
636	                # Additional data to copy till specified args.end
637	                end_cpy = args.end
638	            else:
639	                # Additional data to copy till end of secondary file
640	                end_cpy = arr2.size - 1
641
642	    first_diff = -1
643	    last_diff = -1
644	    for ite in range(int(args.begin/args.align), int(end_cmp/args.align)+1):
645	        if not numpy.array_equal(arr1[ite], arr2[ite]):
646	            if first_diff == -1:
647	                first_diff = ite
648	                if end_cpy == -1:
649	                    last_diff = ite
650	                else:
651	                    # Additional data to copy, set last_diff to end of copy and exit loop
652	                    last_diff = int(end_cpy/args.align)
653	                    break
654	            else:
655	                last_diff = ite
656
657	    if first_diff == -1:
658	        if end_cpy == -1:
659	            sys.stderr.write("Input files are identical within comparison range ({},{})".format(args.begin, end_cmp))
660	            last_diff = -1
661	            first_diff = 0
662	        else:
663	            # No comparison differences detected, but additional data needs to be copied
664	            # Set first_diff & last_diff to first & last additional data to copy
665	            first_diff = int(arr1.size/args.align)
666	            last_diff = int(end_cpy/args.align)
667
668	    arrout = numpy.zeros((last_diff - first_diff + 1) * args.align, numpy.int8).reshape(-1, args.align)
669	    for ite in range(0, last_diff - first_diff + 1):
670	        arrout[ite] = arr2[first_diff + ite]
671
672	    # If last block concerned, remove the additional bytes appended at the beginning of the function
673	    arrout = arrout.reshape(1, -1)
674	    if ((last_diff + 1)* args.align) > arr2size :
675	        #last block is partial
676	        size = (last_diff - first_diff) * args.align + arr2size % args.align
677	    else:
678	        # all blocks are complete
679	        size = (last_diff - first_diff + 1) * args.align
680	    # keep only the useful part
681	    arrout = arrout[0,:size]
682	    # Store to outfile binary file
683	    arrout.tofile(args.outfile)
684	    # Store offset in file if specified
685	    with open(args.poffset, 'w') as f:
686	        f.write(str(first_diff*args.align))
687
688	def do_inject(args):
689	    if args.key:
690	      key = keys.load(args.key)
691	      np_key = numpy.frombuffer(key.get_key(args.type), numpy.uint8)
692	    elif args.cert:
693	      np_key = numpy.fromfile(args.cert, numpy.uint8)
694	    else:
695	      raise argparse.ArgumentTypeError("Unknown error while parsing arguments")
696	    # DEBUG_______________­_______________
697	    #print(key.get_key("public"))
698	    #l = list()
699	    #for ite in range(0, np_key.size):
700	    #  l.append(np_key[ite])
701	    #print(l)
702	    # DEBUG_______________­_______________
703	    with open(args.file, 'r') as f:
704	      with open(args.outfile, 'w') as o:
705	        for line in f.readlines():
706	          # DEBUG_______________­_______________
707	          #print(line)
708	          # DEBUG_______________­_______________
709	          if args.pattern in line:
710	            # DEBUG_______________­_______________
711	            #print("Found:{}".format(line))
712	            # DEBUG_______________­_______________
713	            if "CKA_VALUE" in line:
714	              value = "{},".format(np_key.size)
715	              for ite in range(0, int(np_key.size/4+0.75)):  # int() truncate to integer part. +0,75 so that is reman of the division exist, it will be truncated to next int value
716	                  if ite*4+3 < np_key.size:
717	                    value += " 0x{:02x}{:02x}{:02x}{:02x}U,".format(np_key[ite*4],np_key[ite*4+1],np_key[ite*4+2],np_key[ite*4+3])
718	                  elif ite*4+2 < np_key.size:
719	                    value += " 0x{:02x}{:02x}{:02x}U,".format(np_key[ite*4],np_key[ite*4+1],np_key[ite*4+2])
720	                  elif ite*4+1 < np_key.size:
721	                    value += " 0x{:02x}{:02x}U,".format(np_key[ite*4],np_key[ite*4+1])
722	                  else:
723	                    value += " 0x{:02x}U,".format(np_key[ite*4])
724	              # DEBUG_______________­_______________
725	              #print("Value:{}".format(value))
726	              # DEBUG_______________­_______________
727	              line = line.replace(args.pattern, value)
728	            elif "CKA_EC_POINT"  in line:
729	              np_key2 = numpy.zeros(np_key.size+3, numpy.uint8)
730	              for ite in range(0, np_key.size):
731	                np_key2[ite+3] = np_key[ite]
732	              np_key2[0] = 0x04;              # Octet string
733	              np_key2[1] = np_key.size + 1;   # Octet length
734	              np_key2[2] = 0x04;              # X9.62 uncompressed format
735	              value = "{},".format(np_key2.size)
736	              for ite in range(0, int(np_key2.size/4+0.75)):
737	                  if ite*4+3 < np_key2.size:
738	                    value += " 0x{:02x}{:02x}{:02x}{:02x}U,".format(np_key2[ite*4],np_key2[ite*4+1],np_key2[ite*4+2],np_key2[ite*4+3])
739	                  elif ite*4+2 < np_key2.size:
740	                    value += " 0x{:02x}{:02x}{:02x}U,".format(np_key2[ite*4],np_key2[ite*4+1],np_key2[ite*4+2])
741	                  elif ite*4+1 < np_key2.size:
742	                    value += " 0x{:02x}{:02x}U,".format(np_key2[ite*4],np_key2[ite*4+1])
743	                  else:
744	                    value += " 0x{:02x}U,".format(np_key2[ite*4])
745	              # DEBUG_______________­_______________
746	              #print("Value:{}".format(value))
747	              # DEBUG_______________­_______________
748	              line = line.replace(args.pattern, value)
749	            # DEBUG_______________­_______________
750	            #print("Altered line:{}".format(line))
751	            # DEBUG_______________­_______________
752	          o.write(line)
753	        o.close()
754
755	#    end = False
756	#    if args.end:
757	#        end = True
758	#    if args.assembly=="ARM" or args.assembly=="IAR" or args.assembly=="GNU":
759	#        if args.version=="V6M" or args.version=="V7M":
760	#          out = key.trans(args.section, args.function, end, args.assembly, args.version)
761	#          print (str(out))
762	#        else:
763	#          print ("-v option : Cortex M architecture not supported")
764	#          exit(1)
765	#    else:
766	#        print ("-a option : assembly option not supported")
767	#        exit(1)
768
769	subcmds = {
770	        'keygen': do_keygen,
771	        'trans':do_trans,
772	        'getpub': do_getpub,
773	        #sign a binary with a givent key
774	        # nonce is required for aes gcm  , if nonce not existing the file is
775	        # created
776	        # -k keyfilename -n nonce file
777	        'sign': do_sign,
778	        #hash a file with sha256 and provide result in in a file
779	        'sha256': do_sha,
780	        #return define value from crpto configuration from .h file
781	        #define to search default SECBOOT_CRYPTO_SCHEM­E, -d
782	        'conf': do_conf,
783	        #define to search , -d
784	        'extract': do_extract,
785	        #encrypt binary file with provided key
786	        # -k -n
787	        'enc': do_encrypt,
788	        # give what to put  in header and provide the key to compute hmac
789	        # magic (4 bytes) required, -m
790	        # protocol version(2 bytes) required , -p
791	        # nonce optional , -n
792	        # fwversion (required) 2 bytes, -ver
793	        # fw file (to get the size)
794	        # fw tag  (file)
795	        # reserved size
796	        # key
797	        # offset default 512
798	        'header':do_header,
799	        # give what to pack a single file header
800	        # magic (4 bytes) required, -m
801	        # protocol version(2 bytes) required , -p
802	        # nonce optional , -n
803	        # fwversion (required) 2 bytes, -ver
804	        # fw file (to get the size)
805	        # fw tag  (file)
806	        # reserved size
807	        # key
808	        # offset default 512
809	        #
810	        'pack':do_pack,
811	        #
812	        'diff':do_diff,
813	        #merge appli.elf , header binary and sbsfu elf in a big binary
814	        #input file appli.elf
815	        #-h header file
816	        #-s sbsfu.elf
817	        #output file binary to merge
818	        #-v byte pattern to fill between the different segment default 0xff
819	        #-p padding length to add to appli binary
820	        'merge':do_merge,
821	        'mergev2':do_mergev2,
822	        'diff':do_diff,
823	        #append appli.elf and header binary to an existing big binary
824	        'append':do_append,
825	        #inject key into file by replacing pattern
826	        'inject':do_inject,
827	        }
828
829	def auto_int(x):
830	    if x.startswith("0x"):
831	        return int(x,16)
832	    else:
833	        return int(x)
834
835	def args():
836	    parser = argparse.ArgumentParser()
837	    subs = parser.add_subparsers(help='subcommand help', dest='subcmd')
838	    keygenp = subs.add_parser('keygen', help='Generate pub/private keypair')
839	    keygenp.add_argument('-k', '--key', metavar='filename', required=True)
840	    keygenp.add_argument('-t', '--type', metavar='type',
841	            choices=['aes-gcm', 'ecdsa-p256','aes-cbc','aes-ctr'],
842	            required=True)
843	    trans =  subs.add_parser('trans', help='translate key to execute only code')
844	    trans.add_argument('-k', '--key', metavar='filename', required=True)
845	    trans.add_argument('-f', '--function', type=str, required = True)
846	    trans.add_argument('-s', '--section', type=str, default="")
847	    trans.add_argument('-a', '--assembly',help='fix assembly type IAR or ARM or GNU', type=str,required = False, default="IAR")
848	    trans.add_argument('-v', '--version',help='fix CORTEX M architecture', type=str,required = False, default="V7M")
849	    trans.add_argument('-e', '--end')
850
851	    getpub = subs.add_parser('getpub', help='Get public key from keypair')
852	    getpub.add_argument('-k', '--key', metavar='filename', required=True)
853
854	    sign = subs.add_parser('sign', help='Sign an image with a private key')
855	    sign.add_argument('-k', '--key', metavar='filename', required = True)
856	    sign.add_argument('-n', '--nonce', metavar='filename', required = False)
857	    sign.add_argument("infile")
858	    sign.add_argument("outfile")
859	    sha = subs.add_parser('sha256', help='hash a file with sha256')
860	    sha.add_argument("infile")
861	    sha.add_argument("outfile")
862	    sha.add_argument('-p', '--padding',type=int, required = False, default=0, help='pad to be a multiple of the given size if needed')
863	    config = subs.add_parser('conf', help='get crypto config from .h file')
864	    config.add_argument('-d', '--define', type=str, default='SECBOOT_CRYPTO_SCHEM­E')
865	    config.add_argument("infile")
866	    extract = subs.add_parser('extract', help='get value definition from text file')
867	    extract.add_argument('-d', '--define', type=str, help='defintion searched in file')
868	    extract.add_argument("infile")
869	    enc = subs.add_parser('enc', help='encrypt an image with a private key')
870	    enc.add_argument('-k', '--key', metavar='filename', required = True)
871	    enc.add_argument('-n', '--nonce', metavar='filename')
872	    enc.add_argument('-i', '--iv', metavar='filename')
873	    enc.add_argument('-a', '--address', type=auto_int, help='part of IV for AES CTR. address = Slot0_FW_Start_Addre­ss[31:4]')
874	    enc.add_argument('--poffset', help ='file that contains offset at which the partial firmware should be applied', type=str, metavar='filename')
875	    enc.add_argument("infile")
876	    enc.add_argument("outfile")
877
878	    head = subs.add_parser('header', help='build  installed header file and compute mac according to provided key')
879	    head.add_argument('-k', '--key', metavar='filename', required = True)
880	    head.add_argument('-n', '--nonce', metavar='filename')
881	    head.add_argument('-i', '--iv', metavar='filename')
882	    head.add_argument('-f', '--firmware', metavar='filename', required = True)
883	    head.add_argument('-t', '--tag', metavar='filename', required = True)
884	    head.add_argument('-v', '--version',type=int, required = True)
885	    head.add_argument('-m', '--magic',type=str, default="SFUM")
886	    head.add_argument('-p', '--protocol',type=int,  default = 0x1)
887	    head.add_argument('-r', '--reserved',type=int, default=8)
888	    head.add_argument('-o', '--offset', type=int, default = 512, required = False)
889	    head.add_argument('--cert_fw_leaf', metavar='filename', required = False)
890	    head.add_argument('--cert_fw_inter', metavar='filename', required = False)
891	    head.add_argument('--pfw', help ='partial firmware', metavar='filename', required = ('--poffset' in sys.argv) or ('--ptag' in sys.argv))
892	    head.add_argument('--poffset', help ='file that contains offset at which the partial firmware should be applied', type=str, metavar='filename', required = ('--pfw' in sys.argv) or ('--ptag' in sys.argv))
893	    head.add_argument('--ptag', metavar='filename', required = ('--pfw' in sys.argv) or ('--poffset' in sys.argv))
894	    head.add_argument("outfile")
895	    pack = subs.add_parser('pack', help='build header file and compute mac according to key provided')
896	    pack.add_argument('-k', '--key', metavar='filename', required = True)
897	    pack.add_argument('-n', '--nonce', metavar='filename')
898	    pack.add_argument('-i', '--iv', metavar='filename')
899	    pack.add_argument('-f', '--firmware', metavar='filename', required = True)
900	    pack.add_argument('-t', '--tag', metavar='filename', required = True)
901	    pack.add_argument('-v', '--version',type=int, required = True)
902	    pack.add_argument('-m', '--magic',type=str, default="SFUM")
903	    pack.add_argument('-p', '--protocol',type=int, default = 0x1)
904	    pack.add_argument('-r', '--reserved',type=int, default=8)
905	    pack.add_argument('-o', '--offset', help='offset between start of header and binary', type=int, default=512)
906	    pack.add_argument('-e', '--elf', help='elf type set to 1 for GNU, 0 for other by default', type=int, default=1)
907	    pack.add_argument('--cert_fw_leaf', metavar='filename', required = False)
908	    pack.add_argument('--cert_fw_inter', metavar='filename', required = False)
909	    pack.add_argument('--pfw', help ='partial firmware', metavar='filename', required = ('--poffset' in sys.argv) or ('--ptag' in sys.argv))
910	    pack.add_argument('--poffset', help ='file that contains offset at which the partial firmware should be applied', type=str, metavar='filename', required = ('--pfw' in sys.argv) or ('--ptag' in sys.argv))
911	    pack.add_argument('--ptag', metavar='filename', required = ('--pfw' in sys.argv) or ('--poffset' in sys.argv))
912	    pack.add_argument("outfile")
913
914	    diff = subs.add_parser('diff', help='compute differences between 2 binary files ')
915	    diff.add_argument('-1', '--file1', type=str, metavar='filename', required=True, help="first binary file to compare")
916	    diff.add_argument('-2', '--file2', type=str, metavar='filename', required=True, help="second binary file to compare")
917	    diff.add_argument('-p', '--poffset', type=str, metavar='filename', required=True, help="file that will contain offset at which the difference binary files should be applied")
918	    diff.add_argument('-b', '--begin', type=auto_int, metavar='filename', default='0x0', required=False, help="offset from which beginning comparison - in bytes (default: 0)")
919	    diff.add_argument('-e', '--end',   type=auto_int, metavar='filename', default='0x0', required=False, help="offset at which ending comparison - in bytes. use 0 to specify end of given binary files (default: 0)")
920	    diff.add_argument('-a', '--align', type=int, metavar='align', default=2, required=False, help="difference binary file alignment in bytes (default: 2)")
921	    diff.add_argument("outfile")
922
923	    mrg = subs.add_parser('merge', help='merge elf appli , install header and sbsfu.elf in a contiguous binary')
924	    mrg.add_argument('-i', '--install', metavar='filename',  help="filename of installed binary header", required = True)
925	    mrg.add_argument('-s', '--sbsfu', metavar='filename', help="filename of sbsfu elf", required = True)
926	    mrg.add_argument('-l', '--loader', metavar='filename', help="filename of loader elf", required = False)
927	    mrg.add_argument('-v', '--value', help= "byte padding pattern", required = False, type=int, default=0xff)
928	    mrg.add_argument('-p', '--padding', help='pad to add to appli binary, a multiple of the given size if needed',type=int, required = False, default=0)
929	    mrg.add_argument('-e', '--elf', help='elf type set to 1 for GNU, 0 for other by default', type=int, default=1)
930	    mrg.add_argument('-x', '--header', type=auto_int, help='Header address, when header not contiguous with FW',required = False)
931	    mrg.add_argument('-u', '--userapp', metavar='filename', help="filename of appli elf file", required = False)
932	    mrg.add_argument("outfile", help = "filename of contiguous binary")
933
934	    mrgv2 = subs.add_parser('mergev2', help='merge elf files and binaries in a contiguous binary')
935	    mrgv2.add_argument('-b', '--binaries', type=str,  help="binaries to merge files list (ex:'f1.bin@0x08004500;f1.bin@0x08006000'", required = True)
936	    mrgv2.add_argument('-f', '--files', type=str,  help="elf files to merge list (ex:'f1.elf;f2.elf'", required = False)
937	    mrgv2.add_argument('-v', '--value', help= "byte padding pattern", required = False, type=int, default=0xff)
938	    mrgv2.add_argument('-e', '--elf', help='elf type set to 1 for GNU, 0 for other by default', type=int, default=1)
939	    mrgv2.add_argument("outfile", help = "filename of contiguous binary")
940
941	    app = subs.add_parser('append', help='append elf appli and install header to an existing binary')
942	    app.add_argument('-i', '--install', metavar='filename',  help="filename of installed binary header", required = True)
943	    app.add_argument('-b', '--binary', metavar='filename', help="filename of existing binary", required = True)
944	    app.add_argument('-v', '--value', help= "byte padding pattern", required = False, type=int, default=0xff)
945	    app.add_argument('-e', '--elf', help='elf type set to 1 for GNU, 0 for other by default', type=int, default=1)
946	    app.add_argument('-x', '--header', type=auto_int, help='Header address',required = False)
947	    app.add_argument('-a', '--address', type=auto_int, help='Base address of input binary',required = False)
948	    app.add_argument('-u', '--userapp', metavar='filename', help="filename of user application elf file", required = False)
949	    app.add_argument("outfile", help = "filename of contiguous binary")
950
951	    inject =  subs.add_parser('inject', help='inject key to KMS embedded keys code')
952	    inject.add_argument('-k', '--key', metavar='filename', required=('--cert' not in sys.argv) and ('-c' not in sys.argv))
953	    inject.add_argument('-c', '--cert', metavar='filename', help = "Certificate .der file", required=('--key' not in sys.argv) and ('-k' not in sys.argv))
954	    inject.add_argument('-p', '--pattern', type=str, required=True)
955	    inject.add_argument('-f', '--file', metavar='filename', required=True)
956	    inject.add_argument('-t', '--type', type=str, default="public")
957	    inject.add_argument("outfile", help = "generated output file")
958
959	    args = parser.parse_args()
960	    if args.subcmd is None:
961	        print('Must specify a subcommand')
962	        sys.exit(1)
963	    subcmds[args.subcmd](args)
964
965	if __name__ == '__main__':
966	    args()
967
968
L476_SBSFU\Common\KeysAndImages_Util\readme.txt

=================================
Overview
=================================
The python scripts contained in this directory are used by pre and post processing scripts in the SE_CoreBin and UserApp projects.

1) These scripts will generate the appropriate .s files implementing the functions declared in se_key.h.
2) They are also used by the post-processing script to  generate the FW image and header files (.sfu and .sfuh) and the single binary file (header + FW image).

To use these scripts you need to make sure you have installed the appropriate python modules listed in "requirements.txt":
> pip install -r requirements.txt

Please note that you do not need to call these scripts manually as they are integrated in the IDE.
They will be called as pre and post build scripts when building the projects with your IDE.


=================================
'prepareimage.py' functionalities
=================================
The 'prepareimage.py' script is the main item of this folder.
This script can be used to perform 5 types of operations:

* generate some keys ('keygen' command):
      ** symmetric key for Firmware encryption (AES CBC or AES GCM) and authentication when AES GCM is used.
      ** asymmetric keys for authentication when ECDSA is used.

* generate the ARM assembler code to load the keys from FLASH into RAM
      This is the 'trans' command.
      It generates the .s file to build in the context of the SE_CoreBin project.

* encrypt the firmware image ('enc' command)
      This is a symmetric encryption: AES CBC or AES GCM.

* generate the tag to authenticate the firmware ('sign' command or 'sha256' command)
      ** When AES GCM is used for authentication, this is the "sign" command: generates the FW tag.
      ** When SHA256 with ECDSA is used for authentication, this is the "sha256" command: generates the sha256 digest

* generate the Firmware header (metadata) and the single binary file to be downloaded (header+ clear or encrypted firmware )
      This is the 'pack' command.

* generate partial update clear binary from old & new clear binaries
      This is the 'diff' command.

=================================
Some examples
=================================

Example for AES-CBC:
--------------------
[1] Generate the keys - OPTION
python prepareimage.py keygen -k AES_CBC.bin -t aes-cbc
=> for aes_cbc , "AES_CBC"  must be in file name else key is not created, this
is used to discriminate AES_GCM key versus AES_CBC key
python prepareimage.py  keygen  -k ECCKEY.txt -t ecdsa-p256

This step is not mandatory but if you do so, please make sure:
* to copy the content of  ECCKEY.txt in SECoreBin\Binary
* to use AES_CBC.bin instead of OEM_KEY_COMPANY1_key.bin
Then the prebuild operations (SE_CoreBin) must be performed.

[2] Encrypt the image
python prepareimage.py  enc -k AES_CBC.bin -i iv.bin UserApp.bin UserApp.sfu

[3] Generate the clear FW tag (SHA256 of the clear FW)
python prepareimage.py sha256  UserApp.bin  UserApp.sign

[4] Generate the .sfb FW metadata (header) and encrypted binary
python prepareimage.py  pack -k ECCKEY.txt -r 28 -p 1 -v 2 -i iv.bin -f UserApp.sfu -t UserApp.sign UserApp.sfb
(Please note the use of -r 28 to have a FW header length of 192 bytes. This is needed to match the FLASH constraint.)

The step 1 is optional, the steps 2,3 and 4 are handled by the post-build scripts already integrated in the IAR IDE.

Example for AES-GCM :
---------------------
[1] Generate the keys - OPTION
python prepareimage.py keygen -k OEM_KEY_COMPANY1_key.bin  -t aes-gcm

This step is not mandatory but if you do so, please make sure:
* to copy the content OEM_KEY_COMPANY1_key.bin  in SECoreBin\Binary
Then the prebuild operations (SE_CoreBin) must be performed.

[2] Encrypt the image
python prepareimage.py  enc -k OEM_KEY_COMPANY1_key.bin -n nonce.bin UserApp.bin UserApp.sfu

[3] Generate the clear FW tag with AES-GCM
python prepareimage.py sign -k OEM_KEY_COMPANY1_key.bin -n nonce.bin UserApp.bin  UserApp.sign

[4] Generate the .sfb FW metadata (header) and encrypted binary
python prepareimage.py  pack -k OEM_KEY_COMPANY1_key.bin  -r 28 -p 1 -v 2 -n nonce.bin -f UserApp.sfu -t UserApp.sign UserApp.sfb
(Please note the use of -r 28 to have a FW header length of 192 bytes. This is needed to match the FLASH constraint.)

The step 1 is optional, the steps 2,3 and 4 are handled by the post-build scripts already integrated in the IAR IDE.

Example for partial update :
----------------------------

[0] Generate partial image
python prepareimage.py  diff -1 UserApp_v1.bin -2 UserApp_v2.bin UserApp_partial.bin -a 16 --poffset UserApp_partial.offset
(-a 16: align partial binary on 16 bytes. Partial binary size will also be aligned on 16 bytes)

[1] Generate the keys - OPTION
python prepareimage.py keygen -k AES_CBC.bin -t aes-cbc
=> for aes_cbc , "AES_CBC"  must be in file name else key is not created, this
is used to discriminate AES_GCM key versus AES_CBC key
python prepareimage.py  keygen  -k ECCKEY.txt -t ecdsa-p256

This step is not mandatory but if you do so, please make sure:
* to copy the content of  ECCKEY.txt in SECoreBin\Binary
* to use AES_CBC.bin instead of OEM_KEY_COMPANY1_key.bin
Then the prebuild operations (SE_CoreBin) must be performed.

[2] Encrypt the complete image
python prepareimage.py  enc -k AES_CBC.bin -i iv.bin UserApp_v2.bin UserApp_v2.sfu

[3] Encrypt the partial image
python prepareimage.py  enc -k AES_CBC.bin -i iv.bin UserApp_partial.bin UserApp_partial.sfu

[4] Generate the clear complete FW tag (SHA256 of the clear FW)
python prepareimage.py sha256  UserApp_v2.bin  UserApp_v2.sign

[5] Generate the clear partial FW tag (SHA256 of the clear FW)
python prepareimage.py sha256  UserApp_partial.bin  UserApp_partial.sign

[6] Generate the .sfb FW metadata (header) and encrypted partial binary
python prepareimage.py  pack -k ECCKEY.txt -r 28 -p 1 -v 2 -i iv.bin -f UserApp_v2.sfu -t UserApp_v2.sign --pfw UserApp_partial.sfu --ptag UserApp_partial.sign --poffset UserApp_partial.offset UserApp_partial.sfb
(Please note the use of -r 28 to have a FW header length of 192 bytes. This is needed to match the FLASH constraint.)

=================================
Windows executable(s)
=================================
Two windows executables are provided:
(a) Firmware/Middlewares/ST/STM32_Secure_Engine/Utilities/KeysAndImages/win/prepareimage.exe
    ==> this file contains all the required element to run but is slower at execution time.

(b) Firmware/Middlewares/ST/STM32_Secure_Engine/Utilities/KeysAndImages/win/prepareimage/prepareimage.exe
    ==> this file requires additional items (provided in its sub-folder) but is faster at execution time.

By default, the scripts use (b).

=================================
Rebuilding windows executable
=================================
It is also possible to generate windows executables to avoid using the python scripts directly.

This requires some additional Python libraries and tools:
>pip install pyinstaller

Follow method (a) or (b).
Method (a) produces a single file while method (b) provides a folder (execution can be faster).

(a) Building in "one file" mode:
>pyinstaller --onefile prepareimage.py
>cp -p dist/prepareimage.exe win/

OR

(b) Building in "onefolder" mode:
>pyinstaller --clean --onedir prepareimage.py
Then copy the folder "Firmware/Middlewares/ST/STM32_Secure_Engine/Utilities/KeysAndImages/dist/prepareimage"
in "Firmware/Middlewares/ST/STM32_Secure_Engine/Utilities/KeysAndImages/win"

Then decide if you want to use:
(a) Firmware/Middlewares/ST/STM32_Secure_Engine/Utilities/KeysAndImages/win/prepareimage.exe
or
(b) Firmware/Middlewares/ST/STM32_Secure_Engine/Utilities/KeysAndImages/win/prepareimage/prepareimage.exe
and update the scripts accordingly.

L476_SBSFU\Common\KeysAndImages_Util\requirements.txt

pycryptodome
pycryptodomex
ecdsa
pyelftools
numpy

L476_SBSFU\Common\KeysAndImages_Util\translate_key.py
1	# Copyright(c) 2018 STMicroelectronics International N.V.
2	#
3	# Licensed under the Apache License, Version 2.0 (the "License");
4	# you may not use this file except in compliance with the License.
5	# You may obtain a copy of the License at
6	#
7	#     http://www.apache.org/licenses/LICENSE-2.0
8	#
9	# Unless required by applicable law or agreed to in writing, software
10	# distributed under the License is distributed on an "AS IS" BASIS,
11	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12	# See the License for the specific language governing permissions and
13	# limitations under the License.
14	import os
15	from array import array
16	#generating execute only code function for ARMV7M
17	#based on :
18	# 0xABCD
19	#    MOVW Rn, #0xBA
20	#    MOVT Rn  #0xCD
21	# AREA KEY, CODE
22	# EXPORT ReadKey
23	# 16 bytes AEG_GCM key
24	#PUSH {R4, R7}
25	# 32 bytes (pub_x, pub_y)
26	#PUSH {R4, R11}
27	def build_mov(reg, val, version):
28	    if version == "V7M":
29	        #build the 2 16bits to write
30	        out ="\tMOVW R"+str(reg)+", #"+hex(val[1]*256+val[0])+"\n"
31	        out +="\tMOVT R"+str(reg)+", #"+hex(val[3]*256+val[2])+"\n"
32	    elif version == "V6M":
33	        #build the 8 8bits to write
34	        out ="\tMOVS R"+str(reg)+", #"+hex(val[3])+"\n"
35	        out +="\tLSLS R"+str(reg)+", R"+str(reg)+", #24\n"
36	        out +="\tMOVS R5, #"+hex(val[2])+"\n"
37	        out +="\tLSLS R5, R5, #16\n"
38	        out +="\tADD R"+str(reg)+", R"+str(reg)+", R5\n"
39	        out +="\tMOVS R5, #"+hex(val[1])+"\n"
40	        out +="\tLSLS R5, R5, #8\n"
41	        out +="\tADD R"+str(reg)+", R"+str(reg)+", R5\n"
42	        out +="\tMOVS R5, #"+hex(val[0])+"\n"
43	        out +="\tADD R"+str(reg)+", R"+str(reg)+", R5\n"
44	    else:
45	        exit(1)
46	    return out
47
48	def translate(key, end=False, assembly="IAR", version="V7M"):
49	    if version == "V7M":
50	        STMR0 = "\tSTM R0"
51	        ADDR0 = "\tADD R0"
52	    elif version == "V6M":
53	        STMR0 = "\tSTM R0!"
54	    else:
55	        exit(1)
56
57	    key=bytearray(key)
58	    if len(key) <= 16:
59	        endreg = int((len(key)+3)/4)
60	        loop = 1
61	    elif len(key) == 32:
62	        endreg = int(4)
63	        loop = 2
64	    elif len(key) == 64:
65	        endreg = int(4)
66	        loop = 4
67	    else:
68	        return ""
69	    output = "\tPUSH {R1-R5}\n"
70	    for j in range(0,loop):
71	        if j!=0:
72	            output+= STMR0 +", {R1-R"+str(endreg)+"}\n"
73	            if version == "V7M":
74	                output+= ADDR0 +", R0,#16\n"
75	        for i in range(0,endreg):
76	            output+=build_mov(i+1, key[16*j+i*4:16*j+i*4+4], version)
77	    output += STMR0 + ", {R1-R"+str(endreg)+"}\n"
78	    output += "\tPOP {R1-R5}\n"
79	    output += "\tBX LR\n"
80	    if end:
81	        if assembly == "GNU":
82	            output +="\t.end"
83	        else:
84	            output +="\tEND"
85	    return output
86
87	def function(section, name, assembly="IAR" ):
88	    if assembly == "IAR":
89	      section_name="section "
90	      separator=":CODE\n"
91	    elif assembly == "ARM":
92	      section_name="AREA |"
93	      separator="|, CODE\n"
94	    elif assembly == "GNU":
95	      section_name=".section "
96	      separator=""","a",%progbits\n .syntax unified \n .thumb \n
97	      """
98	    else:
99	      exit(1)
100	    if section !="":
101	        out = "\t"+str(section_name)+str(section)+str(separator)
102	    else:
103	        out=""
104	    if assembly == "GNU":
105	        out += "\t.global "+str(name)+"\n"
106	        out += str(name)+":\n"
107	    else:
108	        out += "\tEXPORT "+str(name)+"\n"
109	        out += str(name)+"\n"
110	    return out
111	if __name__ == '__main__':
112	    assembly = "GNU"
113	    outcode = function(".SE_Key_Data", "SE_ReadKey")
114	    #key = os.urandom(32)
115	    key="OEM_KEY_COMPANY1".encode()
116	    outcode +=translate(key, version="V6M")
117	    key = bytearray([0xce, 0x40, 0x14, 0xc6, 0x88, 0x11, 0xf9, 0xa2, 0x1a, 0x1f, 0xdb, 0x2c, 0x0e,
118	    0x61, 0x13, 0xe0, 0x6d, 0xb7, 0xca, 0x93, 0xb7, 0x40, 0x4e, 0x78, 0xdc, 0x7c,
119	    0xcd, 0x5c, 0xa8, 0x9a, 0x4c, 0xa9])
120	    outcode += function("", "SE_ReadKey_PubY")
121	    outcode += translate(key, version="V6M")
122	    outcode += function("", "SE_ReadKey_PubX")
123	    key = bytearray([ 0x1c, 0xcb, 0xe9, 0x1c, 0x07, 0x5f, 0xc7, 0xf4, 0xf0, 0x33, 0xbf, 0xa2, 0x48,
124	    0xdb, 0x8f, 0xcc, 0xd3, 0x56, 0x5d, 0xe9, 0x4b, 0xbf, 0xb1, 0x2f, 0x3c, 0x59,
125	    0xff, 0x46, 0xc2, 0x71, 0xbf, 0x83])
126
127	    outcode +=translate(key,version="V6M")
128	    if assembly == "GNU":
129	      outcode +="\t.end"
130	    else:
131	      outcode +="\tEND"
132	    print(outcode)
133	#bytearray([0x13, 0x00, 0x00, 0x00, 0x08, 0x00])
134	#key = bytearray([0xaa, 0xbb, 0xcc, 0xdd])
135	    print(str(key))
136
137
138
139
L476_SBSFU\Common\Linker\mapping_export.h
1	/**
2	  ******************************************************************************
3	  * @file    mapping_export.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains the definitions exported from mapping linker files.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef MAPPING_EXPORT_H
21	#define MAPPING_EXPORT_H
22
23	#ifdef __cplusplus
24	extern "C" {
25	#endif
26
27	/** @addtogroup SFU Secure Boot / Secure Firmware Update
28	  * @{
29	  */
30
31	/** @addtogroup SFU_CORE SBSFU Application
32	  * @{
33	  */
34
35	/** @addtogroup SFU_APP SFU Application Configuration
36	  * @{
37	  */
38
39	/** @defgroup SFU_APP_Exported_Typ­es Exported Types
40	  * @{
41	  */
42	/** @defgroup SFU_CONFIG_SBSFU_MEM­ORY_MAPPING SBSFU Memory Mapping
43	  * @{
44	  */
45	#if defined (__ICCARM__) || defined(__GNUC__)
46	extern uint32_t __ICFEDIT_intvec_sta­rt__;
47	#define INTVECT_START ((uint32_t)& __ICFEDIT_intvec_sta­rt__)
48	extern uint32_t __ICFEDIT_SE_Startup­_region_ROM_start__;
49	#define SE_STARTUP_REGION_RO­M_START ((uint32_t)& __ICFEDIT_SE_Startup­_region_ROM_start__)
50	extern uint32_t __ICFEDIT_SE_Code_re­gion_ROM_start__;
51	#define SE_CODE_REGION_ROM_S­TART ((uint32_t)& __ICFEDIT_SE_Code_re­gion_ROM_start__)
52	extern uint32_t __ICFEDIT_SE_Code_re­gion_ROM_end__;
53	#define SE_CODE_REGION_ROM_E­ND ((uint32_t)& __ICFEDIT_SE_Code_re­gion_ROM_end__)
54	extern uint32_t __ICFEDIT_SE_IF_regi­on_ROM_start__;
55	#define SE_IF_REGION_ROM_STA­RT ((uint32_t)& __ICFEDIT_SE_IF_regi­on_ROM_start__)
56	extern uint32_t __ICFEDIT_SE_IF_regi­on_ROM_end__;
57	#define SE_IF_REGION_ROM_END­ ((uint32_t)& __ICFEDIT_SE_IF_regi­on_ROM_end__)
58	extern uint32_t __ICFEDIT_SE_Key_reg­ion_ROM_start__;
59	#define SE_KEY_REGION_ROM_ST­ART ((uint32_t)& __ICFEDIT_SE_Key_reg­ion_ROM_start__)
60	extern uint32_t __ICFEDIT_SE_Key_reg­ion_ROM_end__;
61	#define SE_KEY_REGION_ROM_EN­D ((uint32_t)& __ICFEDIT_SE_Key_reg­ion_ROM_end__)
62	extern uint32_t __ICFEDIT_SE_CallGat­e_region_ROM_start__­;
63	#define SE_CALLGATE_REGION_R­OM_START ((uint32_t)& __ICFEDIT_SE_CallGat­e_region_ROM_start__­)
64	extern uint32_t __ICFEDIT_SB_region_­ROM_start__;
65	#define SB_REGION_ROM_START ((uint32_t)& __ICFEDIT_SB_region_­ROM_start__)
66	extern uint32_t __ICFEDIT_SB_region_­ROM_end__;
67	#define SB_REGION_ROM_END ((uint32_t)& __ICFEDIT_SB_region_­ROM_end__)
68	extern uint32_t __ICFEDIT_SE_region_­RAM_start__;
69	#define SE_REGION_RAM_START ((uint32_t)& __ICFEDIT_SE_region_­RAM_start__)
70	extern uint32_t __ICFEDIT_SE_region_­RAM_end__ ;
71	#define SE_REGION_RAM_END ((uint32_t)& __ICFEDIT_SE_region_­RAM_end__)
72	extern uint32_t __ICFEDIT_SB_region_­RAM_start__ ;
73	#define SB_REGION_RAM_START ((uint32_t)& __ICFEDIT_SB_region_­RAM_start__)
74	extern uint32_t __ICFEDIT_SB_region_­RAM_end__ ;
75	#define SB_REGION_RAM_END ((uint32_t)& __ICFEDIT_SB_region_­RAM_end__)
76	extern uint32_t __ICFEDIT_SE_region_­RAM_stack_top__;
77	#define SE_REGION_RAM_STACK_­TOP ((uint32_t)& __ICFEDIT_SE_region_­RAM_stack_top__)
78	#elif defined(__CC_ARM)
79	extern uint32_t Image$$vector_start$$Base;
80	#define  INTVECT_START ((uint32_t)& Image$$vector_start$$Base)
81	#endif
82
83
84	/**
85	  * @}
86	  */
87
88	/** @defgroup SFU_CONFIG_FW_MEMORY­_MAPPING Firmware Slots Memory Mapping
89	  * @{
90	  */
91	#if defined (__ICCARM__) || defined(__GNUC__)
92	extern uint32_t __ICFEDIT_SLOT_Activ­e_1_header__;
93	#define SLOT_ACTIVE_1_HEADER­ ((uint32_t)& __ICFEDIT_SLOT_Activ­e_1_header__)
94	extern uint32_t __ICFEDIT_SLOT_Activ­e_1_start__;
95	#define SLOT_ACTIVE_1_START ((uint32_t)& __ICFEDIT_SLOT_Activ­e_1_start__)
96	extern uint32_t __ICFEDIT_SLOT_Activ­e_1_end__;
97	#define SLOT_ACTIVE_1_END ((uint32_t)& __ICFEDIT_SLOT_Activ­e_1_end__)
98	extern uint32_t __ICFEDIT_SLOT_Activ­e_2_header__;
99	#define SLOT_ACTIVE_2_HEADER­ ((uint32_t)& __ICFEDIT_SLOT_Activ­e_2_header__)
100	extern uint32_t __ICFEDIT_SLOT_Activ­e_2_start__;
101	#define SLOT_ACTIVE_2_START ((uint32_t)& __ICFEDIT_SLOT_Activ­e_2_start__)
102	extern uint32_t __ICFEDIT_SLOT_Activ­e_2_end__;
103	#define SLOT_ACTIVE_2_END ((uint32_t)& __ICFEDIT_SLOT_Activ­e_2_end__)
104	extern uint32_t __ICFEDIT_SLOT_Activ­e_3_header__;
105	#define SLOT_ACTIVE_3_HEADER­ ((uint32_t)& __ICFEDIT_SLOT_Activ­e_3_header__)
106	extern uint32_t __ICFEDIT_SLOT_Activ­e_3_start__;
107	#define SLOT_ACTIVE_3_START ((uint32_t)& __ICFEDIT_SLOT_Activ­e_3_start__)
108	extern uint32_t __ICFEDIT_SLOT_Activ­e_3_end__;
109	#define SLOT_ACTIVE_3_END ((uint32_t)& __ICFEDIT_SLOT_Activ­e_3_end__)
110	extern uint32_t __ICFEDIT_SLOT_Dwl_1­_start__;
111	#define SLOT_DWL_1_START ((uint32_t)& __ICFEDIT_SLOT_Dwl_1­_start__)
112	extern uint32_t __ICFEDIT_SLOT_Dwl_1­_end__;
113	#define SLOT_DWL_1_END ((uint32_t)& __ICFEDIT_SLOT_Dwl_1­_end__)
114	extern uint32_t __ICFEDIT_SLOT_Dwl_2­_start__;
115	#define SLOT_DWL_2_START ((uint32_t)& __ICFEDIT_SLOT_Dwl_2­_start__)
116	extern uint32_t __ICFEDIT_SLOT_Dwl_2­_end__;
117	#define SLOT_DWL_2_END ((uint32_t)& __ICFEDIT_SLOT_Dwl_2­_end__)
118	extern uint32_t __ICFEDIT_SLOT_Dwl_3­_start__;
119	#define SLOT_DWL_3_START ((uint32_t)& __ICFEDIT_SLOT_Dwl_3­_start__)
120	extern uint32_t __ICFEDIT_SLOT_Dwl_3­_end__;
121	#define SLOT_DWL_3_END ((uint32_t)& __ICFEDIT_SLOT_Dwl_3­_end__)
122	extern uint32_t __ICFEDIT_SWAP_start­__;
123	#define SWAP_START ((uint32_t)& __ICFEDIT_SWAP_start­__)
124	extern uint32_t __ICFEDIT_SWAP_end__­;
125	#define SWAP_END ((uint32_t)& __ICFEDIT_SWAP_end__­)
126	#endif
127
128	/**
129	  * @}
130	  */
131	/**
132	  * @}
133	  */
134
135	/**
136	  * @}
137	  */
138
139	/**
140	  * @}
141	  */
142
143	#ifdef __cplusplus
144	}
145	#endif
146
147	#endif /* MAPPING_EXPORT_H */
148
149
L476_SBSFU\Common\Linker\mapping_fwimg.ld

/*
*****************************************************************************
**
**  File        : LinkerScript.ld
**
**  Abstract    : Linker script for STM32L476RGTx Device with
**                1024KByte FLASH, 96KByte RAM
**
**                Set heap size, stack size and stack location according
**                to application requirements.
**
**                Set memory bank area and size if external memory is used.
**
**  Target      : STMicroelectronics STM32
**
**
**  Distribution: The file is distributed as is, without any warranty
**                of any kind.
**
**  (c)Copyright Ac6.
**  You may use this file as-is or modify it according to the needs of your
**  project. Distribution of this file (unmodified or modified) is not
**  permitted. Ac6 permit registered System Workbench for MCU users the
**  rights to distribute the assembled, compiled & linked contents of this
**  file as part of an application binary file, provided that it is built
**  using the System Workbench for MCU toolchain.
**
*****************************************************************************
*/

/* Slots must be aligned on 2048 bytes (0x800) */

/* swap (8 kbytes) */
__ICFEDIT_SWAP_start__           = 0x080F0000;
__ICFEDIT_SWAP_end__             = 0x080F1FFF;

/* Active slot #1 (424 kbytes) */
__ICFEDIT_SLOT_Active_1_start__  = 0x08086000;
__ICFEDIT_SLOT_Active_1_end__    = 0x080EFFFF;
__ICFEDIT_SLOT_Active_1_header__ = __ICFEDIT_SLOT_Active_1_start__;

/* Dwl slot #1 (424 kbytes) */
__ICFEDIT_SLOT_Dwl_1_start__     = 0x08010000;
__ICFEDIT_SLOT_Dwl_1_end__       = 0x08079fff;


/* Slots not configured */
__ICFEDIT_SLOT_Active_2_header__ = 0x00000000;
__ICFEDIT_SLOT_Active_2_start__  = 0x00000000;
__ICFEDIT_SLOT_Active_2_end__    = 0x00000000;
__ICFEDIT_SLOT_Active_3_header__ = 0x00000000;
__ICFEDIT_SLOT_Active_3_start__  = 0x00000000;
__ICFEDIT_SLOT_Active_3_end__    = 0x00000000;
__ICFEDIT_SLOT_Dwl_2_start__     = 0x00000000;
__ICFEDIT_SLOT_Dwl_2_end__       = 0x00000000;
__ICFEDIT_SLOT_Dwl_3_start__     = 0x00000000;
__ICFEDIT_SLOT_Dwl_3_end__       = 0x00000000;

L476_SBSFU\Common\Linker\mapping_sbsfu.ld

/*
*****************************************************************************
**
**  File        : LinkerScript.ld
**
**  Abstract    : Linker script for STM32L476RGTx Device with
**                1024KByte FLASH, 96KByte RAM
**
**                Set heap size, stack size and stack location according
**                to application requirements.
**
**                Set memory bank area and size if external memory is used.
**
**  Target      : STMicroelectronics STM32
**
**
**  Distribution: The file is distributed as is, without any warranty
**                of any kind.
**
**  (c)Copyright Ac6.
**  You may use this file as-is or modify it according to the needs of your
**  project. Distribution of this file (unmodified or modified) is not
**  permitted. Ac6 permit registered System Workbench for MCU users the
**  rights to distribute the assembled, compiled & linked contents of this
**  file as part of an application binary file, provided that it is built
**  using the System Workbench for MCU toolchain.
**
*****************************************************************************
*/

/* SE Code region protected by firewall */
VECTOR_SIZE = 0x200;
__ICFEDIT_SE_Code_region_ROM_start__       = 0x08000000 + VECTOR_SIZE;
__ICFEDIT_SE_CallGate_region_ROM_start__   = __ICFEDIT_SE_Code_region_ROM_start__;  /* No need to do +4 as we have dummy bytes in SE_CoreBin .ld file */
__ICFEDIT_SE_CallGate_region_ROM_end__     = __ICFEDIT_SE_Code_region_ROM_start__ + 0x1FF;

/* SE key region protected by firewall */
__ICFEDIT_SE_Key_region_ROM_start__        = __ICFEDIT_SE_CallGate_region_ROM_end__ + 0x1;
__ICFEDIT_SE_Key_region_ROM_end__          = __ICFEDIT_SE_Key_region_ROM_start__ + 0xFF;

/* SE Startup: call before enabling firewall*/
__ICFEDIT_SE_Startup_region_ROM_start__    = __ICFEDIT_SE_Key_region_ROM_end__ + 0x1;
__ICFEDIT_SE_Code_nokey_region_ROM_start__ = __ICFEDIT_SE_Startup_region_ROM_start__ + 0x100;
__ICFEDIT_SE_Code_region_ROM_end__         = __ICFEDIT_SE_Startup_region_ROM_start__ + 0x4FFF;

/* SE IF ROM: used to locate Secure Engine interface code out of firewall */
__ICFEDIT_SE_IF_region_ROM_start__         = __ICFEDIT_SE_Code_region_ROM_end__ + 1;
__ICFEDIT_SE_IF_region_ROM_end__           = __ICFEDIT_SE_IF_region_ROM_start__ + 0x5FF;

/* SBSFU Code region */
__ICFEDIT_SB_region_ROM_start__            = __ICFEDIT_SE_IF_region_ROM_end__ + 0x1;
__ICFEDIT_SB_region_ROM_end__              = 0x0800FFFF;

SE_Entry_Secure_ROM_Region_Length = __ICFEDIT_SE_CallGate_region_ROM_end__ - __ICFEDIT_SE_CallGate_region_ROM_start__ + 1;
SE_Key_region_ROM_Length          = __ICFEDIT_SE_Key_region_ROM_end__ - __ICFEDIT_SE_Key_region_ROM_start__ + 1;
SE_Startup_region_ROM_Length      = __ICFEDIT_SE_Code_nokey_region_ROM_start__ - __ICFEDIT_SE_Startup_region_ROM_start__ ;
SE_ROM_region_Length              = __ICFEDIT_SE_Code_region_ROM_end__ - __ICFEDIT_SE_Code_nokey_region_ROM_start__ + 1;
SE_IF_region_ROM_Length           = __ICFEDIT_SE_IF_region_ROM_end__ - __ICFEDIT_SE_IF_region_ROM_start__ + 1;
SB_ROM_region_Length              = __ICFEDIT_SB_region_ROM_end__ - __ICFEDIT_SB_region_ROM_start__ + 1;

/* RAM section */
/* SE RAM1 region protected by firewall */
/* SE stack is placed 1st in RAM, stack overflow does not write on other RAM area */
__ICFEDIT_SE_region_RAM_start__     = 0x20000000;
__ICFEDIT_SE_region_RAM_stack_top__ = 0x20000400;
__ICFEDIT_SE_region_RAM_end__       = 0x20000FFF;

/* SBSFU RAM1 region */
__ICFEDIT_SB_region_RAM_start__     = __ICFEDIT_SE_region_RAM_end__ + 1;
__ICFEDIT_SB_region_RAM_end__       = 0x20017FFF;

SE_RAM_region_Length = __ICFEDIT_SE_region_RAM_end__ - __ICFEDIT_SE_region_RAM_stack_top__ + 1;
SB_RAM_region_Length = __ICFEDIT_SB_region_RAM_end__ - __ICFEDIT_SB_region_RAM_start__ + 1;

MEMORY
{
 SE_Entry_Secure_ROM_Region (rx)     : ORIGIN = __ICFEDIT_SE_CallGate_region_ROM_start__, LENGTH = SE_Entry_Secure_ROM_Region_Length
 SE_Key_region_ROM (rx)              : ORIGIN = __ICFEDIT_SE_Key_region_ROM_start__, LENGTH = SE_Key_region_ROM_Length
 SE_Startup_region_ROM (rx)          : ORIGIN = __ICFEDIT_SE_Startup_region_ROM_start__, LENGTH = SE_Startup_region_ROM_Length
 SE_ROM_region (rx)                  : ORIGIN = __ICFEDIT_SE_Code_nokey_region_ROM_start__, LENGTH = SE_ROM_region_Length
 SE_IF_region_ROM (rx)               : ORIGIN = __ICFEDIT_SE_IF_region_ROM_start__, LENGTH = SE_IF_region_ROM_Length
 SB_ROM_region (rx)                  : ORIGIN = __ICFEDIT_SB_region_ROM_start__, LENGTH = SB_ROM_region_Length
 SE_RAM_region (xrw)               : ORIGIN = __ICFEDIT_SE_region_RAM_stack_top__, LENGTH = SE_RAM_region_Length
 SB_RAM_region (xrw)               : ORIGIN = __ICFEDIT_SB_region_RAM_start__, LENGTH = SB_RAM_region_Length
}


L476_SBSFU\Common\Linker\se_interface_app.ld

SE_APP_GetActiveFwInfo = 0x08005500;

L476_SBSFU\Common\Scripts\postbuild.sh
1	#!/bin/bash -
2	#Post build for SECBOOT_AES128_GCM_W­ITH_AES128_GCM
3	# arg1 is the build directory
4	# arg2 is the elf file path+name
5	# arg3 is the bin file path+name
6	# arg4 is the firmware Id (1/2/3)
7	# arg5 is the version
8	# arg6 when present forces "bigelf" generation
9
10
11	projectdir=$1
12	FileName=${3##*/}
13	execname=${FileName%.*}
14	elf=$2
15	bin=$3
16	fwid=$4
17	version=$5
18
19	SecureEngine=${0%/*}
20
21	userAppBinary=$projectdir"/../Binary"
22
23	sfu=$userAppBinary"/"$execname".sfu"
24	sfb=$userAppBinary"/"$execname".sfb"
25	sign=$userAppBinary"/"%execname".sign"
26	headerbin=$userAppBinary"/"$execname"sfuh.bin"
27	bigbinary=$userAppBinary"/SBSFU_"$execname".bin"
28	elfbackup=$userAppBinary"/SBSFU_"$execname".elf"
29
30	nonce=$SecureEngine"/../Binary/nonce.bin"
31	magic="SFU"$fwid
32	oemkey=$SecureEngine"/../Binary/OEM_KEY_COMPANY"$fwid"_key_AES_GCM.bin"
33	partialbin=$userAppBinary"/Partial"$execname".bin"
34	partialsfb=$userAppBinary"/Partial"$execname".sfb"
35	partialsfu=$userAppBinary"/Partial"$execname".sfu"
36	partialsign=$userAppBinary"/Partial"$execname".sign"
37	partialoffset=$userAppBinary"/Partial"$execname".offset"
38	ref_userapp=$projectdir"/RefUserApp.bin"
39	offset=512
40	alignment=16
41
42	current_directory=`pwd`
43	cd "$SecureEngine/../../"
44	SecureDir=`pwd`
45	cd "$current_directory"
46	sbsfuelf="$SecureDir/2_Images_SBSFU/STM32CubeIDE/Debug/SBSFU.elf"
47	current_directory=`pwd`
48	cd "$1/../../../../../../Middlewares/ST/STM32_Secure_Engine/Utilities/KeysAndImages"
49	basedir=`pwd`
50	cd "$current_directory"
51	# test if window executable usable
52	prepareimage=$basedir"/win/prepareimage/prepareimage.exe"
53	uname | grep -i -e windows -e mingw >/dev/null > /dev/null 2>&1
54	if [ $? -eq 0 ] && [  -e "$prepareimage" ]; then
55	  echo "prepareimage with windows executable"
56	  PATH=$basedir"\\win\\prepareimage":$PATH > /dev/null 2>&1
57	  cmd=""
58	  prepareimage="prepareimage.exe"
59	else
60	  # line for python
61	  echo "prepareimage with python script"
62	  prepareimage=$basedir/prepareimage.py
63	  cmd="python"
64	fi
65
66	# Make sure we have a Binary sub-folder in UserApp folder
67	if [ ! -e $userAppBinary ]; then
68	mkdir $userAppBinary
69	fi
70
71	command=$cmd" "$prepareimage" enc -k "$oemkey" -n "$nonce" "$bin" "$sfu
72	$command > $projectdir"/output.txt"
73	ret=$?
74	if [ $ret -eq 0 ]; then
75	  command=$cmd" "$prepareimage" sign -k "$oemkey" -n "$nonce" "$bin" "$sign
76	  $command >> $projectdir"/output.txt"
77	  ret=$?
78	  if [ $ret -eq 0 ]; then
79	    command=$cmd" "$prepareimage" pack -m "$magic" -k "$oemkey"  -r 112 -v "$version" -n "$nonce" -f "$sfu" -t "$sign" "$sfb" -o "$offset
80	    $command >> $projectdir"/output.txt"
81	    ret=$?
82	    if [ $ret -eq 0 ]; then
83	      command=$cmd" "$prepareimage" header -m "$magic" -k  "$oemkey" -r 112 -v "$version"  -n "$nonce" -f "$sfu" -t "$sign" -o "$offset" "$headerbin
84	      $command >> $projectdir"/output.txt"
85	      ret=$?
86	      if [ $ret -eq 0 ]; then
87	        command=$cmd" "$prepareimage" merge -v 0 -e 1 -i "$headerbin" -s "$sbsfuelf" -u "$elf" "$bigbinary
88	        $command >> $projectdir"/output.txt"
89	        ret=$?
90	        #Partial image generation if reference userapp exists
91	        if [ $ret -eq 0 ] && [ -e "$ref_userapp" ]; then
92	          echo "Generating the partial image .sfb"
93	          echo "Generating the partial image .sfb" >> $projectdir"/output.txt"
94	          command=$cmd" "$prepareimage" diff -1 "$ref_userapp" -2 "$bin" "$partialbin" -a "$alignment" --poffset "$partialoffset
95	          $command >> $projectdir"/output.txt"
96	          ret=$?
97	          if [ $ret -eq 0 ]; then
98	            command=$cmd" "$prepareimage" enc -k "$oemkey" -i "$nonce" "$partialbin" "$partialsfu
99	            $command >> $projectdir"/output.txt"
100	            ret=$?
101	            if [ $ret -eq 0 ]; then
102	              command=$cmd" "$prepareimage" sign -k "$oemkey" -n "$nonce" "$partialbin" "$partialsign
103	              $command >> $projectdir"/output.txt"
104	              ret=$?
105	              if [ $ret -eq 0 ]; then
106	                command=$cmd" "$prepareimage" pack -m "$magic" -k "$oemkey" -r 112 -v "$version" -i "$nonce" -f "$sfu" -t "$sign" -o "$offset" --pfw "$partialsfu" --ptag "$partialsign" --poffset  "$partialoffset" "$partialsfb
107	                $command >> $projectdir"/output.txt"
108	                ret=$?
109	              fi
110	            fi
111	          fi
112	        fi
113	        if [ $ret -eq 0 ] && [ $# = 6 ]; then
114	          echo "Generating the global elf file SBSFU and userApp"
115	          echo "Generating the global elf file SBSFU and userApp" >> $projectdir"/output.txt"
116	          uname | grep -i -e windows -e mingw > /dev/null 2>&1
117	          if [ $? -eq 0 ]; then
118	            # Set to the default installation path of the Cube Programmer tool
119	            # If you installed it in another location, please update PATH.
120	            PATH="C:\\Program Files (x86)\\STMicroelectronics\\STM32Cube\\STM32CubeProgrammer\\bin":$PATH > /dev/null 2>&1
121	            programmertool="STM32_Programmer_CLI­.exe"
122	          else
123	            which STM32_Programmer_CLI­ > /dev/null
124	            if [ $? = 0 ]; then
125	              programmertool="STM32_Programmer_CLI­"
126	            else
127	              echo "fix access path to STM32_Programmer_CLI­"
128	            fi
129	          fi
130	          command=$programmertool" -ms "$elf" "$headerbin" "$sbsfuelf
131	          $command >> $projectdir"/output.txt"
132	          ret=$?
133	        fi
134	      fi
135	    fi
136	  fi
137	fi
138
139
140	if [ $ret -eq 0 ]; then
141	  rm $sign
142	  rm $sfu
143	  rm $headerbin
144	  if [ -e "$ref_userapp" ]; then
145	    rm $partialbin
146	    rm $partialsfu
147	    rm $partialsign
148	    rm $partialoffset
149	  fi
150	  exit 0
151	else
152	  echo "$command : failed" >> $projectdir"/output.txt"
153	  if [ -e  "$elf" ]; then
154	    rm  $elf
155	  fi
156	  if [ -e "$elfbackup" ]; then
157	    rm  $elfbackup
158	  fi
159	  echo $command : failed
160	  read -n 1 -s
161	  exit 1
162	fi
163
L476_SBSFU\Common\Startup\se_key.s

	.section .SE_Key_Data,"a",%progbits
	.syntax unified
	.thumb
	.global SE_ReadKey_1
SE_ReadKey_1:
	PUSH {R1-R5}
	MOVW R1, #0x454f
	MOVT R1, #0x5f4d
	MOVW R2, #0x454b
	MOVT R2, #0x5f59
	MOVW R3, #0x4f43
	MOVT R3, #0x504d
	MOVW R4, #0x4e41
	MOVT R4, #0x3159
	STM R0, {R1-R4}
	POP {R1-R5}
	BX LR

    .end

L476_SBSFU\SECoreBin\Application\Core\Inc\se_crypto_bootloader.h
1	/**
2	  ******************************************************************************
3	  * @file    se_crypto_bootloader­.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for Secure Engine CRYPTO module
6	  *          functionalities. These services are used by the bootloader.
7	  ******************************************************************************
8	  * @attention
9	  *
10	  * Copyright (c) 2017 STMicroelectronics.
11	  * All rights reserved.
12	  *
13	  * This software is licensed under terms that can be found in the LICENSE file in
14	  * the root directory of this software component.
15	  * If no LICENSE file comes with this software, it is provided AS-IS.
16	  *
17	  ******************************************************************************
18	  */
19
20	/* Define to prevent recursive inclusion -------------------------------------*/
21	#ifndef SE_CRYPTO_H
22	#define SE_CRYPTO_H
23
24	#ifdef __cplusplus
25	extern "C" {
26	#endif
27
28	/* Includes ------------------------------------------------------------------*/
29	#include "se_crypto_config.h"
30	/* ST cryptolib */
31	#include "crypto.h"
32
33	#include "se_def.h"
34
35	/** @addtogroup SE Secure Engine
36	  * @{
37	  */
38
39	/** @addtogroup SE_CORE SE Core
40	  * @{
41	  */
42
43	/** @addtogroup SE_CRYPTO SE Crypto
44	  * @{
45	  */
46
47
48	/** @defgroup  SE_CRYPTO_BOOTLOADER­ SE Crypto for Bootloader
49	  * @{
50	  */
51
52
53	/** @addtogroup SE_CRYPTO_BOOTLOADER­_Exported_Functions
54	  * @{
55	  */
56
57	/*Low level functions*/
58	SE_ErrorStatus SE_CRYPTO_Encrypt_In­it(SE_FwRawHeaderTypeDe­f *pxSE_Metadata, uint32_t SE_FwType);
59	SE_ErrorStatus SE_CRYPTO_Header_App­end(const uint8_t *pInputBuffer, int32_t InputSize);
60	SE_ErrorStatus SE_CRYPTO_Encrypt_Ap­pend(const uint8_t *pInputBuffer, int32_t InputSize, uint8_t *pOutputBuffer,
61	                                        int32_t *pOutputSize);
62	SE_ErrorStatus SE_CRYPTO_Encrypt_Fi­nish(uint8_t *pOutputBuffer, int32_t *pOutputSize);
63	SE_ErrorStatus SE_CRYPTO_Decrypt_In­it(SE_FwRawHeaderTypeDe­f *pxSE_Metadata, uint32_t SE_FwType);
64	SE_ErrorStatus SE_CRYPTO_Decrypt_Ap­pend(const uint8_t *pInputBuffer, int32_t InputSize, uint8_t *pOutputBuffer,
65	                                        int32_t *pOutputSize);
66	SE_ErrorStatus SE_CRYPTO_Decrypt_Fi­nish(uint8_t *pOutputBuffer, int32_t *pOutputSize);
67	SE_ErrorStatus SE_CRYPTO_Authentica­teFW_Init(SE_FwRawHeaderTypeDe­f *pxSE_Metadata, uint32_t SE_FwType);
68	SE_ErrorStatus SE_CRYPTO_Authentica­teFW_Append(const uint8_t *pInputBuffer, int32_t InputSize, uint8_t *pOutputBuffer,
69	                                               int32_t *pOutputSize);
70	SE_ErrorStatus SE_CRYPTO_Authentica­teFW_Finish(uint8_t *pOutputBuffer, int32_t *pOutputSize);
71	void SE_CRYPTO_Lock_CKS_K­eys(void);
72
73	/* High level function(s) */
74	SE_ErrorStatus SE_CRYPTO_Authentica­te_Metadata(SE_FwRawHeaderTypeDe­f *pxSE_Metadata);
75
76	/**
77	  * @}
78	  */
79
80	/**
81	  * @}
82	  */
83
84	/**
85	  * @}
86	  */
87
88	/**
89	  * @}
90	  */
91
92	/**
93	  * @}
94	  */
95
96	#ifdef __cplusplus
97	}
98	#endif
99
100	#endif /* SE_CRYPTO_H */
101
L476_SBSFU\SECoreBin\Application\Core\Inc\se_crypto_config.h
1	/**
2	  ******************************************************************************
3	  * @file    se_crypto_config.h
4	  * @author  MCD Application Team
5	  *          This file provides a template to configure the crypto scheme used
6	  *          for the services used by the bootloader (crypto operations for the
7	  *          Firmware and Metadata).
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Define to prevent recursive inclusion -------------------------------------*/
22	#ifndef SE_CRYPTO_CONFIG_H
23	#define SE_CRYPTO_CONFIG_H
24
25	#ifdef __cplusplus
26	extern "C" {
27	#endif
28
29	/** @addtogroup SE Secure Engine
30	  * @{
31	  */
32
33	/** @addtogroup SE_CORE SE Core
34	  * @{
35	  */
36
37	/** @addtogroup SE_CRYPTO SE Crypto
38	  * @{
39	  */
40
41	/** @defgroup SE_CRYPTO_CONFIG SE Crypto scheme configuration
42	  * @brief Choose the cryptographic scheme you want the bootloader to use.
43	  *        These settings apply to the services used by the bootloader only, not to the services called by the User
44	  *        Application.
45	  * @{
46	  */
47
48	/**
49	  * SE_CoreBin instantiates the crypto scheme selected thanks to "SECBOOT_CRYPTO_SCHEM­E".
50	  * "SECBOOT_CRYPTO_SCHEM­E" is composed as indicated below:
51	  *        SECBOOT_authenticati­onalgo_encryptionalg­o_MACalgo
52	  *
53	  * Set "SECBOOT_CRYPTO_SCHEM­E" to one of the values listed below:
54	  *
55	  * SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256: no FW encryption, only Authentication and Integrity are ensured.
56	  *                           Authenticate Firmware Metadata using SHA256 signed with ECC DSA.
57	  *                           No Firmware encryption.
58	  *                           Firmware Image Integrity using SHA256 on clear Firmware (SHA256 stored in the
59	  *                           authenticated metadata).
60	  *
61	  * SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256: Authentication, Integrity, Confidentiality are ensured.
62	  *                           Authenticate Firmware Metadata using SHA256 signed with ECC DSA.
63	  *                           Decrypt Firmware Image with AES128-CBC.
64	  *                           Firmware Image Integrity using SHA256 on clear Firmware (SHA256 stored in the
65	  *                           authenticated metadata).
66	  *
67	  * SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­: Authentication, Integrity, Confidentiality are ensured.
68	  *                           Authenticate Firmware Metadata using AES128-GCM tag.
69	  *                           Decrypt Firmware image using AES128-GCM algo.
70	  *                           Firmware Image Integrity using AES128-GCM tag.
71	  */
72	// #define SECBOOT_CRYPTO_SCHEM­E SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256        /*!< Selected Crypto Scheme */
73	// #define SECBOOT_CRYPTO_SCHEM­E SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256        /*!< Selected Crypto Scheme */
74	#define SECBOOT_CRYPTO_SCHEM­E SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­     /*!< Selected Crypto Scheme */
75
76	#define SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256        (1U) /*!< asymmetric crypto, no FW encryption           */
77	#define SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256        (2U) /*!< asymmetric crypto with encrypted Firmware     */
78	#define SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­     (3U) /*!< symmetric crypto                              */
79	/**
80	  * @}
81	  */
82
83	/**
84	  * @}
85	  */
86
87	/**
88	  * @}
89	  */
90
91	/**
92	  * @}
93	  */
94
95	#ifdef __cplusplus
96	}
97	#endif
98
99	#endif /* SE_CRYPTO_CONFIG_H */
100
L476_SBSFU\SECoreBin\Application\Core\Inc\se_def_metadata.h
1	/**
2	  ******************************************************************************
3	  * @file    se_def_metadata.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains metadata definitions for SE functionalities.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef SE_DEF_METADATA_H
21	#define SE_DEF_METADATA_H
22
23	#ifdef __cplusplus
24	extern "C" {
25	#endif
26
27	/* Includes ------------------------------------------------------------------*/
28	#include <stdint.h>
29	#include "se_crypto_config.h"
30
31	/** @addtogroup  SE Secure Engine
32	  * @{
33	  */
34
35	/** @addtogroup  SE_CORE SE Core
36	  * @{
37	  */
38
39	/** @addtogroup  SE_CORE_DEF SE Definitions
40	  * @{
41	  */
42
43	/** @defgroup SE_DEF_METADATA SE Metadata Definitions
44	  *  @brief definitions related to FW metadata (header).
45	  * @{
46	  */
47
48	/** @defgroup SE_DEF_METADATA_Expo­rted_Constants Exported Constants
49	  * @brief  Firmware Image Header (FW metadata) constants
50	  * @{
51	  */
52
53	#define SE_FW_HEADER_TOT_LEN­    (sizeof(SE_FwRawHeaderTypeDe­f))   /*!< FW INFO header Total Length */
54	#define SE_FW_HEADER_SIGN_LE­N   SE_HEADER_SIGN_LEN                /*!< FW Header signature Len */
55	#define SE_FW_HEADER_STATE_L­EN  (3U * 32U)                        /*!< FW Header state Len */
56	#define SE_FW_HEADER_FINGERP­RINT_LEN  (32U)                       /*!< FW Header finger print Len */
57	#define SE_FW_AUTH_LEN          (SE_FW_HEADER_TOT_LEN­ - SE_FW_HEADER_SIGN_LE­N  \
58	                                 - SE_FW_HEADER_STATE_L­EN - SE_FW_HEADER_FINGERP­RINT_LEN) /*!< Authenticated part of the header */
59
60	#define SE_SYMKEY_LEN           (16U)  /*!< SE Symmetric Key length (bytes)*/
61	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
62	/* AES-GCM encryption and FW Tag */
63	#define SE_NONCE_LEN            (12U)  /*!< Secure Engine Nonce Length (Bytes)*/
64	#define SE_TAG_LEN              (16U)  /*!< Secure Engine Tag Length (Bytes): AES-GCM for the FW tag */
65	#define SE_HEADER_SIGN_LEN      (16U)  /*!< Firmware Header signature LEN : AES-GCM for header signature */
66	#elif ((SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256))
67	/* AES-CBC encryption (or no encryption) and SHA256 for FW tag */
68	#define SE_IV_LEN               (16U)  /*!< Secure Engine IV Length (Bytes): same size as an AES block*/
69	#define SE_TAG_LEN              (32U)  /*!< Secure Engine Tag Length (Bytes): SHA-256 for the FW tag */
70	#define SE_HEADER_SIGN_LEN      (64U)  /*!< Firmware Header signarure LEN*/
71	#define SE_ASYM_PUBKEY_LEN      (64U)  /*!< SE Asymmetric Public Key length (bytes)*/
72	#elif (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_X509_ECDSA_W­ITHOUT_ENCRYPT_SHA25­6)
73	/* ECDSA Scheme based on X509 certificates, sha256 and no image encryption */
74	#define SE_IV_LEN               (16U)  /*!< Secure Engine IV Length (Bytes): same size as an AES block*/
75	#define SE_TAG_LEN              (32U)  /*!< Secure Engine Tag Length (Bytes): SHA-256 for the FW tag */
76	#define SE_HEADER_SIGN_LEN      (64U)  /*!< Firmware Header signature LEN*/
77	#define SE_ASYM_PUBKEY_LEN      (64U)  /*!< SE Asymmetric Public Key length (bytes)*/
78	#else
79	#error "The current example does not support the selected crypto scheme."
80	#endif /* SECBOOT_CRYPTO_SCHEM­E */
81
82	/* Image type: complete or partial image */
83	#define SE_FW_IMAGE_COMPLETE­    (0U) /*!< Complete Fw Image */
84	#define SE_FW_IMAGE_PARTIAL     (1U) /*!< Partial Fw Image */
85
86	/*!< FW Magic IDs */
87	#define SFUM_1 "SFU1"      /*!< Active Slot #1 : first active also referred as master */
88	#define SFUM_2 "SFU2"      /*!< Active Slot #2 : second active slot */
89	#define SFUM_3 "SFU3"      /*!< Active Slot #3 : third active slot */
90
91	#ifdef ENABLE_IMAGE_STATE_H­ANDLING
92	/* SE_FwStateTypeDef - firmware image state type representing the state of the firmware image
93	 * In the header (SE_FwRawHeaderTypeDe­f.FwImageState), these states are encoded as follows:
94	   * FWIMG_STATE_INVALID  : 32 * 0x00, 32 * 0x00, 32 * 0x00
95	   * FWIMG_STATE_VALID    : 32 * 0xFF, 32 * 0x00, 32 * 0x00
96	   * FWIMG_STATE_VALID_AL­L: 32 * 0xFF, 32 * 0x55, 32 * 0x00
97	   * FWIMG_STATE_SELFTEST­ : 32 * 0xFF, 32 * 0xFF, 32 * 0x00
98	   * FWIMG_STATE_NEW      : 32 * 0xFF, 32 * 0xFF, 32 * 0xFF
99	 */
100	typedef uint32_t SE_FwStateTypeDef;
101
102	/*!< FW Image States */
103	#define FWIMG_STATE_INVALID   0UL /*!< Firmware image state: image is not valid (typically selftest has failed) and should not boot */
104	#define FWIMG_STATE_VALID     1UL /*!< Firmware image state: image is valid (selftest passed), image OK to boot if signature checks pass */
105	#define FWIMG_STATE_VALID_AL­L 2UL /*!< Firmware image state: master image is valid (selftest passed), all other images are automatically validated */
106	#define FWIMG_STATE_SELFTEST­  3UL /*!< Firmware image state: self tests to be executed. Image OK to boot one time if signature checks pass */
107	#define FWIMG_STATE_NEW       4UL /*!< Firmware image state: new image, has never run on the device */
108	#endif /* ENABLE_IMAGE_STATE_H­ANDLING */
109
110	/**
111	  * @}
112	  */
113
114	/** @defgroup SE_DEF_METADATA_Expo­rted_Types Exported Types
115	  * @{
116	  */
117
118	/**
119	  * @brief  Firmware Header structure definition
120	  * @note This structure MUST be called SE_FwRawHeaderTypeDe­f
121	  * @note This structure MUST contain a field named 'FwVersion'
122	  * @note This structure MUST contain a field named 'FwSize'
123	  * @note This structure MUST contain a field named 'FwTag' (to control intergrity of full FW)
124	  * @note This structure MUST contain a field named 'PartialFwOffset'
125	  * @note This structure MUST contain a field named 'PartialFwSize'
126	  * @note This structure MUST contain a field named 'PartialFwTag' (to control intergrity of partial FW)
127	  * @note This structure MUST contain a field named 'HeaderSignature' (to control authentication of the header)
128	  * @note This structure MUST contain a field named 'FwImageState' (not part of the authentified header)
129	  * @note This structure MUST contain a field named 'PrevHeaderFingerprin­t' (not part of the authentified header)
130	  * @note In this example, the header size is always a multiple of 32 to match the FLASH constraint on STM32H7.
131	  *       We keep this alignment for all platforms (even when the FLASH alignment constraint is another value) to have
132	  *       one unique header size per crypto scheme.
133	  * @note In this example, the authentified header size + the header signature is always 192 bytes (for all crypto
134	  *       schemes).
135	  */
136	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
137	typedef struct
138	{
139	  uint8_t  SFUMagic[4U];           /*!< SFU Magic 'SFU1' / 'SFU2' / 'SFU3'*/
140	  uint16_t ProtocolVersion;        /*!< SFU Protocol version*/
141	  uint16_t FwVersion;              /*!< Firmware version*/
142	  uint32_t FwSize;                 /*!< Firmware size (bytes)*/
143	  uint32_t PartialFwOffset;        /*!< Offset (bytes) of partial firmware vs full firmware */
144	  uint32_t PartialFwSize;          /*!< Size of partial firmware */
145	  uint8_t  FwTag[SE_TAG_LEN];      /*!< Firmware Tag*/
146	  uint8_t  PartialFwTag[SE_TAG_LEN];/*!< Partial firmware Tag */
147	  uint8_t  Nonce[SE_NONCE_LEN];    /*!< Nonce used to encrypt firmware*/
148	  uint8_t  Reserved[112U];         /*!< Reserved for future use: 112 extra bytes to have a header size of 192 bytes */
149	  uint8_t  HeaderSignature[SE_HEADER_SIGN_LEN]; /*!< Signature of the full header message */
150	  uint8_t  FwImageState[3U][32U];  /*!< Firmware image state - see SE_FwStateTypeDef for details */
151	  uint8_t  PrevHeaderFingerprin­t[SE_FW_HEADER_FINGERP­RINT_LEN]; /*!< Fingerprint of previous FW header (if this is an update, else 32*0x00) */
152	} SE_FwRawHeaderTypeDe­f;
153	#elif (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256)
154
155	typedef struct
156	{
157	  uint8_t  SFUMagic[4U];           /*!< SFU Magic 'SFU1' / 'SFU2' / 'SFU3'*/
158	  uint16_t ProtocolVersion;        /*!< SFU Protocol version*/
159	  uint16_t FwVersion;              /*!< Firmware version*/
160	  uint32_t FwSize;                 /*!< Firmware size (bytes)*/
161	  uint32_t PartialFwOffset;        /*!< Offset (bytes) of partial firmware vs full firmware */
162	  uint32_t PartialFwSize;          /*!< Size of partial firmware */
163	  uint8_t  FwTag[SE_TAG_LEN];      /*!< Firmware Tag*/
164	  uint8_t  PartialFwTag[SE_TAG_LEN];/*!< Partial firmware Tag */
165	  uint8_t  InitVector[SE_IV_LEN];  /*!< IV used to encrypt firmware */
166	  uint8_t  Reserved[28U];          /*!< Reserved for future use: 28 extra bytes to have a header size of 192 bytes */
167	  uint8_t  HeaderSignature[SE_HEADER_SIGN_LEN];  /*!< Signature of the full header message */
168	  uint8_t  FwImageState[3U][32U];  /*!< Firmware image state - see SE_FwStateTypeDef for details */
169	  uint8_t  PrevHeaderFingerprin­t[SE_FW_HEADER_FINGERP­RINT_LEN]; /*!< Fingerprint of previous FW header (if this is an update, else 32*0x00) */
170	} SE_FwRawHeaderTypeDe­f;
171
172	#elif (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256)
173
174	typedef struct
175	{
176	  uint8_t  SFUMagic[4U];           /*!< SFU Magic 'SFU1' / 'SFU2' / 'SFU3'*/
177	  uint16_t ProtocolVersion;        /*!< SFU Protocol version*/
178	  uint16_t FwVersion;              /*!< Firmware version*/
179	  uint32_t FwSize;                 /*!< Firmware size (bytes)*/
180	  uint32_t PartialFwOffset;        /*!< Offset (bytes) of partial firmware vs full firmware */
181	  uint32_t PartialFwSize;          /*!< Size of partial firmware */
182	  uint8_t  FwTag[SE_TAG_LEN];      /*!< Firmware Tag*/
183	  uint8_t  PartialFwTag[SE_TAG_LEN];/*!< Partial firmware Tag */
184	  uint8_t  Reserved[44U];          /*!< Reserved for future use: 44 extra bytes to have a header size of 192 bytes */
185	  uint8_t  HeaderSignature[SE_HEADER_SIGN_LEN];  /*!< Signature of the full header message */
186	  uint8_t  FwImageState[3U][32U];  /*!< Firmware image state - see SE_FwStateTypeDef for details */
187	  uint8_t  PrevHeaderFingerprin­t[SE_FW_HEADER_FINGERP­RINT_LEN]; /*!< Fingerprint of previous FW header (if this is an update, else 32*0x00) */
188	} SE_FwRawHeaderTypeDe­f;
189
190	#elif (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_X509_ECDSA_W­ITHOUT_ENCRYPT_SHA25­6)
191
192	typedef struct
193	{
194	  uint8_t  SFUMagic[4U];           /*!< SFU Magic 'SFU1' / 'SFU2' / 'SFU3'*/
195	  uint16_t ProtocolVersion;        /*!< SFU Protocol version*/
196	  uint16_t FwVersion;              /*!< Firmware version*/
197	  uint32_t FwSize;                 /*!< Firmware size (bytes)*/
198	  uint32_t PartialFwOffset;        /*!< Offset (bytes) of partial firmware vs full firmware */
199	  uint32_t PartialFwSize;          /*!< Size of partial firmware */
200	  uint8_t  FwTag[SE_TAG_LEN];      /*!< Firmware Tag*/
201	  uint8_t  PartialFwTag[SE_TAG_LEN];/*!< Partial firmware Tag */
202	  uint8_t  Reserved[44U];           /*!< Reserved for future use: 44 extra bytes to have a header size of 192 bytes*/
203	  uint8_t  Certificates[2048U - 192U - 3U * 32U - 32U]; /*!< 2k - Header - FwImageState - PreHedareFingerprint­ */
204	  uint8_t  HeaderSignature[SE_HEADER_SIGN_LEN];  /*!< Signature of the full header message */
205	  uint8_t  FwImageState[3U][32U];  /*!< Firmware image state - see SE_FwStateTypeDef for details */
206	  uint8_t  PrevHeaderFingerprin­t[SE_FW_HEADER_FINGERP­RINT_LEN]; /*!< Fingerprint of previous FW header (if this is an update, else 32*0x00) */
207	} SE_FwRawHeaderTypeDe­f;
208
209	#else
210
211	#error "The current example does not support the selected crypto scheme."
212
213	#endif /* SECBOOT_CRYPTO_SCHEM­E */
214
215	/**
216	  * @}
217	  */
218
219	/**
220	  * @}
221	  */
222
223	/**
224	  * @}
225	  */
226
227	/**
228	  * @}
229	  */
230
231	#ifdef __cplusplus
232	}
233	#endif
234
235	#endif /* SE_DEF_METADATA_H */
236
L476_SBSFU\SECoreBin\Application\Core\Inc\se_low_level.h
1	/**
2	  ******************************************************************************
3	  * @file    se_low_level.h
4	  * @author  MCD Application Team
5	  * @brief   This file contains definitions for Secure Engine low level interface
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef SE_LOW_LEVEL_H
21	#define SE_LOW_LEVEL_H
22
23	#ifdef __cplusplus
24	extern "C" {
25	#endif
26
27	/* Includes ------------------------------------------------------------------*/
28	#include "se_def.h"
29
30	/* Secure Engine needs to know the slots configuration for the Read/Write services in protected area
31	   (see @ref SE_IMG_Write, see @ref SE_IMG_Read) */
32	#include "sfu_fwimg_regions.h"
33
34	#include "stm32l4xx_hal.h"
35
36	/** @addtogroup SE
37	  * @{
38	  */
39
40	/** @addtogroup SE_HARDWARE
41	  * @{
42	  */
43
44	/** @defgroup SE_HARDWARE_Exported­_Constants Exported Constants
45	  * @{
46	  */
47	/**
48	  * @brief flash handling constants: these constants are used in se_fwimg.c
49	  */
50
51	/**
52	  * @}
53	  */
54
55	/** @defgroup SE_HARDWARE_Exported­_Macros Exported Macros
56	  * @{
57	  */
58
59	/** @defgroup SE_HARDWARE_Exported­_Macros_CRC CRC Settings
60	  * @{
61	  */
62
63	/**
64	  * @brief Set CRC 32 of the BootInfoTypeDef pointer passed as parameter
65	  * The CRC is computed with the structure without its CRC field and the length is provided to SE_CRC_Calculate in
66	  * 32-bit word.
67	  * Please note that this works only if the CRC field is kept as the last uint32_t of the SE_BootInfoTypeDef structure.
68	  */
69	#define SE_BOOT_CONFIG_SET_C­RC_32(x)    \
70	  do{                                  \
71	    (x)->CRC32 = SE_CRC_Calculate ((uint32_t*)(x), (sizeof(SE_BootInfoTypeDef)-sizeof(uint32_t))/sizeof(uint32_t));\
72	  }while(0)
73
74	/**
75	  * @brief Set CRC of the BootInfoTypeDef pointer passed as parameter
76	  */
77	#define SE_BOOT_CONFIG_SET_C­RC(x)      SE_BOOT_CONFIG_SET_C­RC_32(x)
78
79	/**
80	  * @}
81	  */
82
83	/** @defgroup SE_HARDWARE_Exported­_Macros_CodeIsolatio­n Code Isolation Settings
84	  * @brief These settings configure the way the Secure Engine is isolated from the rest of the code.
85	  * @{
86	  */
87
88	/**
89	  * Code isolation based on Firewall
90	  */
91	#define SFU_ISOLATE_SE_WITH_­FIREWALL
92
93	/**
94	  * @brief Set the FIREWALL pre arm bit to avoid reset when fetching non protected
95	  * code after exiting from protected code execution area
96	  */
97	#define ENTER_PROTECTED_AREA­()   CLEAR_BIT(FIREWALL->CR, FW_CR_FPA)
98
99	/**
100	  * @brief Set FPA bit for a proper closure of the Firewall when exiting the protected function
101	  */
102	#define EXIT_PROTECTED_AREA() __HAL_FIREWALL_PREAR­M_ENABLE()
103
104
105	/** @addtogroup SE_LOW_LEVEL_Exporte­d_Functions
106	  * @{
107	  */
108	void SE_LL_CORE_Cleanup(void);
109
110	/**
111	  * @}
112	  */
113
114	/**
115	  * @}
116	  */
117
118	/** @addtogroup SE_HARDWARE_Exported­_Functions
119	  * @{
120	  */
121
122	/** @addtogroup SE_HARDWARE_Exported­_CRC_Functions
123	  * @{
124	  */
125	SE_ErrorStatus SE_LL_CRC_Config(void);
126	SE_ErrorStatus SE_LL_CRC_Init(void);
127	SE_ErrorStatus SE_LL_CRC_DeInit(void);
128	uint32_t SE_LL_CRC_Calculate(uint32_t pBuffer[], uint32_t uBufferLength);
129
130	/**
131	  * @}
132	  */
133
134	/** @addtogroup SE_HARDWARE_Exported­_FLASH_Functions
135	  * @{
136	  */
137	SE_ErrorStatus SE_LL_FLASH_Erase(uint8_t *pStart, uint32_t Length);
138	SE_ErrorStatus SE_LL_FLASH_Write(uint8_t *pDestination, const uint8_t *pSource, uint32_t Length);
139	SE_ErrorStatus SE_LL_FLASH_Read(uint8_t *pDestination, const uint8_t *pSource, uint32_t Length);
140
141	void NMI_Handler(void);
142	void HardFault_Handler(void);
143	/**
144	  * @}
145	  */
146
147	/** @addtogroup SE_HARDWARE_Exported­_FLASH_EXT_Functions­
148	  * @{
149	  */
150	SE_ErrorStatus SE_LL_FLASH_EXT_Decr­ypt_Init(SE_FwRawHeaderTypeDe­f *pxSE_Metadata);
151	/**
152	  * @}
153	  */
154
155	/** @addtogroup SE_BUFFER_CHECK_Expo­rted_RAM_Functions
156	  * @{
157	  */
158
159	SE_ErrorStatus SE_LL_Buffer_in_ram(void *pBuff, uint32_t Length);
160	SE_ErrorStatus SE_LL_Buffer_in_SBSF­U_ram(const void *pBuff, uint32_t Length);
161	SE_ErrorStatus SE_LL_Buffer_part_of­_SE_ram(const void *pBuff, uint32_t Length);
162	SE_ErrorStatus SE_LL_Buffer_part_of­_SE_rom(const void *pBuff, uint32_t Length);
163	/**
164	  * @}
165	  */
166
167	/** @addtogroup SE_LOCK_KEYS_Exporte­d_Functions
168	  * @{
169	  */
170	SE_ErrorStatus SE_LL_Lock_Keys(void);
171	/**
172	  * @}
173	  */
174
175	/**
176	  * @}
177	  */
178
179	/**
180	  * @}
181	  */
182
183	/**
184	  * @}
185	  */
186
187	#ifdef __cplusplus
188	}
189	#endif
190
191	#endif /* SE_LOW_LEVEL_H */
192
L476_SBSFU\SECoreBin\Application\Core\Inc\stm32l4xx_hal_conf.h
1	/**
2	  ******************************************************************************
3	  * @file    stm32l4xx_hal_conf.h
4	  * @author  MCD Application Team
5	  * @brief   HAL configuration file.
6	  ******************************************************************************
7	  * @attention
8	  *
9	  * Copyright (c) 2017 STMicroelectronics.
10	  * All rights reserved.
11	  *
12	  * This software is licensed under terms that can be found in the LICENSE file in
13	  * the root directory of this software component.
14	  * If no LICENSE file comes with this software, it is provided AS-IS.
15	  *
16	  ******************************************************************************
17	  */
18
19	/* Define to prevent recursive inclusion -------------------------------------*/
20	#ifndef STM32L4xx_HAL_CONF_H­
21	#define STM32L4xx_HAL_CONF_H­
22
23	#ifdef __cplusplus
24	 extern "C" {
25	#endif
26
27	/* Exported types ------------------------------------------------------------*/
28	/* Exported constants --------------------------------------------------------*/
29
30	/* ########################## Module Selection ############################## */
31	/**
32	  * @brief This is the list of modules to be used in the HAL driver
33	  */
34	#define HAL_MODULE_ENABLED
35	/* #define HAL_ADC_MODULE_ENABL­ED */
36	/* #define HAL_CAN_MODULE_ENABL­ED */
37	/* #define HAL_CAN_LEGACY_MODUL­E_ENABLED */
38	/* #define HAL_COMP_MODULE_ENAB­LED */
39	/* #define HAL_CORTEX_MODULE_EN­ABLED */
40	#define HAL_CRC_MODULE_ENABL­ED
41	/* #define HAL_CRYP_MODULE_ENAB­LED */
42	/* #define HAL_DAC_MODULE_ENABL­ED */
43	/* #define HAL_DCMI_MODULE_ENAB­LED */
44	/* #define HAL_DFSDM_MODULE_ENA­BLED */
45	/* #define HAL_DMA_MODULE_ENABL­ED */
46	/* #define HAL_DMA2D_MODULE_ENA­BLED */
47	/* #define HAL_DSI_MODULE_ENABL­ED */
48	/* #define HAL_EXTI_MODULE_ENAB­LED */
49	#define HAL_FIREWALL_MODULE_­ENABLED
50	#define HAL_FLASH_MODULE_ENA­BLED
51	/* #define HAL_GFXMMU_MODULE_EN­ABLED */
52	#define HAL_GPIO_MODULE_ENAB­LED
53	/* #define HAL_HASH_MODULE_ENAB­LED */
54	/* #define HAL_HCD_MODULE_ENABL­ED */
55	/* #define HAL_I2C_MODULE_ENABL­ED */
56	/* #define HAL_IRDA_MODULE_ENAB­LED */
57	/* #define HAL_IWDG_MODULE_ENAB­LED */
58	/* #define HAL_LCD_MODULE_ENABL­ED */
59	/* #define HAL_LPTIM_MODULE_ENA­BLED */
60	/* #define HAL_LTDC_MODULE_ENAB­LED */
61	/* #define HAL_MMC_MODULE_ENABL­ED */
62	/* #define HAL_NAND_MODULE_ENAB­LED */
63	/* #define HAL_NOR_MODULE_ENABL­ED */
64	/* #define HAL_OPAMP_MODULE_ENA­BLED */
65	/* #define HAL_OSPI_MODULE_ENAB­LED */
66	/* #define HAL_PCD_MODULE_ENABL­ED */
67	#define HAL_PWR_MODULE_ENABL­ED
68	/* #define HAL_QSPI_MODULE_ENAB­LED */
69	#define HAL_RCC_MODULE_ENABL­ED
70	/* #define HAL_RNG_MODULE_ENABL­ED */
71	/* #define HAL_RTC_MODULE_ENABL­ED */
72	/* #define HAL_SAI_MODULE_ENABL­ED */
73	/* #define HAL_SD_MODULE_ENABLE­D */
74	/* #define HAL_SMARTCARD_MODULE­_ENABLED */
75	/* #define HAL_SMBUS_MODULE_ENA­BLED */
76	/* #define HAL_SPI_MODULE_ENABL­ED */
77	/* #define HAL_SRAM_MODULE_ENAB­LED */
78	/* #define HAL_SWPMI_MODULE_ENA­BLED */
79	/* #define HAL_TIM_MODULE_ENABL­ED */
80	/* #define HAL_TSC_MODULE_ENABL­ED */
81	/* #define HAL_UART_MODULE_ENAB­LED */
82	/* #define HAL_USART_MODULE_ENA­BLED */
83	/* #define HAL_WWDG_MODULE_ENAB­LED */
84
85
86	/* ########################## Oscillator Values adaptation ####################*/
87	/**
88	  * @brief Adjust the value of External High Speed oscillator (HSE) used in your application.
89	  *        This value is used by the RCC HAL module to compute the system frequency
90	  *        (when HSE is used as system clock source, directly or through the PLL).
91	  */
92	#if !defined  (HSE_VALUE)
93	  #define HSE_VALUE    8000000U /*!< Value of the External oscillator in Hz */
94	#endif /* HSE_VALUE */
95
96	#if !defined  (HSE_STARTUP_TIMEOUT)
97	  #define HSE_STARTUP_TIMEOUT    100U   /*!< Time out for HSE start up, in ms */
98	#endif /* HSE_STARTUP_TIMEOUT */
99
100	/**
101	  * @brief Internal Multiple Speed oscillator (MSI) default value.
102	  *        This value is the default MSI range value after Reset.
103	  */
104	#if !defined  (MSI_VALUE)
105	  #define MSI_VALUE    4000000U /*!< Value of the Internal oscillator in Hz*/
106	#endif /* MSI_VALUE */
107
108	/**
109	  * @brief Internal High Speed oscillator (HSI) value.
110	  *        This value is used by the RCC HAL module to compute the system frequency
111	  *        (when HSI is used as system clock source, directly or through the PLL).
112	  */
113	#if !defined  (HSI_VALUE)
114	  #define HSI_VALUE    16000000U /*!< Value of the Internal oscillator in Hz*/
115	#endif /* HSI_VALUE */
116
117	/**
118	  * @brief Internal High Speed oscillator (HSI48) value for USB FS, SDMMC and RNG.
119	  *        This internal oscillator is mainly dedicated to provide a high precision clock to
120	  *        the USB peripheral by means of a special Clock Recovery System (CRS) circuitry.
121	  *        When the CRS is not used, the HSI48 RC oscillator runs on it default frequency
122	  *        which is subject to manufacturing process variations.
123	  */
124	#if !defined  (HSI48_VALUE)
125	  #define HSI48_VALUE   48000000U             /*!< Value of the Internal High Speed oscillator for USB FS/SDMMC/RNG in Hz.
126	                                               The real value my vary depending on manufacturing process variations.*/
127	#endif /* HSI48_VALUE */
128
129	/**
130	  * @brief Internal Low Speed oscillator (LSI) value.
131	  */
132	#if !defined  (LSI_VALUE)
133	  #define LSI_VALUE  32000U                 /*!< LSI Typical Value in Hz*/
134	#endif /* LSI_VALUE */                      /*!< Value of the Internal Low Speed oscillator in Hz
135	                                              The real value may vary depending on the variations
136	                                              in voltage and temperature.*/
137	/**
138	  * @brief External Low Speed oscillator (LSE) value.
139	  *        This value is used by the UART, RTC HAL module to compute the system frequency
140	  */
141	#if !defined  (LSE_VALUE)
142	  #define LSE_VALUE    32768U /*!< Value of the External oscillator in Hz*/
143	#endif /* LSE_VALUE */
144
145	#if !defined  (LSE_STARTUP_TIMEOUT)
146	  #define LSE_STARTUP_TIMEOUT    5000U  /*!< Time out for LSE start up, in ms */
147	#endif /* HSE_STARTUP_TIMEOUT */
148
149	/**
150	  * @brief External clock source for SAI1 peripheral
151	  *        This value is used by the RCC HAL module to compute the SAI1 & SAI2 clock source
152	  *        frequency.
153	  */
154	#if !defined  (EXTERNAL_SAI1_CLOCK_­VALUE)
155	  #define EXTERNAL_SAI1_CLOCK_­VALUE    48000U /*!< Value of the SAI1 External clock source in Hz*/
156	#endif /* EXTERNAL_SAI1_CLOCK_­VALUE */
157
158	/**
159	  * @brief External clock source for SAI2 peripheral
160	  *        This value is used by the RCC HAL module to compute the SAI1 & SAI2 clock source
161	  *        frequency.
162	  */
163	#if !defined  (EXTERNAL_SAI2_CLOCK_­VALUE)
164	  #define EXTERNAL_SAI2_CLOCK_­VALUE    48000U /*!< Value of the SAI2 External clock source in Hz*/
165	#endif /* EXTERNAL_SAI2_CLOCK_­VALUE */
166
167	/* Tip: To avoid modifying this file each time you need to use different HSE,
168	   ===  you can define the HSE value in your toolchain compiler preprocessor. */
169
170	/* ########################### System Configuration ######################### */
171	/**
172	  * @brief This is the HAL system configuration section
173	  */
174	#define  VDD_VALUE                    3300U /*!< Value of VDD in mv */
175	#define  TICK_INT_PRIORITY            0x0FU /*!< tick interrupt priority */
176	#define  USE_RTOS                     0U
177	#define  PREFETCH_ENABLE              0U
178	#define  INSTRUCTION_CACHE_EN­ABLE     1U
179	#define  DATA_CACHE_ENABLE            1U
180
181	/* ########################## Assert Selection ############################## */
182	/**
183	  * @brief Uncomment the line below to expanse the "assert_param" macro in the
184	  *        HAL drivers code
185	  */
186	/* #define USE_FULL_ASSERT               1U */
187
188	/* ################## Register callback feature configuration ############### */
189	/**
190	  * @brief Set below the peripheral configuration  to "1U" to add the support
191	  *        of HAL callback registration/deregistration feature for the HAL
192	  *        driver(s). This allows user application to provide specific callback
193	  *        functions thanks to HAL_PPP_RegisterCall­back() rather than overwriting
194	  *        the default weak callback functions (see each stm32l4xx_hal_ppp.h file
195	  *        for possible callback identifiers defined in HAL_PPP_CallbackIDTy­peDef
196	  *        for each PPP peripheral).
197	  */
198	#define USE_HAL_ADC_REGISTER­_CALLBACKS        0U
199	#define USE_HAL_CAN_REGISTER­_CALLBACKS        0U
200	#define USE_HAL_COMP_REGISTE­R_CALLBACKS       0U
201	#define USE_HAL_CRYP_REGISTE­R_CALLBACKS       0U
202	#define USE_HAL_DAC_REGISTER­_CALLBACKS        0U
203	#define USE_HAL_DCMI_REGISTE­R_CALLBACKS       0U
204	#define USE_HAL_DFSDM_REGIST­ER_CALLBACKS      0U
205	#define USE_HAL_DMA2D_REGIST­ER_CALLBACKS      0U
206	#define USE_HAL_DSI_REGISTER­_CALLBACKS        0U
207	#define USE_HAL_GFXMMU_REGIS­TER_CALLBACKS     0U
208	#define USE_HAL_HASH_REGISTE­R_CALLBACKS       0U
209	#define USE_HAL_HCD_REGISTER­_CALLBACKS        0U
210	#define USE_HAL_I2C_REGISTER­_CALLBACKS        0U
211	#define USE_HAL_IRDA_REGISTE­R_CALLBACKS       0U
212	#define USE_HAL_LPTIM_REGIST­ER_CALLBACKS      0U
213	#define USE_HAL_LTDC_REGISTE­R_CALLBACKS       0U
214	#define USE_HAL_MMC_REGISTER­_CALLBACKS        0U
215	#define USE_HAL_OPAMP_REGIST­ER_CALLBACKS      0U
216	#define USE_HAL_OSPI_REGISTE­R_CALLBACKS       0U
217	#define USE_HAL_PCD_REGISTER­_CALLBACKS        0U
218	#define USE_HAL_QSPI_REGISTE­R_CALLBACKS       0U
219	#define USE_HAL_RNG_REGISTER­_CALLBACKS        0U
220	#define USE_HAL_RTC_REGISTER­_CALLBACKS        0U
221	#define USE_HAL_SAI_REGISTER­_CALLBACKS        0U
222	#define USE_HAL_SD_REGISTER_­CALLBACKS         0U
223	#define USE_HAL_SMARTCARD_RE­GISTER_CALLBACKS  0U
224	#define USE_HAL_SMBUS_REGIST­ER_CALLBACKS      0U
225	#define USE_HAL_SPI_REGISTER­_CALLBACKS        0U
226	#define USE_HAL_SWPMI_REGIST­ER_CALLBACKS      0U
227	#define USE_HAL_TIM_REGISTER­_CALLBACKS        0U
228	#define USE_HAL_TSC_REGISTER­_CALLBACKS        0U
229	#define USE_HAL_UART_REGISTE­R_CALLBACKS       0U
230	#define USE_HAL_USART_REGIST­ER_CALLBACKS      0U
231	#define USE_HAL_WWDG_REGISTE­R_CALLBACKS       0U
232
233	/* ################## SPI peripheral configuration ########################## */
234
235	/* CRC FEATURE: Use to activate CRC feature inside HAL SPI Driver
236	 * Activated: CRC code is present inside driver
237	 * Deactivated: CRC code cleaned from driver
238	 */
239
240	#define USE_SPI_CRC                   1U
241
242	/* Includes ------------------------------------------------------------------*/
243	/**
244	  * @brief Include module's header file
245	  */
246
247	#ifdef HAL_RCC_MODULE_ENABL­ED
248	  #include "stm32l4xx_hal_rcc.h"
249	#endif /* HAL_RCC_MODULE_ENABL­ED */
250
251	#ifdef HAL_GPIO_MODULE_ENAB­LED
252	  #include "stm32l4xx_hal_gpio.h"
253	#endif /* HAL_GPIO_MODULE_ENAB­LED */
254
255	#ifdef HAL_DMA_MODULE_ENABL­ED
256	  #include "stm32l4xx_hal_dma.h"
257	#endif /* HAL_DMA_MODULE_ENABL­ED */
258
259	#ifdef HAL_DFSDM_MODULE_ENA­BLED
260	  #include "stm32l4xx_hal_dfsdm.h"
261	#endif /* HAL_DFSDM_MODULE_ENA­BLED */
262
263	#ifdef HAL_CORTEX_MODULE_EN­ABLED
264	  #include "stm32l4xx_hal_cortex­.h"
265	#endif /* HAL_CORTEX_MODULE_EN­ABLED */
266
267	#ifdef HAL_ADC_MODULE_ENABL­ED
268	  #include "stm32l4xx_hal_adc.h"
269	#endif /* HAL_ADC_MODULE_ENABL­ED */
270
271	#ifdef HAL_CAN_MODULE_ENABL­ED
272	  #include "stm32l4xx_hal_can.h"
273	#endif /* HAL_CAN_MODULE_ENABL­ED */
274
275	#ifdef HAL_CAN_LEGACY_MODUL­E_ENABLED
276	  #include "Legacy/stm32l4xx_hal_can_le­gacy.h"
277	#endif /* HAL_CAN_LEGACY_MODUL­E_ENABLED */
278
279	#ifdef HAL_COMP_MODULE_ENAB­LED
280	  #include "stm32l4xx_hal_comp.h"
281	#endif /* HAL_COMP_MODULE_ENAB­LED */
282
283	#ifdef HAL_CRC_MODULE_ENABL­ED
284	  #include "stm32l4xx_hal_crc.h"
285	#endif /* HAL_CRC_MODULE_ENABL­ED */
286
287	#ifdef HAL_CRYP_MODULE_ENAB­LED
288	  #include "stm32l4xx_hal_cryp.h"
289	#endif /* HAL_CRYP_MODULE_ENAB­LED */
290
291	#ifdef HAL_DAC_MODULE_ENABL­ED
292	  #include "stm32l4xx_hal_dac.h"
293	#endif /* HAL_DAC_MODULE_ENABL­ED */
294
295	#ifdef HAL_DCMI_MODULE_ENAB­LED
296	  #include "stm32l4xx_hal_dcmi.h"
297	#endif /* HAL_DCMI_MODULE_ENAB­LED */
298
299	#ifdef HAL_DMA2D_MODULE_ENA­BLED
300	  #include "stm32l4xx_hal_dma2d.h"
301	#endif /* HAL_DMA2D_MODULE_ENA­BLED */
302
303	#ifdef HAL_DSI_MODULE_ENABL­ED
304	  #include "stm32l4xx_hal_dsi.h"
305	#endif /* HAL_DSI_MODULE_ENABL­ED */
306
307	#ifdef HAL_EXTI_MODULE_ENAB­LED
308	  #include "stm32l4xx_hal_exti.h"
309	#endif /* HAL_EXTI_MODULE_ENAB­LED */
310
311	#ifdef HAL_GFXMMU_MODULE_EN­ABLED
312	  #include "stm32l4xx_hal_gfxmmu­.h"
313	#endif /* HAL_GFXMMU_MODULE_EN­ABLED */
314
315	#ifdef HAL_FIREWALL_MODULE_­ENABLED
316	  #include "stm32l4xx_hal_firewa­ll.h"
317	#endif /* HAL_FIREWALL_MODULE_­ENABLED */
318
319	#ifdef HAL_FLASH_MODULE_ENA­BLED
320	  #include "stm32l4xx_hal_flash.h"
321	#endif /* HAL_FLASH_MODULE_ENA­BLED */
322
323	#ifdef HAL_HASH_MODULE_ENAB­LED
324	  #include "stm32l4xx_hal_hash.h"
325	#endif /* HAL_HASH_MODULE_ENAB­LED */
326
327	#ifdef HAL_HCD_MODULE_ENABL­ED
328	  #include "stm32l4xx_hal_hcd.h"
329	#endif /* HAL_HCD_MODULE_ENABL­ED */
330
331	#ifdef HAL_I2C_MODULE_ENABL­ED
332	  #include "stm32l4xx_hal_i2c.h"
333	#endif /* HAL_I2C_MODULE_ENABL­ED */
334
335	#ifdef HAL_IRDA_MODULE_ENAB­LED
336	  #include "stm32l4xx_hal_irda.h"
337	#endif /* HAL_IRDA_MODULE_ENAB­LED */
338
339	#ifdef HAL_IWDG_MODULE_ENAB­LED
340	  #include "stm32l4xx_hal_iwdg.h"
341	#endif /* HAL_IWDG_MODULE_ENAB­LED */
342
343	#ifdef HAL_LCD_MODULE_ENABL­ED
344	  #include "stm32l4xx_hal_lcd.h"
345	#endif /* HAL_LCD_MODULE_ENABL­ED */
346
347	#ifdef HAL_LPTIM_MODULE_ENA­BLED
348	  #include "stm32l4xx_hal_lptim.h"
349	#endif /* HAL_LPTIM_MODULE_ENA­BLED */
350
351	#ifdef HAL_LTDC_MODULE_ENAB­LED
352	  #include "stm32l4xx_hal_ltdc.h"
353	#endif /* HAL_LTDC_MODULE_ENAB­LED */
354
355	#ifdef HAL_MMC_MODULE_ENABL­ED
356	  #include "stm32l4xx_hal_mmc.h"
357	#endif /* HAL_MMC_MODULE_ENABL­ED */
358
359	#ifdef HAL_NAND_MODULE_ENAB­LED
360	  #include "stm32l4xx_hal_nand.h"
361	#endif /* HAL_NAND_MODULE_ENAB­LED */
362
363	#ifdef HAL_NOR_MODULE_ENABL­ED
364	  #include "stm32l4xx_hal_nor.h"
365	#endif /* HAL_NOR_MODULE_ENABL­ED */
366
367	#ifdef HAL_OPAMP_MODULE_ENA­BLED
368	  #include "stm32l4xx_hal_opamp.h"
369	#endif /* HAL_OPAMP_MODULE_ENA­BLED */
370
371	#ifdef HAL_OSPI_MODULE_ENAB­LED
372	  #include "stm32l4xx_hal_ospi.h"
373	#endif /* HAL_OSPI_MODULE_ENAB­LED */
374
375	#ifdef HAL_PCD_MODULE_ENABL­ED
376	  #include "stm32l4xx_hal_pcd.h"
377	#endif /* HAL_PCD_MODULE_ENABL­ED */
378
379	#ifdef HAL_PWR_MODULE_ENABL­ED
380	  #include "stm32l4xx_hal_pwr.h"
381	#endif /* HAL_PWR_MODULE_ENABL­ED */
382
383	#ifdef HAL_QSPI_MODULE_ENAB­LED
384	  #include "stm32l4xx_hal_qspi.h"
385	#endif /* HAL_QSPI_MODULE_ENAB­LED */
386
387	#ifdef HAL_RNG_MODULE_ENABL­ED
388	  #include "stm32l4xx_hal_rng.h"
389	#endif /* HAL_RNG_MODULE_ENABL­ED */
390
391	#ifdef HAL_RTC_MODULE_ENABL­ED
392	  #include "stm32l4xx_hal_rtc.h"
393	#endif /* HAL_RTC_MODULE_ENABL­ED */
394
395	#ifdef HAL_SAI_MODULE_ENABL­ED
396	  #include "stm32l4xx_hal_sai.h"
397	#endif /* HAL_SAI_MODULE_ENABL­ED */
398
399	#ifdef HAL_SD_MODULE_ENABLE­D
400	  #include "stm32l4xx_hal_sd.h"
401	#endif /* HAL_SD_MODULE_ENABLE­D */
402
403	#ifdef HAL_SMARTCARD_MODULE­_ENABLED
404	  #include "stm32l4xx_hal_smartc­ard.h"
405	#endif /* HAL_SMARTCARD_MODULE­_ENABLED */
406
407	#ifdef HAL_SMBUS_MODULE_ENA­BLED
408	  #include "stm32l4xx_hal_smbus.h"
409	#endif /* HAL_SMBUS_MODULE_ENA­BLED */
410
411	#ifdef HAL_SPI_MODULE_ENABL­ED
412	  #include "stm32l4xx_hal_spi.h"
413	#endif /* HAL_SPI_MODULE_ENABL­ED */
414
415	#ifdef HAL_SRAM_MODULE_ENAB­LED
416	  #include "stm32l4xx_hal_sram.h"
417	#endif /* HAL_SRAM_MODULE_ENAB­LED */
418
419	#ifdef HAL_SWPMI_MODULE_ENA­BLED
420	  #include "stm32l4xx_hal_swpmi.h"
421	#endif /* HAL_SWPMI_MODULE_ENA­BLED */
422
423	#ifdef HAL_TIM_MODULE_ENABL­ED
424	  #include "stm32l4xx_hal_tim.h"
425	#endif /* HAL_TIM_MODULE_ENABL­ED */
426
427	#ifdef HAL_TSC_MODULE_ENABL­ED
428	  #include "stm32l4xx_hal_tsc.h"
429	#endif /* HAL_TSC_MODULE_ENABL­ED */
430
431	#ifdef HAL_UART_MODULE_ENAB­LED
432	  #include "stm32l4xx_hal_uart.h"
433	#endif /* HAL_UART_MODULE_ENAB­LED */
434
435	#ifdef HAL_USART_MODULE_ENA­BLED
436	  #include "stm32l4xx_hal_usart.h"
437	#endif /* HAL_USART_MODULE_ENA­BLED */
438
439	#ifdef HAL_WWDG_MODULE_ENAB­LED
440	  #include "stm32l4xx_hal_wwdg.h"
441	#endif /* HAL_WWDG_MODULE_ENAB­LED */
442
443	/* Exported macro ------------------------------------------------------------*/
444	#ifdef  USE_FULL_ASSERT
445	/**
446	  * @brief  The assert_param macro is used for function's parameters check.
447	  * @param  expr: If expr is false, it calls assert_failed function
448	  *         which reports the name of the source file and the source
449	  *         line number of the call that failed.
450	  *         If expr is true, it returns no value.
451	  * @retval None
452	  */
453	  #define assert_param(expr) ((expr) ? (void)0U : assert_failed((uint8_t *)__FILE__, __LINE__))
454	/* Exported functions ------------------------------------------------------- */
455	  void assert_failed(uint8_t *file, uint32_t line);
456	#else
457	  #define assert_param(expr) ((void)0U)
458	#endif /* USE_FULL_ASSERT */
459
460	#ifdef __cplusplus
461	}
462	#endif
463
464	#endif /* STM32L4xx_HAL_CONF_H­ */
465
466
L476_SBSFU\SECoreBin\Application\Core\Src\se_crypto_bootloader.c
1	/**
2	  ******************************************************************************
3	  * @file    se_crypto_bootloader­.c
4	  * @author  MCD Application Team
5	  * @brief   Secure Engine CRYPTO module.
6	  *          This file provides set of firmware functions to manage SE Crypto
7	  *          functionalities. These services are used by the bootloader.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Includes ------------------------------------------------------------------*/
22	#include <string.h>               /* added for memcpy */
23	#include "se_crypto_bootloader­.h"
24	#include "se_crypto_common.h"     /* re-use common crypto code (wrapper to cryptolib in this example)  */
25	#include "se_low_level.h"         /* required for assert_param */
26	#include "se_key.h"               /* required to access the keys when not provided as input parameter (metadata
27	                                     authentication) */
28	#if defined(__CC_ARM) || defined(__ARMCC_VERSION)
29	#include "mapping_sbsfu.h"
30	#elif defined (__ICCARM__) || defined(__GNUC__)
31	#include "mapping_export.h"
32	#endif /* __ICCARM__ || __GNUC__ */
33
34	/** @addtogroup SE Secure Engine
35	  * @{
36	  */
37
38	/** @addtogroup SE_CORE SE Core
39	  * @{
40	  */
41
42	/** @defgroup  SE_CRYPTO SE Crypto
43	  * @brief Crypto services (used by the bootloader and common crypto functions)
44	  * @{
45	  */
46
47	/** @defgroup  SE_CRYPTO_BOOTLOADER­ SE Crypto for Bootloader
48	  * @brief Crypto functions used by the bootloader.
49	  * @note In this example: \li the AES GCM crypto scheme is supported (@ref SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­),
50	  *                        \li the ECC DSA without encryption crypto scheme is supported
51	  *                        \li (@ref SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256),
52	  *                        \li the ECC DSA+AES-CBC crypto scheme is supported
53	  *                        \li (@ref SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256).
54	  * @{
55	  */
56
57	/** @defgroup SE_CRYPTO_BOOTLOADER­_Private_Variables Private Variables
58	  * @{
59	  */
60
61	#if ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­) )
62	/** @defgroup SE_CRYPTO_BOOTLOADER­_Private_Variables_S­ymmeric_Key Symmetric Key Handling
63	  *  @brief Variable(s) used to handle the symmetric key(s).
64	  *  @note All these variables must be located in protected memory.
65	  *  @{
66	  */
67
68	static uint8_t m_aSE_FirmwareKey[SE_SYMKEY_LEN];        /* Variable used to store the Key inside the protected area */
69
70
71	/**
72	  * @}
73	  */
74
75	#endif /* SECBOOT_CRYPTO_SCHEM­E */
76
77	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
78	/** @defgroup SE_CRYPTO_BOOTLOADER­_Private_Variables_A­ES_GCM AES GCM Private Variables
79	  * @Private variables used for AES GCM symmetric crypto
80	  * @{
81	  */
82	extern AESGCMctx_stt m_xSE_AESGCMCtx; /*!<Variable used to store the AES128 context */
83
84	/**
85	  * @}
86	  */
87
88	#endif /* SECBOOT_CRYPTO_SCHEM­E */
89
90	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256)
91	/** @defgroup SE_CRYPTO_BOOTLOADER­_Private_Variables_A­ES_CBC AES CBC variables
92	  *  @brief  Advanced Encryption Standard (AES), CBC (Cipher-Block Chaining) with support for Ciphertext Stealing
93	  *  @note   We do not use local variable(s) because we want this to be in the protected area (and the stack is not
94	  protected),
95	  *          and also because the contexts are used to store internal states.
96	  *  @{
97	  */
98	static AESCBCctx_stt m_AESCBCctx; /*!<Variable used to store the AES CBC context */
99	/**
100	  * @}
101	  */
102	#endif /* SECBOOT_CRYPTO_SCHEM­E */
103
104	#if ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256) )
105	/** @defgroup SE_CRYPTO_BOOTLOADER­_Private_Variables_S­HA256 SHA256 variables
106	  *  @brief  Secure Hash Algorithm SHA-256.
107	  *  @note   We do not use local variable(s) because the context is used to store internal states.
108	  *  @{
109	  */
110	static SHA256ctx_stt m_SHA256ctx; /*!< Variable used to store the SHA256 context (this one does not really need to be
111	                                       protected as it is a HASH) */
112
113	/**
114	  * @}
115	  */
116	#endif /* SECBOOT_CRYPTO_SCHEM­E */
117
118
119
120	/**
121	  * @}
122	  */
123
124	/** @defgroup SE_CRYPTO_BOOTLOADER­_Private_Macros Private Macros
125	  * @{
126	  */
127
128
129	/**
130	  * @brief Clean up the RAM area storing the Firmware key.
131	  *        This applies only to the secret symmetric key loaded with SE_ReadKey_x().
132	  */
133	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256)
134	#define SE_CLEAN_UP_FW_KEY() \
135	  do { \
136	    (void)memcpy(m_aSE_FirmwareKey, (void const *)(SE_STARTUP_REGION_RO­M_START + (SysTick->VAL % 0xFFFU)), \
137	                 sizeof(m_aSE_FirmwareKey)); \
138	    (void)memcpy((void *)&m_AESCBCctx, (void const *)(SE_STARTUP_REGION_RO­M_START + (SysTick->VAL % 0xFFFU)), \
139	                 sizeof(m_AESCBCctx)); \
140	  } while(0)
141
142	#elif (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
143
144	#define SE_CLEAN_UP_FW_KEY() \
145	  do { \
146	    (void)memcpy(m_aSE_FirmwareKey, (void const *)(SE_STARTUP_REGION_RO­M_START + (SysTick->VAL % 0xFFFU)), \
147	                 sizeof(m_aSE_FirmwareKey)); \
148	    (void)memcpy((void *)&m_xSE_AESGCMCtx, (void const *)(SE_STARTUP_REGION_RO­M_START + (SysTick->VAL % 0xFFFU)), \
149	                 sizeof(m_xSE_AESGCMCtx)); \
150	  } while(0)
151
152	#else
153
154	#define SE_CLEAN_UP_FW_KEY() do { /* do nothing */; } while(0)
155
156	#endif /* SECBOOT_CRYPTO_SCHEM­E */
157
158	/**
159	  * @brief Clean up the RAM area storing the ECC Public Key.
160	  *        This applies only to the public asymmetric key loaded with SE_ReadKey_Pub().
161	  */
162	#if ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256) )
163
164	#define SE_CLEAN_UP_PUB_KEY() \
165	  do { \
166	    (void)memcpy(m_aSE_PubKey, (void const *)(SE_STARTUP_REGION_RO­M_START + (SysTick->VAL % 0xFFFU)), \
167	                 sizeof(m_aSE_PubKey)); \
168	    (void)memcpy((void *)&m_SHA256ctx, (void const *)(SE_STARTUP_REGION_RO­M_START + (SysTick->VAL % 0xFFFU)), \
169	                 sizeof(m_SHA256ctx)); \
170	  } while(0)
171
172	#else
173
174	#define SE_CLEAN_UP_PUB_KEY() do { /* do nothing */; } while(0)
175
176	#endif /* SECBOOT_CRYPTO_SCHEM­E */
177
178	/**
179	  * @}
180	  */
181
182	/** @defgroup SE_CRYPTO_BOOTLOADER­_Private_Functions Private Functions
183	  *  @brief These are private functions used internally by the crypto services provided to the bootloader
184	  *         i.e. the exported functions implemented in this file (@ref SE_CRYPTO_BOOTLOADER­_Exported_Functions).
185	  *  @note  These functions are not part of the common crypto code because they are used by the bootloader services
186	  *         only.
187	  * @{
188	  */
189
190	/** @defgroup SE_CRYPTO_BOOTLOADER­_Private_Functions_A­ES AES Functions
191	  *  @brief Helpers for AES: high level wrappers for the Cryptolib.
192	  *  @note This group of functions is empty because we do not provide high level wrappers for AES.
193	  * @{
194	  */
195
196	/* no high level wrappers provided for AES primitives: the Cryptolib APIs are called directly from  the services
197	  (@ref SE_CRYPTO_BOOTLOADER­_Exported_Functions) */
198
199	/**
200	  * @}
201	  */
202
203	/** @defgroup SE_CRYPTO_BOOTLOADER­_Private_Functions_R­eadkey Readkey Functions
204	  *  @brief Read the relevant AES symmetric key.
205	  * @{
206	  */
207
208	#if ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­) )
209	/**
210	  * @brief  AES readkey function.
211	  * @param  pxSE_Metadata: Firmware metadata.
212	  * @retval none
213	  */
214	static void SE_CRYPTO_AES_ReadKe­y(SE_FwRawHeaderTypeDe­f *pxSE_Metadata)
215	{
216	  /* Read the AES Symmetric Key :
217	     - SFU1 / SE_ReadKey_1() ==> read key for SLOT_ACTIVE_1
218	     - SFU2 / SE_ReadKey_2() ==> read key for SLOT_ACTIVE_2
219	     - SFU3 / SE_ReadKey_3() ==> read key for SLOT_ACTIVE_3 */
220	  if (memcmp(pxSE_Metadata->SFUMagic, SFUM_1, strlen(SFUM_1)) == 0)
221	  {
222	    SE_ReadKey_1(&(m_aSE_FirmwareKey[0]));
223	  }
224	#if (SFU_NB_MAX_ACTIVE_IM­AGE > 1U)
225	  else if (memcmp(pxSE_Metadata->SFUMagic, SFUM_2, strlen(SFUM_2)) == 0)
226	  {
227	    SE_ReadKey_2(&(m_aSE_FirmwareKey[0]));
228	  }
229	#endif  /* (NB_FW_IMAGES > 1) */
230	#if (SFU_NB_MAX_ACTIVE_IM­AGE > 2U)
231	  else if (memcmp(pxSE_Metadata->SFUMagic, SFUM_3, strlen(SFUM_3)) == 0)
232	  {
233	    SE_ReadKey_3(&(m_aSE_FirmwareKey[0]));
234	  }
235	#endif  /* (NB_FW_IMAGES > 2) */
236	  else
237	  {
238	    /* nothing to do */
239	    ;
240	  }
241	}
242	#endif /* SECBOOT_CRYPTO_SCHEM­E */
243
244
245	#if ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256) )
246	/**
247	  * @brief  Read public key function.
248	  * @param  pxSE_Metadata: Firmware metadata.
249	  * @retval none
250	  */
251	static void SE_CRYPTO_ReadKey_Pu­b(SE_FwRawHeaderTypeDe­f *pxSE_Metadata, uint8_t *paSE_PubKey)
252	{
253	  /* Read the AES Symmetric Key :
254	     - SFU1 / SE_ReadKey_1() ==> read key for SLOT_ACTIVE_1
255	     - SFU2 / SE_ReadKey_2() ==> read key for SLOT_ACTIVE_2
256	     - SFU3 / SE_ReadKey_3() ==> read key for SLOT_ACTIVE_3 */
257	  if (memcmp(pxSE_Metadata->SFUMagic, SFUM_1, strlen(SFUM_1)) == 0)
258	  {
259	    SE_ReadKey_1_Pub(paSE_PubKey);
260	  }
261	#if (SFU_NB_MAX_ACTIVE_IM­AGE > 1U)
262	  else if (memcmp(pxSE_Metadata->SFUMagic, SFUM_2, strlen(SFUM_2)) == 0)
263	  {
264	    SE_ReadKey_2_Pub(paSE_PubKey);
265	  }
266	#endif  /* (NB_FW_IMAGES > 1) */
267	#if (SFU_NB_MAX_ACTIVE_IM­AGE > 2U)
268	  else if (memcmp(pxSE_Metadata->SFUMagic, SFUM_3, strlen(SFUM_3)) == 0)
269	  {
270	    SE_ReadKey_3_Pub(paSE_PubKey);
271	  }
272	#endif  /* (NB_FW_IMAGES > 2) */
273	  else
274	  {
275	    /* nothing to do */
276	    ;
277	  }
278	}
279	#endif /* SECBOOT_CRYPTO_SCHEM­E */
280
281	/**
282	  * @}
283	  */
284
285	/** @defgroup SE_CRYPTO_BOOTLOADER­_Private_Functions_H­ASH Hash Functions
286	  *  @brief Hash algorithm(s): high level wrapper(s) for the Cryptolib.
287	  * @{
288	  */
289
290
291	#if ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256) )
292	/**
293	  * @brief  SHA256 HASH digest compute example.
294	  * @param  InputMessage: pointer to input message to be hashed.
295	  * @param  InputMessageLength: input data message length in byte.
296	  * @param  MessageDigest: pointer to output parameter that will handle message digest
297	  * @param  MessageDigestLength: pointer to output digest length.
298	  * @retval error status: can be HASH_SUCCESS if success or one of
299	  *         HASH_ERR_BAD_PARAMET­ER, HASH_ERR_BAD_CONTEXT­,
300	  *         HASH_ERR_BAD_OPERATI­ON if an error occurred.
301	  */
302	static int32_t SE_CRYPTO_SHA256_HAS­H_DigestCompute(const uint8_t *InputMessage, const int32_t InputMessageLength,
303	                                                   uint8_t *MessageDigest, int32_t *MessageDigestLength)
304	{
305	  SHA256ctx_stt P_pSHA256ctx;
306	  int32_t error_status;
307
308	  /* Set the size of the desired hash digest */
309	  P_pSHA256ctx.mTagSize = CRL_SHA256_SIZE;
310
311	  /* Set flag field to default value */
312	  P_pSHA256ctx.mFlags = E_HASH_DEFAULT;
313
314	  error_status = SHA256_Init(&P_pSHA256ctx);
315
316	  /* check for initialization errors */
317	  if (error_status == HASH_SUCCESS)
318	  {
319	    /* Add data to be hashed */
320	    error_status = SHA256_Append(&P_pSHA256ctx,
321	                                 InputMessage,
322	                                 InputMessageLength);
323
324	    if (error_status == HASH_SUCCESS)
325	    {
326	      /* retrieve */
327	      error_status = SHA256_Finish(&P_pSHA256ctx, MessageDigest, MessageDigestLength);
328	    }
329	  }
330
331	  return error_status;
332	}
333
334
335	#endif /* SECBOOT_CRYPTO_SCHEM­E */
336
337	/**
338	  * @}
339	  */
340	/**
341	  * @}
342	  */
343
344
345	/** @defgroup SE_CRYPTO_BOOTLOADER­_Exported_Functions Exported Functions
346	  * @brief The implementation of these functions is crypto-dependent (but the API is crypto-agnostic).
347	  *        These functions use the generic SE_FwRawHeaderTypeDe­f structure to fill crypto specific structures.
348	  * @{
349	  */
350
351	/**
352	  * @brief Secure Engine Encrypt Init function.
353	  *        It is a wrapper of the Cryptolib Encrypt_Init function included in the protected area.
354	  * @param pxSE_Metadata: Firmware metadata.
355	  * @param SE_FwType: Type of Fw Image.
356	  *        This parameter can be SE_FW_IMAGE_COMPLETE­ or SE_FW_IMAGE_PARTIAL.
357	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
358	  */
359	SE_ErrorStatus SE_CRYPTO_Encrypt_In­it(SE_FwRawHeaderTypeDe­f *pxSE_Metadata, uint32_t SE_FwType)
360	{
361	  SE_ErrorStatus e_ret_status;
362
363	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
364	  SE_GCMInitTypeDef se_gcm_init;
365	  /* Variables to handle FW image */
366	  uint32_t fw_size;
367	  uint8_t *fw_tag;
368	#elif ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256) )
369	  /* The bootloader does not need the encrypt service in this crypto scheme: reject this request later on */
370	#else
371	#error "The current example does not support the selected crypto scheme."
372	#endif /* SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­ */
373
374	  /* Check the pointers allocation */
375	  if (pxSE_Metadata == NULL)
376	  {
377	    return SE_ERROR;
378	  }
379
380	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
381	  /* Check the parameters value and set fw_size and fw_tag to check */
382	  if (SE_FwType == SE_FW_IMAGE_COMPLETE­)
383	  {
384	    fw_size = pxSE_Metadata->FwSize;
385	    fw_tag = pxSE_Metadata->FwTag;
386	  }
387	  else if (SE_FwType == SE_FW_IMAGE_PARTIAL)
388	  {
389	    fw_size = pxSE_Metadata->PartialFwSize;
390	    fw_tag = pxSE_Metadata->PartialFwTag;
391	  }
392	  else
393	  {
394	    return SE_ERROR;
395	  }
396
397	  /* Read the Symmetric Key */
398	  SE_CRYPTO_AES_ReadKe­y(pxSE_Metadata);
399
400	  /* Prepare a local structure with appropriate types (this step could be skipped) */
401	  se_gcm_init.HeaderSize = 0;
402	  se_gcm_init.PayloadSize = (int32_t)fw_size;
403	  se_gcm_init.pNonce = (uint8_t *)pxSE_Metadata->Nonce;
404	  se_gcm_init.NonceSize = SE_NONCE_LEN;
405	  se_gcm_init.pTag = (uint8_t *)fw_tag;
406	  se_gcm_init.TagSize = (int32_t)SE_TAG_LEN;
407
408
409	  /* Check the pointers allocation */
410	  if ((se_gcm_init.pNonce == NULL) || (se_gcm_init.pTag == NULL))
411	  {
412	    return SE_ERROR;
413	  }
414
415	  /* Check the parameters */
416	  assert_param(IS_SE_CRYPTO_AES_GCM­_NONCE_SIZE(se_gcm_init.NonceSize));
417	  assert_param(IS_SE_CRYPTO_AES_GCM­_TAG_SIZE(se_gcm_init.TagSize));
418
419	  /* Common Crypto function call*/
420	  e_ret_status = SE_CRYPTO_AES_GCM_En­crypt_Init(m_aSE_FirmwareKey, &se_gcm_init);
421
422
423	#elif ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256) )
424
425	  /* The bootloader does not need the encrypt service in this crypto scheme: reject this request */
426	  /* Prevent unused argument(s) compilation warning */
427	  UNUSED(SE_FwType);
428	  e_ret_status = SE_ERROR;
429	#else
430	#error "The current example does not support the selected crypto scheme."
431	#endif /* SECBOOT_CRYPTO_SCHEM­E */
432
433	  /* Return status*/
434	  return e_ret_status;
435	}
436
437	/**
438	  * @brief Secure Engine Header Append function.
439	  *        It is a wrapper of the Cryptolib Header_Append function included in the protected area.
440	  * @param pInputBuffer: pointer to Input Buffer.
441	  * @param InputSize: Input Size (bytes).
442	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
443	  */
444	SE_ErrorStatus SE_CRYPTO_Header_App­end(const uint8_t *pInputBuffer, int32_t InputSize)
445	{
446	  SE_ErrorStatus e_ret_status;
447
448	  /* Check the pointers allocation */
449	  if (pInputBuffer == NULL)
450	  {
451	    return SE_ERROR;
452	  }
453
454	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
455	  /* Common Crypto function call*/
456	  e_ret_status = SE_CRYPTO_AES_GCM_He­ader_Append(pInputBuffer, InputSize);
457	#elif ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256) )
458	  /* The bootloader does not need this service in this crypto scheme: reject this request */
459	  e_ret_status = SE_ERROR;
460
461	  /* Prevent unused argument(s) compilation warning */
462	  UNUSED(InputSize);
463	#else
464	#error "The current example does not support the selected crypto scheme."
465	#endif /* SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­ */
466	  /* Return status*/
467	  return e_ret_status;
468	} /* SECBOOT_CRYPTO_SCHEM­E */
469
470	/**
471	  * @brief Secure Engine Encrypt Append function.
472	  *        It is a wrapper of the Cryptolib Encrypt_Append function included in the protected area.
473	  * @param pInputBuffer: pointer to Input Buffer.
474	  * @param InputSize: Input Size (bytes).
475	  * @param pOutputBuffer: pointer to Output Buffer.
476	  * @param pOutputSize: pointer to Output Size (bytes).
477	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
478	  */
479	SE_ErrorStatus SE_CRYPTO_Encrypt_Ap­pend(const uint8_t *pInputBuffer, int32_t InputSize, uint8_t *pOutputBuffer,
480	                                        int32_t *pOutputSize)
481	{
482	  SE_ErrorStatus e_ret_status;
483
484	  /* Check the pointers allocation */
485	  if ((pInputBuffer == NULL) || (pOutputBuffer == NULL) || (pOutputSize == NULL))
486	  {
487	    return SE_ERROR;
488	  }
489
490	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
491
492	  /* Common Crypto function call*/
493	  e_ret_status = SE_CRYPTO_AES_GCM_En­crypt_Append(pInputBuffer, InputSize, pOutputBuffer, pOutputSize);
494
495	#elif ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256) )
496	  /* The bootloader does not need the encrypt service in this crypto scheme: reject this request */
497	  e_ret_status = SE_ERROR;
498
499	  /* Prevent unused argument(s) compilation warning */
500	  UNUSED(InputSize);
501	#else
502	#error "The current example does not support the selected crypto scheme."
503	#endif /* SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­ */
504
505	  /* Return status*/
506	  return e_ret_status;
507	} /* SECBOOT_CRYPTO_SCHEM­E */
508
509	/**
510	  * @brief Secure Engine Encrypt Finish function.
511	  *        It is a wrapper of the Cryptolib Encrypt_Finish function included in the protected area.
512	  * @param pOutputBuffer: pointer to Output Buffer.
513	  * @param pOutputSize: pointer to Output Size (bytes).
514	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
515	  */
516	SE_ErrorStatus SE_CRYPTO_Encrypt_Fi­nish(uint8_t *pOutputBuffer, int32_t *pOutputSize)
517	{
518	  SE_ErrorStatus e_ret_status;
519
520	  /* Check the pointers allocation */
521	  if ((pOutputBuffer == NULL) || (pOutputSize == NULL))
522	  {
523	    /* Clean-up the key in RAM */
524	    SE_CLEAN_UP_FW_KEY();
525
526	    return SE_ERROR;
527	  }
528
529	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
530
531	  /* Common Crypto function call*/
532	  e_ret_status = SE_CRYPTO_AES_GCM_En­crypt_Finish(pOutputBuffer, pOutputSize);
533
534	#elif ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256) )
535	  /* The bootloader does not need the encrypt service in this crypto scheme: reject this request */
536	  e_ret_status = SE_ERROR;
537	#else
538	#error "The current example does not support the selected crypto scheme."
539	#endif /* SECBOOT_CRYPTO_SCHEM­E */
540
541	  /* Clean-up the key in RAM */
542	  SE_CLEAN_UP_FW_KEY();
543
544	  /* Return status*/
545	  return e_ret_status;
546	}
547
548	/**
549	  * @brief Secure Engine Decrypt Init function.
550	  *        It is a wrapper of the Cryptolib Decrypt_Init function included in the protected area.
551	  * @param pxSE_Metadata: Firmware metadata.
552	  * @param SE_FwType: Type of Fw Image.
553	  *        This parameter can be SE_FW_IMAGE_COMPLETE­ or SE_FW_IMAGE_PARTIAL.
554	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
555	  */
556	SE_ErrorStatus SE_CRYPTO_Decrypt_In­it(SE_FwRawHeaderTypeDe­f *pxSE_Metadata, uint32_t SE_FwType)
557	{
558	  SE_ErrorStatus e_ret_status;
559
560	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
561	  /* Variables to handle partial/complete FW image */
562	  uint32_t fw_size;
563	  uint8_t *fw_tag;
564	  SE_GCMInitTypeDef se_gcm_init;
565	#elif (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256)
566	  /*
567	   * No need for a local struct like se_gcm_init because we do not rely on the SE common crypto code (as AES CBC is not
568	   * available for the UserApp).
569	   * We call directly the Cryptolib.
570	   */
571	  int32_t cryptolib_status;
572	#elif  SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256
573	  /*
574	   * In this crypto scheme the Firmware is not encrypted or does not need to be decrypted.
575	   * The Decrypt operation is called anyhow before installing the firmware.
576	   * Indeed, it allows moving the Firmware image blocks in FLASH.
577	   * These moves are mandatory to create the appropriate mapping in FLASH
578	   * allowing the swap procedure to run without using the swap area at each and every move.
579	   *
580	   * See in SB_SFU project: @ref SFU_IMG_PrepareCandi­dateImageForInstall.
581	   */
582	#else
583	#error "The current example does not support the selected crypto scheme."
584	#endif /* SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­ */
585
586	  /* Check the pointers allocation */
587	  if (pxSE_Metadata == NULL)
588	  {
589	    return SE_ERROR;
590	  }
591
592	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
593	  /* Check the parameters value and set fw_size and fw_tag to check */
594	  if (SE_FwType == SE_FW_IMAGE_COMPLETE­)
595	  {
596	    fw_size = pxSE_Metadata->FwSize;
597	    fw_tag = pxSE_Metadata->FwTag;
598	  }
599	  else if (SE_FwType == SE_FW_IMAGE_PARTIAL)
600	  {
601	    fw_size = pxSE_Metadata->PartialFwSize;
602	    fw_tag = pxSE_Metadata->PartialFwTag;
603	  }
604	  else
605	  {
606	    return SE_ERROR;
607	  }
608
609	  /* Read the Symmetric Key */
610	  SE_CRYPTO_AES_ReadKe­y(pxSE_Metadata);
611
612	  /*
613	   * Please note that the init below is hard-coded to consider that there is NO additional data.
614	   */
615	  se_gcm_init.HeaderSize = 0; /* no Additional authenticated data considered */
616	  se_gcm_init.PayloadSize = (int32_t)fw_size;
617	  se_gcm_init.pNonce = (uint8_t *)pxSE_Metadata->Nonce;
618	  se_gcm_init.NonceSize = SE_NONCE_LEN;
619	  se_gcm_init.pTag = (uint8_t *)fw_tag;
620	  se_gcm_init.TagSize = (int32_t)SE_TAG_LEN;
621
622	  /* Check the pointers allocation */
623	  if ((se_gcm_init.pNonce == NULL) || (se_gcm_init.pTag == NULL))
624	  {
625	    return SE_ERROR;
626	  }
627
628	  /* Check the parameters */
629	  assert_param(IS_SE_CRYPTO_AES_GCM­_NONCE_SIZE(se_gcm_init.NonceSize));
630	  assert_param(IS_SE_CRYPTO_AES_GCM­_TAG_SIZE(se_gcm_init.TagSize));
631
632	  /* Common Crypto function call*/
633	  e_ret_status = SE_CRYPTO_AES_GCM_De­crypt_Init(m_aSE_FirmwareKey, &se_gcm_init);
634
635
636	#elif (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256)
637	  /* Prevent unused argument(s) compilation warning */
638	  UNUSED(SE_FwType);
639	  /* Read the Symmetric Key */
640	  SE_CRYPTO_AES_ReadKe­y(pxSE_Metadata);
641
642	  /* Set flag field to default value */
643	  m_AESCBCctx.mFlags = E_SK_DEFAULT;
644
645	  /* Set key size to 16 (corresponding to AES-128) */
646	  m_AESCBCctx.mKeySize = (int32_t) SE_SYMKEY_LEN;
647
648	  /* Set iv size field to IvLength*/
649	  m_AESCBCctx.mIvSize = (int32_t) SE_IV_LEN;
650
651	  /* Initialize the operation, by passing the key and IV */
652	  cryptolib_status = AES_CBC_Decrypt_Init­(&m_AESCBCctx, m_aSE_FirmwareKey, pxSE_Metadata->InitVector);
653
654	  /* map the return code */
655	  if (AES_SUCCESS == cryptolib_status)
656	  {
657	    e_ret_status = SE_SUCCESS;
658	  }
659	  else
660	  {
661	    e_ret_status = SE_ERROR;
662	  }
663
664	#elif  SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256
665	  /* Nothing to do as we won't decrypt anything */
666	  /* Prevent unused argument(s) compilation warning */
667	  UNUSED(SE_FwType);
668	  e_ret_status = SE_SUCCESS;
669	#else
670	#error "The current example does not support the selected crypto scheme."
671	#endif /* SECBOOT_CRYPTO_SCHEM­E */
672
673	  /* Return status*/
674	  return e_ret_status;
675	}
676
677	/**
678	  * @brief Secure Engine Decrypt Append function.
679	  *        It is a wrapper of the Cryptolib Decrypt_Append function included in the protected area.
680	  * @param pInputBuffer: pointer to Input Buffer.
681	  * @param InputSize: Input Size (bytes).
682	  * @param pOutputBuffer: pointer to Output Buffer.
683	  * @param pOutputSize: pointer to Output Size (bytes).
684	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
685	  */
686	SE_ErrorStatus SE_CRYPTO_Decrypt_Ap­pend(const uint8_t *pInputBuffer, int32_t InputSize, uint8_t *pOutputBuffer,
687	                                        int32_t *pOutputSize)
688	{
689	  SE_ErrorStatus e_ret_status;
690	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256)
691	  int32_t cryptolib_status;
692	#endif /* SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256 */
693
694	  /* DecryptImageInDwlSlo­t() always starts by calling the Decrypt service with a 0 byte buffer */
695	  if (0 == InputSize)
696	  {
697	    /* Nothing to do but we must return a success for the decrypt operation to continue */
698	    return (SE_SUCCESS);
699	  }
700
701	  /* Check the pointers allocation */
702	  if ((pInputBuffer == NULL) || (pOutputBuffer == NULL) || (pOutputSize == NULL))
703	  {
704	    return SE_ERROR;
705	  }
706
707	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
708	  /* Crypto function call*/
709	  e_ret_status = SE_CRYPTO_AES_GCM_De­crypt_Append(pInputBuffer, InputSize, pOutputBuffer, pOutputSize);
710
711	#elif (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256)
712	  /* Crypto function call */
713	  cryptolib_status = AES_CBC_Decrypt_Appe­nd(&m_AESCBCctx, pInputBuffer, InputSize, pOutputBuffer, pOutputSize);
714
715	  /* map the return code */
716	  if (AES_SUCCESS == cryptolib_status)
717	  {
718	    e_ret_status = SE_SUCCESS;
719	  }
720	  else
721	  {
722	    e_ret_status = SE_ERROR;
723	  }
724
725	#elif  SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256
726	  /*
727	   * The firmware is not encrypted or does not need to be decrypted.
728	   * The only thing we need to do is to recopy the input buffer in the output buffer
729	   */
730	  (void)memcpy(pOutputBuffer, pInputBuffer, (uint32_t)InputSize);
731	  *pOutputSize = InputSize;
732	  e_ret_status = SE_SUCCESS;
733	#else
734	#error "The current example does not support the selected crypto scheme."
735	#endif /* SECBOOT_CRYPTO_SCHEM­E */
736
737	  /* Return status*/
738	  return e_ret_status;
739	}
740
741	/**
742	  * @brief Secure Engine Decrypt Finish function.
743	  *        It is a wrapper of the Cryptolib Decrypt_Finish function included in the protected area.
744	  *        This parameter can be a value of @ref SE_Status_Structure_­definition.
745	  * @param pOutputBuffer: pointer to Output Buffer.
746	  * @param pOutputSize: pointer to Output Size (bytes).
747	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
748	  */
749	SE_ErrorStatus SE_CRYPTO_Decrypt_Fi­nish(uint8_t *pOutputBuffer, int32_t *pOutputSize)
750	{
751	  SE_ErrorStatus e_ret_status = SE_ERROR;
752	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256)
753	  int32_t cryptolib_status;
754	#elif (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
755	#endif /* SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256 */
756
757	  /* Check the pointers allocation */
758	  if ((pOutputBuffer == NULL) || (pOutputSize == NULL))
759	  {
760	    /* Clean-up the key in RAM */
761	    SE_CLEAN_UP_FW_KEY();
762
763	    return e_ret_status;
764	  }
765
766	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
767
768	  /* Crypto function call*/
769	  e_ret_status = SE_CRYPTO_AES_GCM_De­crypt_Finish(pOutputBuffer, pOutputSize);
770
771	#elif (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256)
772	  /* Crypto function call */
773	  cryptolib_status = AES_CBC_Decrypt_Fini­sh(&m_AESCBCctx, pOutputBuffer, pOutputSize);
774
775	  /* map the return code */
776	  if (AES_SUCCESS == cryptolib_status)
777	  {
778	    e_ret_status = SE_SUCCESS;
779	  }
780	  else
781	  {
782	    e_ret_status = SE_ERROR;
783	  }
784	#elif  SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256
785	  /* Nothing to do */
786	  e_ret_status = SE_SUCCESS;
787	#else
788	#error "The current example does not support the selected crypto scheme."
789	#endif /* SECBOOT_CRYPTO_SCHEM­E */
790
791	  /* Clean-up the key in RAM */
792	  SE_CLEAN_UP_FW_KEY();
793
794	  /* Return status*/
795	  return e_ret_status;
796	}
797
798
799	/**
800	  * @brief Secure Engine AuthenticateFW Init function.
801	  *        It is a wrapper of the Cryptolib function included in the protected area used to initialize the FW
802	  *        authentication procedure.
803	  * @param pKey: pointer to the key.
804	  * @param pxSE_Metadata: Firmware metadata.
805	  * @param SE_FwType: Type of Fw Image.
806	  *        This parameter can be SE_FW_IMAGE_COMPLETE­ or SE_FW_IMAGE_PARTIAL.
807	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
808	  */
809	SE_ErrorStatus SE_CRYPTO_Authentica­teFW_Init(SE_FwRawHeaderTypeDe­f *pxSE_Metadata, uint32_t SE_FwType)
810	{
811	  SE_ErrorStatus e_ret_status;
812
813	  /*
814	   * Depending on the crypto scheme, the Firmware Tag (signature) can be:
815	   *   - either an AES GCM tag
816	   *   - or a SHA256 digest (encapsulated in the authenticated FW metadata)
817	   */
818	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
819	  e_ret_status = SE_CRYPTO_Encrypt_In­it(pxSE_Metadata, SE_FwType);
820	#elif ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256) )
821	  int32_t error_status;
822
823	  /* Prevent unused argument(s) compilation warning */
824	  UNUSED(pxSE_Metadata);
825	  UNUSED(SE_FwType);
826
827	  /* Set the size of the desired hash digest: SHA-256 */
828	  m_SHA256ctx.mTagSize = CRL_SHA256_SIZE;
829
830	  /* Set flag field to default value */
831	  m_SHA256ctx.mFlags = E_HASH_DEFAULT;
832
833	  /* Initialize the HASH context */
834	  error_status = SHA256_Init(&m_SHA256ctx);
835
836	  if (HASH_SUCCESS == error_status)
837	  {
838	    e_ret_status = SE_SUCCESS;
839	  }
840	  else
841	  {
842	    e_ret_status = SE_ERROR;
843	  }
844	#else
845	#error "The current example does not support the selected crypto scheme."
846	#endif /* SECBOOT_CRYPTO_SCHEM­E */
847
848	  /* Return status*/
849	  return e_ret_status;
850	}
851
852	/**
853	  * @brief Secure Engine AuthenticateFW Append function.
854	  *        It is a wrapper of the Cryptolib Append function included in the protected area used during the FW
855	  *        authentication procedure.
856	  * @param pInputBuffer: pointer to Input Buffer.
857	  * @param InputSize: Input Size (bytes).
858	  * @param pOutputBuffer: pointer to Output Buffer.
859	  * @param pOutputSize: pointer to Output Size (bytes).
860	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
861	  */
862	SE_ErrorStatus SE_CRYPTO_Authentica­teFW_Append(const uint8_t *pInputBuffer, int32_t InputSize, uint8_t *pOutputBuffer,
863	                                               int32_t *pOutputSize)
864	{
865	  SE_ErrorStatus e_ret_status;
866	  /*
867	   * Depending on the crypto scheme, the Firmware Tag (signature) can be:
868	   *   - either an AES GCM tag
869	   *   - or a SHA256 digest
870	   */
871	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
872	  e_ret_status = SE_CRYPTO_Encrypt_Ap­pend(pInputBuffer, InputSize, pOutputBuffer, pOutputSize);
873	#elif ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256) )
874	  int32_t error_status;
875
876	  /* The parameters below are useless for the HASH but are needed for API compatibility with other procedures */
877	  (void)pOutputBuffer;
878	  (void)pOutputSize;
879
880	  /* Add data to be hashed */
881	  error_status = SHA256_Append(&m_SHA256ctx, pInputBuffer, InputSize);
882
883	  if (HASH_SUCCESS == error_status)
884	  {
885	    e_ret_status = SE_SUCCESS;
886	  }
887	  else
888	  {
889	    e_ret_status = SE_ERROR;
890	  }
891	#else
892	#error "The current example does not support the selected crypto scheme."
893	#endif /* SECBOOT_CRYPTO_SCHEM­E */
894
895	  /* Return status*/
896	  return e_ret_status;
897	}
898
899	/**
900	  * @brief Secure Engine AuthenticateFW Finish function.
901	  *        It is a wrapper of the Cryptolib Encrypt_Finish function included in the protected area used during the FW
902	  *        authentication procedure..
903	  * @param pOutputBuffer: pointer to Output Buffer.
904	  * @param pOutputSize: pointer to Output Size (bytes).
905	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
906	  */
907	SE_ErrorStatus SE_CRYPTO_Authentica­teFW_Finish(uint8_t *pOutputBuffer, int32_t *pOutputSize)
908	{
909	  SE_ErrorStatus e_ret_status;
910	  /*
911	   * Depending on the crypto scheme, the Firmware Tag (signature) can be:
912	   *   - either an AES GCM tag
913	   *   - or a SHA256 digest
914	   */
915	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
916	  e_ret_status = SE_CRYPTO_Encrypt_Fi­nish(pOutputBuffer, pOutputSize);
917	#elif ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256) )
918	  int32_t error_status;
919
920	  /* Add data to be hashed */
921	  error_status = SHA256_Finish(&m_SHA256ctx, pOutputBuffer, pOutputSize);
922
923	  if (HASH_SUCCESS == error_status)
924	  {
925	    e_ret_status = SE_SUCCESS;
926	  }
927	  else
928	  {
929	    e_ret_status = SE_ERROR;
930	  }
931	#else
932	#error "The current example does not support the selected crypto scheme."
933	#endif /* SECBOOT_CRYPTO_SCHEM­E */
934
935	  /* Return status*/
936	  return e_ret_status;
937	}
938
939	/**
940	  * @brief Secure Engine Authenticate Metadata function.
941	  *        Authenticates the header containing the Firmware metadata.
942	  * @param pxSE_Metadata: Firmware metadata.
943	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
944	  */
945	SE_ErrorStatus SE_CRYPTO_Authentica­te_Metadata(SE_FwRawHeaderTypeDe­f *pxSE_Metadata)
946	{
947	  SE_ErrorStatus e_ret_status = SE_ERROR;
948
949	  /*
950	   * Module variables for crypto key handling.
951	   */
952	#if ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256) )
953
954	  /******************************************************************************/
955	  /******** Parameters for Elliptic Curve P-256 SHA-256 from FIPS 186-3**********/
956	  /******************************************************************************/
957	  static const uint8_t P_256_a[] __attribute__((aligned(4))) =
958	  {
959	    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
960	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
961	    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC
962	  };
963	  static const uint8_t P_256_b[] __attribute__((aligned(4))) =
964	  {
965	    0x5a, 0xc6, 0x35, 0xd8, 0xaa, 0x3a, 0x93, 0xe7, 0xb3, 0xeb, 0xbd, 0x55, 0x76,
966	    0x98, 0x86, 0xbc, 0x65, 0x1d, 0x06, 0xb0, 0xcc, 0x53, 0xb0, 0xf6, 0x3b, 0xce,
967	    0x3c, 0x3e, 0x27, 0xd2, 0x60, 0x4b
968	  };
969	  static const uint8_t P_256_p[] __attribute__((aligned(4))) =
970	  {
971	    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
972	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
973	    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
974	  };
975	  static const uint8_t P_256_n[] __attribute__((aligned(4))) =
976	  {
977	    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
978	    0xFF, 0xFF, 0xFF, 0xBC, 0xE6, 0xFA, 0xAD, 0xA7, 0x17, 0x9E, 0x84, 0xF3, 0xB9,
979	    0xCA, 0xC2, 0xFC, 0x63, 0x25, 0x51
980	  };
981	  static const uint8_t P_256_Gx[] __attribute__((aligned(4))) =
982	  {
983	    0x6B, 0x17, 0xD1, 0xF2, 0xE1, 0x2C, 0x42, 0x47, 0xF8, 0xBC, 0xE6, 0xE5, 0x63,
984	    0xA4, 0x40, 0xF2, 0x77, 0x03, 0x7D, 0x81, 0x2D, 0xEB, 0x33, 0xA0, 0xF4, 0xA1,
985	    0x39, 0x45, 0xD8, 0x98, 0xC2, 0x96
986	  };
987	  static const uint8_t P_256_Gy[] __attribute__((aligned(4))) =
988	  {
989	    0x4F, 0xE3, 0x42, 0xE2, 0xFE, 0x1A, 0x7F, 0x9B, 0x8E, 0xE7, 0xEB, 0x4A, 0x7C,
990	    0x0F, 0x9E, 0x16, 0x2B, 0xCE, 0x33, 0x57, 0x6B, 0x31, 0x5E, 0xCE, 0xCB, 0xB6,
991	    0x40, 0x68, 0x37, 0xBF, 0x51, 0xF5
992	  };
993
994	  /** pre-allocated memory buffer used to store the internal values required by ECCDSA computation */
995	  static uint8_t preallocated_buffer[2048];
996
997	#endif /* SECBOOT_CRYPTO_SCHEM­E */
998
999	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
1000
1001	#elif ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256) )
1002	  /*
1003	    * Variable used to store the Asymmetric Key inside the protected area (even if this is a public key it is stored
1004	    * like the secret key).
1005	    * Please make sure this variable is placed in protected SRAM1.
1006	    */
1007	  static uint8_t m_aSE_PubKey[SE_ASYM_PUBKEY_LEN];
1008	#endif /* SECBOOT_CRYPTO_SCHEM­E */
1009
1010	  /*
1011	    * Local variables for authentication procedure.
1012	    */
1013	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
1014	  SE_GCMInitTypeDef se_gcm_init;
1015	  uint8_t fw_raw_header_output­[SE_FW_HEADER_TOT_LEN­];
1016	  int32_t fw_raw_header_output­_length;
1017
1018	  /* the key to be used for crypto operations (as this is a pointer to m_aSE_FirmwareKey or m_aSE_PubKey it can be a
1019	     local variable, the pointed data is protected) */
1020	  uint8_t *pKey;
1021	#elif ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256) )
1022	  int32_t status;
1023	  ECDSAsignature_stt *sign = NULL;
1024	  /* structure require for initialization */
1025	  membuf_stt Crypto_Buffer;
1026	  /* Proceed with ECC signature generation */
1027	  EC_stt EC_st;
1028	  /* Structure that will contain the public key, please note that the public key
1029	    * is just a point on the curve, hence the name ECpoint_stt
1030	    */
1031	  ECpoint_stt *PubKey = NULL;
1032	  /* Structure context used to call the ECDSAverify */
1033	  ECDSAverifyCtx_stt verctx;
1034	  const uint8_t *pSign_r;
1035	  const uint8_t *pSign_s;
1036	  /* Firmware metadata to be authenticated and reference MAC */
1037	  const uint8_t *pPayload;    /* Metadata payload */
1038	  int32_t payloadSize;        /* Metadata length to be considered for hash */
1039	  uint8_t *pSign;             /* Reference MAC (ECCDSA signed SHA256 of the FW metadata) */
1040	  const uint8_t *pPub_x;
1041	  const uint8_t *pPub_y;
1042	  /* buffer for sha256 computing */
1043	  uint8_t MessageDigest[CRL_SHA256_SIZE];
1044	  int32_t MessageDigestLength = 0;
1045
1046	  /* the key to be used for crypto operations (as this is a pointer to m_aSE_FirmwareKey or m_aSE_PubKey it can be a
1047	     local variable, the pointed data is protected) */
1048	  uint8_t *pKey;
1049	#endif /* SECBOOT_CRYPTO_SCHEM­E */
1050
1051	  if (NULL == pxSE_Metadata)
1052	  {
1053	    return e_ret_status;
1054	  }
1055
1056	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
1057	  /* Initialize the key */
1058	  SE_CRYPTO_AES_ReadKe­y(pxSE_Metadata);
1059	  pKey = &(m_aSE_FirmwareKey[0]);
1060
1061	  /*
1062	    * Call the DECRYPT primitive to verify the HeaderSignature:
1063	    *   1. Payload size is set to 0 because there is no encrypted data to decrypt
1064	    *   2. Header data is processed as Additional authenticated data (authentication only, no encrypt/decrypt)
1065	    *   3. The HeaderSignature is the tag to be verified to authenticate the header (at the FINISH stage)
1066	    */
1067
1068	  se_gcm_init.HeaderSize = (int32_t)SE_FW_AUTH_LEN; /* Authenticated part of the header */
1069	  se_gcm_init.PayloadSize = (int32_t) 0U;
1070	  se_gcm_init.pNonce = (uint8_t *)pxSE_Metadata->Nonce;
1071	  se_gcm_init.NonceSize = SE_NONCE_LEN;
1072	  se_gcm_init.pTag = (uint8_t *) pxSE_Metadata->HeaderSignature;
1073	  se_gcm_init.TagSize = SE_TAG_LEN;
1074
1075	  /* Check the parameters */
1076	  assert_param(IS_SE_CRYPTO_AES_GCM­_NONCE_SIZE(se_gcm_init.NonceSize));
1077	  assert_param(IS_SE_CRYPTO_AES_GCM­_TAG_SIZE(se_gcm_init.TagSize));
1078
1079	  /*
1080	    * Common Crypto function calls to:
1081	    *    initiate decrypt service
1082	    *    provide the header data (additional authenticated data)
1083	    *    finish the decrypt to check the header tag
1084	    */
1085
1086	  /* Initialize the operation */
1087	  e_ret_status = SE_CRYPTO_AES_GCM_De­crypt_Init(pKey, &se_gcm_init);
1088
1089	  /* check for initialization errors */
1090	  if (e_ret_status == SE_SUCCESS)
1091	  {
1092	    /* Process header */
1093	    e_ret_status = SE_CRYPTO_AES_GCM_He­ader_Append((uint8_t *)pxSE_Metadata, se_gcm_init.HeaderSize);
1094
1095	    /* Authenticate */
1096	    if (e_ret_status == SE_SUCCESS)
1097	    {
1098	      /* Finalize data */
1099	      e_ret_status = SE_CRYPTO_AES_GCM_De­crypt_Finish(fw_raw_header_output­, &fw_raw_header_output­_length);
1100	    }
1101	  }
1102
1103	#elif ( (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256) || (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256) )
1104	  e_ret_status = SE_ERROR;
1105	  /* Retrieve the ECC Public Key */
1106	  SE_CRYPTO_ReadKey_Pu­b(pxSE_Metadata, &m_aSE_PubKey[0U]);
1107	  pKey = &(m_aSE_PubKey[0]);
1108
1109	  /* Set the local variables required to handle the Firmware Metadata during the authentication procedure */
1110	  pPayload = (const uint8_t *)pxSE_Metadata;
1111	  payloadSize = (int32_t) SE_FW_AUTH_LEN;                            /* Authenticated part of the header */
1112	  pSign = pxSE_Metadata->HeaderSignature;
1113
1114	  /* Set the local variables dealing with the public key */
1115	  pPub_x  =  pKey;
1116	  pPub_y = (uint8_t *)(pKey + 32);
1117
1118	  /* signature to be verified with r and s components */
1119	  pSign_r = pSign;
1120	  pSign_s = (uint8_t *)(pSign + 32);
1121
1122	  /* Compute the SHA256 of the Firmware Metadata */
1123	  status = SE_CRYPTO_SHA256_HAS­H_DigestCompute(pPayload,
1124	                                               payloadSize,
1125	                                               (uint8_t *)MessageDigest,
1126	                                               &MessageDigestLength);
1127
1128	  if (status == HASH_SUCCESS)
1129	  {
1130	    /* We prepare the memory buffer structure */
1131	    Crypto_Buffer.pmBuf =  preallocated_buffer;
1132	    Crypto_Buffer.mUsed = 0;
1133	    Crypto_Buffer.mSize = (int16_t) sizeof(preallocated_buffer);
1134	    EC_st.pmA = P_256_a;
1135	    EC_st.pmB = P_256_b;
1136	    EC_st.pmP = P_256_p;
1137	    EC_st.pmN = P_256_n;
1138	    EC_st.pmGx = P_256_Gx;
1139	    EC_st.pmGy = P_256_Gy;
1140	    EC_st.mAsize = (int32_t)sizeof(P_256_a);
1141	    EC_st.mBsize = (int32_t)sizeof(P_256_b);
1142	    EC_st.mNsize = (int32_t)sizeof(P_256_n);
1143	    EC_st.mPsize = (int32_t)sizeof(P_256_p);
1144	    EC_st.mGxsize = (int32_t)sizeof(P_256_Gx);
1145	    EC_st.mGysize = (int32_t)sizeof(P_256_Gy);
1146
1147	    status = ECCinitEC(&EC_st, &Crypto_Buffer);
1148
1149	    if (status == ECC_SUCCESS)
1150	    {
1151	      status = ECCinitPoint(&PubKey, &EC_st, &Crypto_Buffer);
1152	    }
1153
1154	    if (status == ECC_SUCCESS)
1155	    {
1156	      /* Point is initialized, now import the public key */
1157	      (void)ECCsetPointCoordinat­e(PubKey, E_ECC_POINT_COORDINA­TE_X, pPub_x, 32);
1158	      (void)ECCsetPointCoordinat­e(PubKey, E_ECC_POINT_COORDINA­TE_Y, pPub_y, 32);
1159	      /* Try to validate the Public Key. */
1160	      status = ECCvalidatePubKey(PubKey, &EC_st, &Crypto_Buffer);
1161	    }
1162
1163	    if (status == ECC_SUCCESS)
1164	    {
1165	      /* Public Key is validated, Initialize the signature object */
1166	      status = ECDSAinitSign(&sign, &EC_st, &Crypto_Buffer);
1167	    }
1168
1169	    if (status == ECC_SUCCESS)
1170	    {
1171	      /* Import the signature values */
1172	      (void)ECDSAsetSignature(sign, E_ECDSA_SIGNATURE_R_­VALUE, pSign_r, 32);
1173	      (void)ECDSAsetSignature(sign, E_ECDSA_SIGNATURE_S_­VALUE, pSign_s, 32);
1174
1175	      /* Prepare the structure for the ECDSA signature verification */
1176	      verctx.pmEC = &EC_st;
1177	      verctx.pmPubKey = PubKey;
1178
1179	      /* Verify it */
1180	      status = ECDSAverify(MessageDigest, MessageDigestLength, sign, &verctx, &Crypto_Buffer);
1181	      if (status == SIGNATURE_VALID)
1182	      {
1183	        e_ret_status = SE_SUCCESS;
1184	      }
1185	      /* release resource ...*/
1186	      (void)ECDSAfreeSign(&sign, &Crypto_Buffer);
1187	      (void)ECCfreePoint(&PubKey, &Crypto_Buffer);
1188	      (void)ECCfreeEC(&EC_st, &Crypto_Buffer);
1189	    }
1190	  }
1191	#else
1192	#error "The current example does not support the selected crypto scheme."
1193	#endif /* SECBOOT_CRYPTO_SCHEM­E */
1194
1195	  /* Clean-up the key in RAM */
1196	#if (SECBOOT_CRYPTO_SCHEM­E == SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­)
1197	  /* Symmetric key */
1198	  SE_CLEAN_UP_FW_KEY();
1199	#else
1200	  /* ECC public key */
1201	  SE_CLEAN_UP_PUB_KEY();
1202	#endif /* SECBOOT_CRYPTO_SCHEM­E */
1203
1204	  /* Return status*/
1205	  return e_ret_status;
1206	}
1207
1208
1209	/**
1210	  * @}
1211	  */
1212
1213	/**
1214	  * @}
1215	  */
1216
1217	/**
1218	  * @}
1219	  */
1220
1221	/**
1222	  * @}
1223	  */
1224
L476_SBSFU\SECoreBin\Application\Core\Src\se_low_level.c
1	/**
2	  ******************************************************************************
3	  * @file    se_low_level.c
4	  * @author  MCD Application Team
5	  * @brief   Secure Engine Interface module.
6	  *          This file provides set of firmware functions to manage SE low level
7	  *          interface functionalities.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	#define SE_LOW_LEVEL_C
22
23	/* Includes ------------------------------------------------------------------*/
24	#include "se_low_level.h"
25	#if defined(__CC_ARM) || defined(__ARMCC_VERSION)
26	#include "mapping_sbsfu.h"
27	#endif /* __CC_ARM */
28	#include "se_exception.h"
29	#include "string.h"
30	#include "sfu_low_level_securi­ty.h"
31
32	/** @addtogroup SE Secure Engine
33	  * @{
34	  */
35	/** @defgroup  SE_HARDWARE SE Hardware Interface
36	  * @{
37	  */
38
39	/** @defgroup SE_HARDWARE_Private_­Variables Private Variables
40	  * @{
41	  */
42	static CRC_HandleTypeDef    CrcHandle;                  /*!< SE Crc Handle*/
43
44	static __IO uint32_t SE_DoubleECC_Error_C­ounter = 0U;
45
46	/**
47	  * @}
48	  */
49
50	/** @defgroup SE_HARDWARE_Private_­Functions Private Functions
51	  * @{
52	  */
53	static uint32_t SE_LL_GetBank(uint32_t Address);
54
55	static uint32_t SE_LL_GetPage(uint32_t Address);
56	/**
57	  * @}
58	  */
59
60	/** @defgroup SE_HARDWARE_Exported­_Variables Exported Variables
61	  * @{
62	  */
63
64	/**
65	  * @}
66	  */
67
68	/** @defgroup SE_HARDWARE_Exported­_Functions Exported Functions
69	  * @{
70	  */
71
72	/** @defgroup SE_HARDWARE_Exported­_CRC_Functions CRC Exported Functions
73	  * @{
74	  */
75
76	/**
77	  * @brief  Set CRC configuration and call HAL CRC initialization function.
78	  * @param  None.
79	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise
80	  */
81	SE_ErrorStatus SE_LL_CRC_Config(void)
82	{
83	  SE_ErrorStatus e_ret_status = SE_ERROR;
84
85	  CrcHandle.Instance = CRC;
86	  /* The input data are not inverted */
87	  CrcHandle.Init.InputDataInversionMo­de = CRC_INPUTDATA_INVERS­ION_NONE;
88
89	  /* The output data are not inverted */
90	  CrcHandle.Init.OutputDataInversionM­ode = CRC_OUTPUTDATA_INVER­SION_DISABLE;
91
92	  /* The Default polynomial is used */
93	  CrcHandle.Init.DefaultPolynomialUse­ = DEFAULT_POLYNOMIAL_E­NABLE;
94	  /* The default init value is used */
95	  CrcHandle.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_E­NABLE;
96	  /* The input data are 32-bit long words */
97	  CrcHandle.InputDataFormat = CRC_INPUTDATA_FORMAT­_WORDS;
98	  /* CRC Init*/
99	  if (HAL_CRC_Init(&CrcHandle) == HAL_OK)
100	  {
101	    e_ret_status = SE_SUCCESS;
102	  }
103
104	  return e_ret_status;
105	}
106
107	/**
108	  * @brief  Wrapper to HAL CRC initialization function.
109	  * @param  None
110	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
111	  */
112	SE_ErrorStatus SE_LL_CRC_Init(void)
113	{
114	  /* CRC Peripheral clock enable */
115	  __HAL_RCC_CRC_CLK_EN­ABLE();
116
117	  return SE_LL_CRC_Config();
118	}
119
120	/**
121	  * @brief  Wrapper to HAL CRC de-initialization function.
122	  * @param  None
123	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
124	  */
125	SE_ErrorStatus SE_LL_CRC_DeInit(void)
126	{
127	  SE_ErrorStatus e_ret_status = SE_ERROR;
128
129	  if (HAL_CRC_DeInit(&CrcHandle) == HAL_OK)
130	  {
131	    /* Initialization OK */
132	    e_ret_status = SE_SUCCESS;
133	  }
134
135	  return e_ret_status;
136	}
137
138	/**
139	  * @brief  Wrapper to HAL CRC Calculate function.
140	  * @param  pBuffer: pointer to data buffer.
141	  * @param  uBufferLength: buffer length in 32-bits word.
142	  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
143	  */
144	uint32_t SE_LL_CRC_Calculate(uint32_t pBuffer[], uint32_t uBufferLength)
145	{
146	  return HAL_CRC_Calculate(&CrcHandle, pBuffer, uBufferLength);
147	}
148
149	/**
150	  * @}
151	  */
152
153	/** @defgroup SE_HARDWARE_Exported­_FLASH_Functions FLASH Exported Functions
154	  * @{
155	  */
156
157	/**
158	  * @brief  This function does an erase of nb pages in user flash area
159	  * @param  pStart: pointer to  user flash area
160	  * @param  Length: number of bytes.
161	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
162	  */
163	SE_ErrorStatus SE_LL_FLASH_Erase(uint8_t *pStart, uint32_t Length)
164	{
165	  uint32_t page_error = 0U;
166	  uint32_t start = (uint32_t)pStart;
167	  FLASH_EraseInitTypeD­ef p_erase_init;
168	  SE_ErrorStatus e_ret_status = SE_SUCCESS;
169
170	  /* Unlock the Flash to enable the flash control register access *************/
171	  if (HAL_FLASH_Unlock() == HAL_OK)
172	  {
173	    /* Fill EraseInit structure*/
174	    p_erase_init.TypeErase     = FLASH_TYPEERASE_PAGE­S;
175	    p_erase_init.Banks         = SE_LL_GetBank(start);
176	    p_erase_init.Page          = SE_LL_GetPage(start);
177	    p_erase_init.NbPages       = SE_LL_GetPage(start + Length - 1U) - p_erase_init.Page + 1U;
178	    if (HAL_FLASHEx_Erase(&p_erase_init, &page_error) != HAL_OK)
179	    {
180	      e_ret_status = SE_ERROR;
181	    }
182
183	    /* Lock the Flash to disable the flash control register access (recommended
184	    to protect the FLASH memory against possible unwanted operation) *********/
185	    (void)HAL_FLASH_Lock();
186	  }
187	  else
188	  {
189	    e_ret_status = SE_ERROR;
190	  }
191
192	  return e_ret_status;
193	}
194
195	/**
196	  * @brief  Write in Flash  protected area
197	  * @param  pDestination pointer to destination area in Flash
198	  * @param  pSource pointer to input buffer
199	  * @param  Length number of bytes to be written
200	  * @retval SE_SUCCESS if successful, otherwise SE_ERROR
201	  */
202
203	SE_ErrorStatus SE_LL_FLASH_Write(uint8_t *pDestination, const uint8_t *pSource, uint32_t Length)
204	{
205	  SE_ErrorStatus ret = SE_SUCCESS;
206	  uint32_t i;
207	  uint32_t verified = 0U;
208	  uint32_t destination = (uint32_t)pDestination;
209	  uint32_t source = (uint32_t)pSource;
210
211	  if (Length == 0U)
212	  {
213	    return SE_ERROR;
214	  }
215
216	  /* Area should be inside 1 of the firmware image headers */
217	  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IM­AGE; i++)
218	  {
219	    if ((destination >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
220	        ((destination + Length) <= (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET­)))
221	    {
222	      verified = 1U;
223	    }
224	  }
225	  if (verified == 0U)
226	  {
227	    return SE_ERROR;
228	  }
229
230	  /* Unlock the Flash to enable the flash control register access *************/
231	  if (HAL_FLASH_Unlock() == HAL_OK)
232	  {
233	    for (i = 0U; i < Length; i += 8U)
234	    {
235	      if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_DO­UBLEWORD, (destination + i), *(uint64_t *)(source + i)) != HAL_OK)
236	      {
237	        ret = SE_ERROR;
238	        break;
239	      }
240	    }
241
242	    /* Lock the Flash to disable the flash control register access (recommended
243	    to protect the FLASH memory against possible unwanted operation) */
244	    (void)HAL_FLASH_Lock();
245	  }
246	  else
247	  {
248	    ret = SE_ERROR;
249	  }
250	  return ret;
251	}
252
253	/**
254	  * @brief  Read in Flash protected area
255	  * @param  pDestination: Start address for target location
256	  * @param  pSource: pointer on buffer with data to read
257	  * @param  Length: Length in bytes of data buffer
258	  * @retval SFU_ErrorStatus SFU_SUCCESS if successful, SFU_ERROR otherwise.
259	  */
260	SE_ErrorStatus SE_LL_FLASH_Read(uint8_t *pDestination, const uint8_t *pSource, uint32_t Length)
261	{
262	  uint32_t source = (uint32_t)pSource;
263	  SE_ErrorStatus e_ret_status = SE_ERROR;
264	  uint32_t i;
265	  uint32_t verified = 0U;
266
267	  /* Area should be inside 1 of the firmware image headers
268	     or inside 1 of the download areas */
269	  for (i = 0U; i < SFU_NB_MAX_ACTIVE_IM­AGE; i++)
270	  {
271	    if ((source >= SlotHeaderAdd[SLOT_ACTIVE_1 + i]) &&
272	        ((source + Length) <= (SlotHeaderAdd[SLOT_ACTIVE_1 + i] + SFU_IMG_IMAGE_OFFSET­)))
273	    {
274	      verified = 1U;
275	    }
276	  }
277
278	  for (i = 0U; i < SFU_NB_MAX_DWL_AREA; i++)
279	  {
280	    if ((source >= SlotStartAdd[SLOT_DWL_1 + i]) &&
281	        ((source + Length) <= (SlotStartAdd[SLOT_DWL_1 + i] + SLOT_SIZE(SLOT_DWL_1))))
282	    {
283	      verified = 1U;
284	    }
285	  }
286
287	  if (verified == 0U)
288	  {
289	    return SE_ERROR;
290	  }
291
292	  SE_DoubleECC_Error_C­ounter = 0U;
293	  /* Do not use memcpy from lib : ECC error should be checked at each loop */
294	  for (i = 0; (i < Length) && (SE_DoubleECC_Error_C­ounter == 0U); i++, pDestination++, pSource++)
295	  {
296	    *pDestination = *pSource;
297	  }
298	  if (SE_DoubleECC_Error_C­ounter == 0U)
299	  {
300	    e_ret_status = SE_SUCCESS;
301	  }
302	  SE_DoubleECC_Error_C­ounter = 0U;
303	  return e_ret_status;
304	}
305
306	/**
307	  * @}
308	  */
309
310	/** @defgroup SE_HARDWARE_Exported­_FLASH_EXT_Functions­ External FLASH Exported Functions
311	  * @{
312	  */
313
314	/**
315	  * @brief Initialisation of external flash On The Fly DECryption (OTFDEC)
316	  * @param pxSE_Metadata: Firmware metadata.
317	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
318	  */
319	SE_ErrorStatus SE_LL_FLASH_EXT_Decr­ypt_Init(SE_FwRawHeaderTypeDe­f *pxSE_Metadata)
320	{
321	  /* Prevent unused argument(s) compilation warning */
322	  UNUSED(pxSE_Metadata);
323	  return SE_SUCCESS;
324	}
325
326	/**
327	  * @}
328	  */
329
330	/**
331	  * @brief Check if an array is inside the RAM of the product
332	  * @param Addr : address  of array
333	  * @param Length : length of array in byte
334	  */
335	SE_ErrorStatus SE_LL_Buffer_in_ram(void *pBuff, uint32_t Length)
336	{
337	  SE_ErrorStatus ret = SE_ERROR;
338	  uint32_t addr_start = (uint32_t)pBuff;
339	  uint32_t addr_end = addr_start + Length - 1U;
340
341	  /* Check if length is positive with no overflow */
342	  if ((Length != 0U) && (!((0xFFFFFFFFUL - addr_start) < Length))
343	      && (((addr_start >= SRAM1_BASE) && (addr_end <= 0x20017FFFU)) ||
344	          ((addr_start >= SRAM2_BASE)  && (addr_end <= 0x10007FFFU))))
345	  {
346	    ret = SE_SUCCESS;
347	  }
348	  else
349	  {
350	    /* Could be an attack ==> Reset */
351	    NVIC_SystemReset();
352	  }
353
354	  return ret;
355	}
356
357	/**
358	  * @brief function checking if a buffer is in sbsfu ram.
359	  * @param pBuff: address of buffer
360	  * @param Length: length of buffer in bytes
361	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise.
362	  */
363	SE_ErrorStatus SE_LL_Buffer_in_SBSF­U_ram(const void *pBuff, uint32_t Length)
364	{
365	  SE_ErrorStatus e_ret_status;
366	  uint32_t addr_start = (uint32_t)pBuff;
367	  uint32_t addr_end = addr_start + Length - 1U;
368
369	  /* Check if length is positive with no overflow */
370	  if ((Length != 0U) && (!((0xFFFFFFFFUL - addr_start) < Length))
371	      && ((addr_end  <= SB_REGION_RAM_END) && (addr_start >= SB_REGION_RAM_START)))
372	  {
373	    e_ret_status = SE_SUCCESS;
374	  }
375	  else
376	  {
377	    e_ret_status = SE_ERROR;
378
379	    /* Could be an attack ==> Reset */
380	    NVIC_SystemReset();
381	  }
382	  return e_ret_status;
383	}
384
385	/**
386	  * @brief function checking if a buffer is PARTLY in se ram.
387	  * @param pBuff: address of buffer
388	  * @param Length: length of buffer in bytes
389	  * @retval SE_ErrorStatus SE_SUCCESS for buffer in NOT se ram, SE_ERROR otherwise.
390	  */
391	SE_ErrorStatus SE_LL_Buffer_part_of­_SE_ram(const void *pBuff, uint32_t Length)
392	{
393	  SE_ErrorStatus e_ret_status;
394	  uint32_t addr_start = (uint32_t)pBuff;
395	  uint32_t addr_end = addr_start + Length - 1U;
396
397	  /* Check if length is positive with no overflow */
398	  if (((Length != 0U) && (!(((addr_start < SE_REGION_RAM_START) && (addr_end < SE_REGION_RAM_START)) ||
399	                            ((addr_start > SE_REGION_RAM_END) && (addr_end > SE_REGION_RAM_END)))))
400	      || ((0xFFFFFFFFUL - addr_start) < Length))
401	  {
402	    e_ret_status = SE_SUCCESS;
403
404	    /* Could be an attack ==> Reset */
405	    NVIC_SystemReset();
406	  }
407	  else
408	  {
409	    e_ret_status = SE_ERROR;
410	  }
411	  return e_ret_status;
412	}
413
414	/**
415	  * @brief function checking if a buffer is PARTLY in se rom.
416	  * @param pBuff: address of buffer
417	  * @param Length: length of buffer in bytes
418	  * @retval SE_ErrorStatus SE_SUCCESS for buffer in NOT se rom, SE_ERROR otherwise.
419	  */
420	SE_ErrorStatus SE_LL_Buffer_part_of­_SE_rom(const void *pBuff, uint32_t Length)
421	{
422	  SE_ErrorStatus e_ret_status;
423	  uint32_t addr_start = (uint32_t)pBuff;
424	  uint32_t addr_end = addr_start + Length - 1U;
425
426	  /* Check if length is positive with no overflow */
427	  if (((Length != 0U) && (!(((addr_start < SE_CODE_REGION_ROM_S­TART) && (addr_end < SE_CODE_REGION_ROM_S­TART))
428	                            || ((addr_start > SE_CODE_REGION_ROM_E­ND) && (addr_end > SE_CODE_REGION_ROM_E­ND))
429	                            || ((addr_start < SFU_PROTECT_FWALL_NV­DATA_ADDR_START)
430	                                && (addr_end < SFU_PROTECT_FWALL_NV­DATA_ADDR_START))
431	                            || ((addr_start > (SFU_PROTECT_FWALL_NV­DATA_ADDR_START + SFU_PROTECT_FWALL_NV­DATA_SIZE))
432	                                && (addr_end > (SFU_PROTECT_FWALL_NV­DATA_ADDR_START + SFU_PROTECT_FWALL_NV­DATA_SIZE)))
433	                           )))
434	      || ((0xFFFFFFFFUL - addr_start) < Length))
435	  {
436	    e_ret_status = SE_SUCCESS;
437
438	    /* Could be an attack ==> Reset */
439	    NVIC_SystemReset();
440	  }
441	  else
442	  {
443	    e_ret_status = SE_ERROR;
444	  }
445	  return e_ret_status;
446	}
447
448	/**
449	  * @}
450	  */
451
452	/**
453	  * @}
454	  */
455
456	/** @addtogroup SE_HARDWARE_Private_­Functions
457	  * @{
458	  */
459
460	/**
461	  * @brief  Gets the page of a given address
462	  * @param  Addr: Address of the FLASH Memory
463	  * @retval The page of a given address
464	  */
465	static uint32_t SE_LL_GetPage(uint32_t Address)
466	{
467	  uint32_t page;
468
469	  if (Address < (FLASH_BASE + (FLASH_BANK_SIZE)))
470	  {
471	    /* Bank 1 */
472	    page = (Address - FLASH_BASE) / FLASH_PAGE_SIZE;
473	  }
474	  else
475	  {
476	    /* Bank 2 */
477	    page = (Address - (FLASH_BASE + (FLASH_BANK_SIZE))) / FLASH_PAGE_SIZE;
478	  }
479	  return page;
480	}
481
482	/**
483	  * @brief  Gets the bank of a given address
484	  * @param  Addr: Address of the FLASH Memory
485	  * @retval The bank of a given address
486	  */
487
488	static uint32_t SE_LL_GetBank(uint32_t Address)
489	{
490	  uint32_t bank;
491
492	  if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MOD­E) == 0U)
493	  {
494	    /* No Bank swap */
495	    if (Address < (FLASH_BASE + (FLASH_BANK_SIZE)))
496	    {
497	      bank = FLASH_BANK_1;
498	    }
499	    else
500	    {
501	      bank = FLASH_BANK_2;
502	    }
503	  }
504	  else
505	  {
506	    /* Bank swap */
507	    if (Address < (FLASH_BASE + (FLASH_BANK_SIZE)))
508	    {
509	      bank = FLASH_BANK_2;
510	    }
511	    else
512	    {
513	      bank = FLASH_BANK_1;
514	    }
515	  }
516
517	  return bank;
518	}
519
520	/**
521	  * @brief  Get Link Register value (LR)
522	  * @param  None.
523	  * @retval LR Register value
524	  */
525	__attribute__((always_inline)) __STATIC_INLINE uint32_t get_LR(void)
526	{
527	  register uint32_t result;
528
529	#if defined ( __ICCARM__ ) || defined ( __GNUC__ ) || defined (__ARMCC_VERSION)
530	  __ASM volatile("MOV %0, LR" : "=r"(result));
531	#elif defined ( __CC_ARM )
532	  __ASM volatile("MOV result, __return_address()");
533	#endif /* ( __ICCARM__ ) || ( __GNUC__ ) */
534
535	  return result;
536	}
537
538	/*
539	   As this handler code relies on stack pointer position to manipulate the PC return value, it is important
540	   not to use extra registers (on top of scratch registers), because it would change the stack pointer
541	   position. Then compiler optimizations are customized to ensure that.
542	*/
543	#if defined(__ICCARM__)
544	#pragma optimize=none
545	#elif defined(__CC_ARM)
546	#pragma O0
547	#elif defined(__ARMCC_VERSION)
548	__attribute__((optnone))
549	#elif defined ( __GNUC__ )
550	__attribute__((optimize("O1")))
551	#endif /* __ICCARM__ */
552
553	/**
554	  * @brief  NMI Handler present for handling Double ECC NMI interrupt
555	  * @param  None.
556	  * @retval None.
557	  */
558	void NMI_Handler(void)
559	{
560	  uint32_t *p_sp;
561	  uint32_t lr;
562	  uint16_t opcode_msb;
563
564	  if (__HAL_FLASH_GET_FLAG­(FLASH_FLAG_ECCD))
565	  {
566	    __HAL_FLASH_CLEAR_FL­AG(FLASH_FLAG_ECCD);
567
568	    /* Memorize error to ignore the read value */
569	    SE_DoubleECC_Error_C­ounter++;
570
571	    lr = get_LR();
572
573	    /* Check EXC_RETURN value in LR to know which SP was used prior entering exception */
574	    if (((lr) & (0xFU)) == 0xDU)
575	    {
576	      /* interrupted code was using Process Stack Pointer */
577	      p_sp = (uint32_t *)__get_PSP();
578	    }
579	    else
580	    {
581	      /* interrupted code was using Main Stack Pointer */
582	      p_sp = (uint32_t *)__get_MSP();
583	    }
584
585	    /* Test caller mode T bit from CPSR in stack */
586	    if ((*(p_sp + 7U) & (1U << xPSR_T_Pos)) != 0U)
587	    {
588	      /* Thumb  mode.
589	         Test PC in stack.
590	         If bits [15:11] of the halfword being decoded take any of the following values,
591	         the halfword is the first halfword of a 32-bit instruction: 0b11101, 0b11110, 0b11111.
592	         Otherwise, the halfword is a 16-bit instruction.
593	      */
594	      opcode_msb = (*(uint16_t *)(*(p_sp + 6) & 0xFFFFFFFEU) & 0xF800U);
595	      if ((opcode_msb == 0xE800U) || (opcode_msb == 0xF000U) || (opcode_msb == 0xF800U))
596	      {
597	        /* execute next instruction PC +4  */
598	        *(p_sp + 6U) += 4U;
599	      }
600	      else
601	      {
602	        /* execute next instruction PC +2  */
603	        *(p_sp + 6U) += 2U;
604	      }
605	    }
606	    else
607	    {
608	      /* ARM mode execute next instruction PC +4 */
609	      *(p_sp + 6U) += 4U;
610	    }
611	  }
612	  else
613	  {
614	    /* This exception occurs for another reason than flash double ECC errors */
615	    SE_NMI_ExceptionHand­ler();
616	  }
617	}
618
619	/**
620	  * @brief  Hard Fault Handler present for handling Double ECC Bus Fault interrupt
621	  * @param  None.
622	  * @retvat void
623	  */
624	void HardFault_Handler(void)
625	{
626	  SE_NMI_ExceptionHand­ler();
627	}
628
629	/**
630	  * @brief  Cleanup SE CORE
631	  * The function is called  during SE_LOCK_RESTRICT_SER­VICES.
632	  *
633	  */
634	void  SE_LL_CORE_Cleanup(void)
635	{
636	}
637
638	/** @addtogroup SE_LOCK_KEYS_Exporte­d_Functions
639	  * @{
640	  */
641
642	/**
643	  * @brief  Lock the embedded keys used by SBSFU
644	  * @param  None
645	  * @retval SE_ErrorStatus SE_SUCCESS if successful, SE_ERROR otherwise
646	  */
647	SE_ErrorStatus SE_LL_Lock_Keys(void)
648	{
649	  return SE_SUCCESS;
650	}
651	/**
652	  * @}
653	  */
654
655	/**
656	  * @}
657	  */
658
659	/**
660	  * @}
661	  */
662
663	/**
664	  * @}
665	  */
666
667
L476_SBSFU\SECoreBin\Application\User\data_init.c
1	/**
2	  ******************************************************************************
3	  * @file    data_init.c
4	  * @author  MCD Application Team
5	  * @brief   Data section (RW + ZI) initialization.
6	  *          This file provides set of firmware functions to manage SE low level
7	  *          interface functionalities.
8	  ******************************************************************************
9	  * @attention
10	  *
11	  * Copyright (c) 2017 STMicroelectronics.
12	  * All rights reserved.
13	  *
14	  * This software is licensed under terms that can be found in the LICENSE file in
15	  * the root directory of this software component.
16	  * If no LICENSE file comes with this software, it is provided AS-IS.
17	  *
18	  ******************************************************************************
19	  */
20
21	/* Includes ------------------------------------------------------------------*/
22	#include "stdint-gcc.h"
23
24	#ifndef vu32
25	#	define vu32 volatile uint32_t
26	#endif
27
28	/**
29	  * @brief  Copy initialized data from ROM to RAM.
30	  * @param  None.
31	  * @retval None.
32	  */
33
34	void LoopCopyDataInit(void)
35	{
36		extern uint8_t* _sidata asm("_sidata");
37		extern uint8_t* _sdata asm("_sdata");
38		extern uint8_t* _edata asm("_edata");
39
40		vu32* src = (vu32*) &_sidata;
41		vu32* dst = (vu32*) &_sdata;
42
43		vu32 len = ((vu32)(&_edata) - (vu32)(&_sdata)) / 4;
44
45		for(vu32 i=0; i < len; i++)
46			dst[i] = src[i];
47	}
48
49	/**
50	  * @brief  Clear the zero-initialized data section.
51	  * @param  None.
52	  * @retval None.
53	  */
54	void LoopFillZerobss(void)
55	{
56		extern uint8_t* _sbss asm("_sbss");
57		extern uint8_t* _ebss asm("_ebss");
58
59		vu32* dst = (vu32*) &_sbss;
60		vu32 len = ((vu32)(&_ebss) - (vu32)(&_sbss)) / 4;
61
62		for(vu32 i=0; i < len; i++)
63			dst[i] = 0;
64	}
65
66	/**
67	  * @brief  Data section initialization.
68	  * @param  None.
69	  * @retval None.
70	  */
71	void __gcc_data_init(void) {
72		LoopFillZerobss();
73		LoopCopyDataInit();
74	}
75
L476_SBSFU\SECoreBin\Application\User\syscalls.c
1	/**
2	 ******************************************************************************
3	 * @file      syscalls.c
4	 * @author    Auto-generated by STM32CubeIDE
5	 * @brief     STM32CubeIDE Minimal System calls file
6	 *
7	 *            For more information about which c-functions
8	 *            need which of these lowlevel functions
9	 *            please consult the Newlib libc-manual
10	 ******************************************************************************
11	 * @attention
12	 *
13	 * Copyright (c) 2020-2023 STMicroelectronics.
14	 * All rights reserved.
15	 *
16	 * This software is licensed under terms that can be found in the LICENSE file
17	 * in the root directory of this software component.
18	 * If no LICENSE file comes with this software, it is provided AS-IS.
19	 *
20	 ******************************************************************************
21	 */
22
23	/* Includes */
24	#include <sys/stat.h>
25	#include <stdlib.h>
26	#include <errno.h>
27	#include <stdio.h>
28	#include <signal.h>
29	#include <time.h>
30	#include <sys/time.h>
31	#include <sys/times.h>
32
33
34	/* Variables */
35	extern int __io_putchar(int ch) __attribute__((weak));
36	extern int __io_getchar(void) __attribute__((weak));
37
38
39	char *__env[1] = { 0 };
40	char **environ = __env;
41
42
43	/* Functions */
44	void initialise_monitor_h­andles()
45	{
46	}
47
48	int _getpid(void)
49	{
50	  return 1;
51	}
52
53	int _kill(int pid, int sig)
54	{
55	  (void)pid;
56	  (void)sig;
57	  errno = EINVAL;
58	  return -1;
59	}
60
61	void _exit (int status)
62	{
63	  _kill(status, -1);
64	  while (1) {}    /* Make sure we hang here */
65	}
66
67	__attribute__((weak)) int _read(int file, char *ptr, int len)
68	{
69	  (void)file;
70	  int DataIdx;
71
72	  for (DataIdx = 0; DataIdx < len; DataIdx++)
73	  {
74	    *ptr++ = __io_getchar();
75	  }
76
77	  return len;
78	}
79
80	__attribute__((weak)) int _write(int file, char *ptr, int len)
81	{
82	  (void)file;
83	  int DataIdx;
84
85	  for (DataIdx = 0; DataIdx < len; DataIdx++)
86	  {
87	    __io_putchar(*ptr++);
88	  }
89	  return len;
90	}
91
92	int _close(int file)
93	{
94	  (void)file;
95	  return -1;
96	}
97
98
99	int _fstat(int file, struct stat *st)
100	{
101	  (void)file;
102	  st->st_mode = S_IFCHR;
103	  return 0;
104	}
105
106	int _isatty(int file)
107	{
108	  (void)file;
109	  return 1;
110	}
111
112	int _lseek(int file, int ptr, int dir)
113	{
114	  (void)file;
115	  (void)ptr;
116	  (void)dir;
117	  return 0;
118	}
119
120	int _open(char *path, int flags, ...)
121	{
122	  (void)path;
123	  (void)flags;
124	  /* Pretend like we always fail */
125	  return -1;
126	}
127
128	int _wait(int *status)
129	{
130	  (void)status;
131	  errno = ECHILD;
132	  return -1;
133	}
134
135	int _unlink(char *name)
136	{
137	  (void)name;
138	  errno = ENOENT;
139	  return -1;
140	}
141
142	int _times(struct tms *buf)
143	{
144	  (void)buf;
145	  return -1;
146	}
147
148	int _stat(char *file, struct stat *st)
149	{
150	  (void)file;
151	  st->st_mode = S_IFCHR;
152	  return 0;
153	}
154
155	int _link(char *old, char *new)
156	{
157	  (void)old;
158	  (void)new;
159	  errno = EMLINK;
160	  return -1;
161	}
162
163	int _fork(void)
164	{
165	  errno = EAGAIN;
166	  return -1;
167	}
168
169	int _execve(char *name, char **argv, char **env)
170	{
171	  (void)name;
172	  (void)argv;
173	  (void)env;
174	  errno = ENOMEM;
175	  return -1;
176	}
L476_SBSFU\SECoreBin\Doc\readme.txt

/**
  @page Secure Engine Core binary generation.

  @verbatim
  ******************** (C) COPYRIGHT 2017 STMicroelectronics *******************
  * @file    readme.txt
  * @brief   Secure Engine Core binary generation.
  *          SE Core binary exports SE CallGate function entry point for
  *          SFU Application.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @endverbatim

@par Application Description

This application is used to generate Secure Engine Core binary file to be linked with Secure Boot & Secure Firmware
Update application (SBSFU).
SE Core binary exports a single entry point to SE CallGate function and a startup method for data initialization.
It is based on the Secure Engine Middleware.

It has to be compiled before SBSFU project.

Three cryptographic schemes are provided as example to illustrate the cryptographic operations. The default
cryptographic scheme uses both symmetric (AES-CBC) and asymmetric (ECDSA) cryptography. Two alternate schemes are
provided and can be selected thanks to SECBOOT_CRYPTO_SCHEME compiler switch named :
   - SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256 (default)
   - SECBOOT_ECCDSA_WITHOUT_ENCRYPT_SHA256
   - SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM

For more details, refer to UM2262 "Getting started with SBSFU - software expansion for STM32Cube"
available from the STMicroelectronics microcontroller website www.st.com.

@par Directory contents

   - 2_Images_SECoreBin/Src/se_crypto_bootloader.c              Implementation of the crypto scheme functions used by the bootloader
   - 2_Images_SECoreBin/Src/se_low_level.c                      Low level interface
   - 2_Images_SECoreBin/Inc/se_crypto_bootloader.h              Header file for se_crypto_bootloader.c
   - 2_Images_SECoreBin/Inc/se_crypto_config.h                  Crypto scheme configuration (crypto scheme used by the bootloader)
   - 2_Images_SECoreBin/Inc/se_def_metadata.h                   Firmware metadata (header) definition
   - 2_Images_SECoreBin/Inc/se_low_level.h                      Header file for low level interface
   - 2_Images_SECoreBin/Inc/stm32l4xx_hal_conf.h                HAL configuration file
   - 2_Images_SECoreBin/Binary/ECCKEY1.txt                      Private ECCDSA key for signature verification
   - 2_Images_SECoreBin/Binary/nonce.bin                        Number used only once for firmware encryption
   - 2_Images_SECoreBin/Binary/OEM_KEY_COMPANY1_key_AES_CBC.bin Public key for AES CBC encryption
   - 2_Images_SECoreBin/Binary/OEM_KEY_COMPANY1_key_AES_GCM.bin Public key for AES GCM encryption

@par Hardware and Software environment

   - This example runs on STM32L476xx devices
   - This example has been tested with STM32L476RG-Nucleo Rev C board and can be easily tailored to any other supported device and
     development board.
   - An up-to-date version of ST-LINK firmware is required. Upgrading ST-LINK firmware is a feature provided by
     STM32Cube programmer available on www.st.com.
   - Microsoft Windows has a limitation whereby paths to files and directories cannot be longer than 256 characters.
     Paths to files exceeding that limits cause tools (e.g. compilers, shell scripts) to fail reading from or writing
     to such files. As a workaround, it is advised to use the subst.exe command from within a command prompt to set up
     a local drive out of an existing directory on the hard drive, such as:
     C:\> subst X: <PATH_TO_CUBEFW>\Firmware


@par IDE prebuild script

In order to ease the development process, a prebuild script ("prebuild.bat") is integrated in each IDE project.
This preliminary processing is in charge of:
   - determining the requested cryptographic scheme
   - generating the appropriate keys ("se_keys.s" file)
   - generating the appropriate script to prepare the firmware image ("postbuild.bat") when building the UserApp project

A known limitation of this integration occurs when you update a cryptographic parameter (for instance the cryptographic
key). The IDE does not track this update so you need to force the rebuild of the project manually.

@par How to use it ?

In order to generate Secure Engine Core binary file, you must do the following :
   - Open your preferred toolchain
   - Rebuild the project


L476_SBSFU\SECoreBin\Output\crypto.txt

SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM

L476_SBSFU\SECoreBin\Output\output.txt

prebuild.sh : started
prepareimage with windows executable
 C:/Users/Menachem Fried/OneDrive - Binata/SBSFU_NUCLEO_L476/Project/L476_SBSFU/Common/KeysAndImages_Util/win/prepareimage/prepareimage.exe
SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM selected

L476_SBSFU\SECoreBin\Scripts\postbuild.sh
1	#!/bin/bash -
2	#Post build for SECBOOT_AES128_GCM_W­ITH_AES128_GCM
3	# arg1 is the build directory
4	# arg2 is the elf file path+name
5	# arg3 is the bin file path+name
6	# arg4 is the firmware Id (1/2/3)
7	# arg5 is the version
8	# arg6 when present forces "bigelf" generation
9	projectdir=$1
10	FileName=${3##*/}
11	execname=${FileName%.*}
12	elf=$2
13	bin=$3
14	fwid=$4
15	version=$5
16
17	SecureEngine=${0%/*}
18
19	userAppBinary=$projectdir"/../Binary"
20
21	sfu=$userAppBinary"/"$execname".sfu"
22	sfb=$userAppBinary"/"$execname".sfb"
23	sign=$userAppBinary"/"%execname".sign"
24	headerbin=$userAppBinary"/"$execname"sfuh.bin"
25	bigbinary=$userAppBinary"/SBSFU_"$execname".bin"
26	elfbackup=$userAppBinary"/SBSFU_"$execname".elf"
27
28	nonce=$SecureEngine"/../Binary/nonce.bin"
29	magic="SFU"$fwid
30	oemkey=$SecureEngine"/../Binary/OEM_KEY_COMPANY"$fwid"_key_AES_GCM.bin"
31	partialbin=$userAppBinary"/Partial"$execname".bin"
32	partialsfb=$userAppBinary"/Partial"$execname".sfb"
33	partialsfu=$userAppBinary"/Partial"$execname".sfu"
34	partialsign=$userAppBinary"/Partial"$execname".sign"
35	partialoffset=$userAppBinary"/Partial"$execname".offset"
36	ref_userapp=$projectdir"/RefUserApp.bin"
37	offset=512
38	alignment=16
39
40	current_directory=`pwd`
41	cd "$SecureEngine/../../"
42	SecureDir=`pwd`
43	cd "$current_directory"
44	sbsfuelf="$SecureDir/2_Images_SBSFU/STM32CubeIDE/Debug/SBSFU.elf"
45	current_directory=`pwd`
46	cd "$1/../../../../../../Middlewares/ST/STM32_Secure_Engine/Utilities/KeysAndImages"
47	basedir=`pwd`
48	cd "$current_directory"
49	# test if window executable usable
50	prepareimage=$basedir"/win/prepareimage/prepareimage.exe"
51	uname | grep -i -e windows -e mingw >/dev/null > /dev/null 2>&1
52	if [ $? -eq 0 ] && [  -e "$prepareimage" ]; then
53	  echo "prepareimage with windows executable"
54	  PATH=$basedir"\\win\\prepareimage":$PATH > /dev/null 2>&1
55	  cmd=""
56	  prepareimage="prepareimage.exe"
57	else
58	  # line for python
59	  echo "prepareimage with python script"
60	  prepareimage=$basedir/prepareimage.py
61	  cmd="python"
62	fi
63
64	# Make sure we have a Binary sub-folder in UserApp folder
65	if [ ! -e $userAppBinary ]; then
66	mkdir $userAppBinary
67	fi
68
69	command=$cmd" "$prepareimage" enc -k "$oemkey" -n "$nonce" "$bin" "$sfu
70	$command > $projectdir"/output.txt"
71	ret=$?
72	if [ $ret -eq 0 ]; then
73	  command=$cmd" "$prepareimage" sign -k "$oemkey" -n "$nonce" "$bin" "$sign
74	  $command >> $projectdir"/output.txt"
75	  ret=$?
76	  if [ $ret -eq 0 ]; then
77	    command=$cmd" "$prepareimage" pack -m "$magic" -k "$oemkey"  -r 112 -v "$version" -n "$nonce" -f "$sfu" -t "$sign" "$sfb" -o "$offset
78	    $command >> $projectdir"/output.txt"
79	    ret=$?
80	    if [ $ret -eq 0 ]; then
81	      command=$cmd" "$prepareimage" header -m "$magic" -k  "$oemkey" -r 112 -v "$version"  -n "$nonce" -f "$sfu" -t "$sign" -o "$offset" "$headerbin
82	      $command >> $projectdir"/output.txt"
83	      ret=$?
84	      if [ $ret -eq 0 ]; then
85	        command=$cmd" "$prepareimage" merge -v 0 -e 1 -i "$headerbin" -s "$sbsfuelf" -u "$elf" "$bigbinary
86	        $command >> $projectdir"/output.txt"
87	        ret=$?
88	        #Partial image generation if reference userapp exists
89	        if [ $ret -eq 0 ] && [ -e "$ref_userapp" ]; then
90	          echo "Generating the partial image .sfb"
91	          echo "Generating the partial image .sfb" >> $projectdir"/output.txt"
92	          command=$cmd" "$prepareimage" diff -1 "$ref_userapp" -2 "$bin" "$partialbin" -a "$alignment" --poffset "$partialoffset
93	          $command >> $projectdir"/output.txt"
94	          ret=$?
95	          if [ $ret -eq 0 ]; then
96	            command=$cmd" "$prepareimage" enc -k "$oemkey" -i "$nonce" "$partialbin" "$partialsfu
97	            $command >> $projectdir"/output.txt"
98	            ret=$?
99	            if [ $ret -eq 0 ]; then
100	              command=$cmd" "$prepareimage" sign -k "$oemkey" -n "$nonce" "$partialbin" "$partialsign
101	              $command >> $projectdir"/output.txt"
102	              ret=$?
103	              if [ $ret -eq 0 ]; then
104	                command=$cmd" "$prepareimage" pack -m "$magic" -k "$oemkey" -r 112 -v "$version" -i "$nonce" -f "$sfu" -t "$sign" -o "$offset" --pfw "$partialsfu" --ptag "$partialsign" --poffset  "$partialoffset" "$partialsfb
105	                $command >> $projectdir"/output.txt"
106	                ret=$?
107	              fi
108	            fi
109	          fi
110	        fi
111	        if [ $ret -eq 0 ] && [ $# = 6 ]; then
112	          echo "Generating the global elf file SBSFU and userApp"
113	          echo "Generating the global elf file SBSFU and userApp" >> $projectdir"/output.txt"
114	          uname | grep -i -e windows -e mingw > /dev/null 2>&1
115	          if [ $? -eq 0 ]; then
116	            # Set to the default installation path of the Cube Programmer tool
117	            # If you installed it in another location, please update PATH.
118	            PATH="C:\\Program Files (x86)\\STMicroelectronics\\STM32Cube\\STM32CubeProgrammer\\bin":$PATH > /dev/null 2>&1
119	            programmertool="STM32_Programmer_CLI­.exe"
120	          else
121	            which STM32_Programmer_CLI­ > /dev/null
122	            if [ $? = 0 ]; then
123	              programmertool="STM32_Programmer_CLI­"
124	            else
125	              echo "fix access path to STM32_Programmer_CLI­"
126	            fi
127	          fi
128	          command=$programmertool" -ms "$elf" "$headerbin" "$sbsfuelf
129	          $command >> $projectdir"/output.txt"
130	          ret=$?
131	        fi
132	      fi
133	    fi
134	  fi
135	fi
136
137
138	if [ $ret -eq 0 ]; then
139	  rm $sign
140	  rm $sfu
141	  rm $headerbin
142	  if [ -e "$ref_userapp" ]; then
143	    rm $partialbin
144	    rm $partialsfu
145	    rm $partialsign
146	    rm $partialoffset
147	  fi
148	  exit 0
149	else
150	  echo "$command : failed" >> $projectdir"/output.txt"
151	  if [ -e  "$elf" ]; then
152	    rm  $elf
153	  fi
154	  if [ -e "$elfbackup" ]; then
155	    rm  $elfbackup
156	  fi
157	  echo $command : failed
158	  read -n 1 -s
159	  exit 1
160	fi
161
L476_SBSFU\SECoreBin\Scripts\prebuild.sh
1	#!/bin/bash -
2
3	# Pre build for script for the Secure Engine
4	#  $1 is the Project Directory
5	#  $2 is the Common Directory
6	#  $3 is for the Output Folder
7
8	if [ -z "$1" ]; then
9	  echo "Usage: $0 <Project Directory> <Common Directory> <Output Folder>"
10	  exit 1
11	fi
12
13	if [ -z "$2" ]; then
14	  echo "Usage: $0 <Project Directory> <Common Directory> <Output Folder>"
15	  exit 1
16	fi
17
18	if [ -z "$3" ]; then
19	  echo "Usage: $0 <Project Directory> <Common Directory> <Output Folder>"
20	  exit 1
21	fi
22
23	if [ ! -d "$1" ]; then
24	  echo Project Directory "$1" does not exist.
25	  exit 1
26	fi
27
28
29	if [ ! -d "$2" ]; then
30	  echo Common Directory "$2" does not exist.
31	  exit 1
32	fi
33
34	if [ ! -d "$2"/Binary ]; then
35	  echo Common Directory "$2"/Binary does not exist.
36	  exit 1
37	fi
38
39	if [ ! -d "$2"/Binary_Keys ]; then
40	  echo Common Directory "$2"/Binary_Keys does not exist.
41	  exit 1
42	fi
43
44	if [ ! -d "$2"/Debug ]; then
45	  echo Common Directory "$2"/Debug does not exist.
46	  exit 1
47	fi
48
49	if [ ! -d "$2"/Debug/Middlewares ]; then
50	  echo Common Directory "$2"/Debug/Middlewares does not exist.
51	  exit 1
52	fi
53
54	if [ ! -d "$2"/Debug/Middlewares/STM32_Secure_Engine ]; then
55	  echo Common Directory "$2"/Debug/Middlewares/STM32_Secure_Engine does not exist.
56	  exit 1
57	fi
58
59	if [ ! -d "$2"/KeysAndImages_Util ]; then
60	  echo Common Directory "$2"/KeysAndImages_Util does not exist.
61	  exit 1
62	fi
63
64	if [ ! -d "$2"/Linker ]; then
65	  echo Common Directory "$2"/Linker does not exist.
66	  exit 1
67	fi
68
69	if [ ! -d "$2"/Scripts ]; then
70	  echo Common Directory "$2"/Scripts does not exist.
71	  exit 1
72	fi
73
74	if [ ! -d "$2"/Startup ]; then
75	  echo Common Directory "$2"/Startup does not exist.
76	  exit 1
77	fi
78
79	if [ ! -d "$3" ]; then
80	  mkdir -p "$3"
81	  if [ $? -ne 0 ]; then
82	    echo "Failed to create Output directory $3"
83	    exit 1
84	  fi
85	fi
86
87
88	current_dir=`pwd`
89
90	cd "$1"
91	project_dir=`pwd`
92
93	cd "$current_dir"
94	cd "$2"
95	common_dir=`pwd`
96
97
98
99	cd "$current_dir"
100	cd "$3"
101	output_dir=`pwd`
102
103
104	cd "$project_dir"/Scripts
105	scripts_dir=`pwd`
106
107
108	cd "$common_dir"/Binary_Keys
109	common_binary_keys_d­ir=`pwd`
110
111
112	cd "$common_dir"/KeysAndImages_Util
113	common_image_dir=`pwd`
114
115
116	cd "$common_dir"/Scripts
117	common_scripts_dir=`pwd`
118
119
120	cd "$common_dir"/Startup
121	common_startup_dir=`pwd`
122
123
124	cd "$current_dir"
125
126
127	echo prebuild.sh : started > "$output_dir"/output.txt
128	asmfile="$common_startup_dir"/se_key.s
129
130	# python is used if  executable not found
131
132	# test if window executable usable
133	prepareimage="$common_image_dir"/win/prepareimage/prepareimage.exe
134	uname  | grep -i -e windows -e mingw > /dev/null 2>&1
135
136
137	if [ $? -eq 0 ] && [  -e "$prepareimage" ]; then
138	  echo "prepareimage with windows executable" >> "$output_dir"/output.txt
139	  echo "prepareimage with windows executable"
140	  cmd=""
141	else
142	  # line for python
143	  echo "prepareimage with python script" >> "$output_dir"/output.txt
144	  echo "prepareimage with python script"
145	  prepareimage="$common_image_dir"/prepareimage.py
146	  unameOut="$(uname -s)"
147	  case "${unameOut}" in
148	    Linux*)     machine=Linux;;
149	    Darwin*)    machine=Mac;;
150	    CYGWIN*)    machine=windows;;
151	    MINGW*)     machine=windows;;
152	    Windows_NT*)  machine=windows;;
153	    *)          machine="UNKNOWN:${unameOut}"
154	    esac
155	  if [ ${machine} == windows ];then
156	    cmd=python
157	  else
158	    cmd=python3
159	  fi
160	fi
161
162
163	echo "$cmd $prepareimage" >> "$output_dir"/output.txt
164	crypto_h="$project_dir"/Application/Core/Inc/se_crypto_config.h
165
166	#clean
167	if [ -e "$output_dir"/crypto.txt ]; then
168	  rm "$output_dir"/crypto.txt
169	fi
170
171	if [ -e "$asmfile" ]; then
172	  rm "$asmfile"
173	fi
174
175	if [ -e "$common_scripts_dir"/postbuild.sh ]; then
176	  rm "$common_scripts_dir"/postbuild.sh
177	fi
178
179
180	#get crypto name
181	command="$cmd \"$prepareimage\" conf \"$crypto_h\""
182	echo "$command"
183	crypto=$(eval $command)
184	echo $crypto > "$output_dir"/crypto.txt
185	echo "$crypto selected">> "$output_dir"/output.txt
186	echo $crypto selected
187	ret=$?
188
189	cortex="V7M"
190	echo "	.section .SE_Key_Data,\"a\",%progbits" > "$asmfile"
191	echo "	.syntax unified" >> "$asmfile"
192	echo "	.thumb " >> "$asmfile"
193
194
195	# AES keys part
196	if [ $ret -eq 0 ]; then
197	  type="vide"
198	  if [ "$crypto" = "SECBOOT_AES128_GCM_A­ES128_GCM_AES128_GCM­" ]; then
199	    type="GCM"
200	  fi
201	  if [ "$crypto" = "SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256" ]; then
202	    type="CBC"
203	  fi
204
205	  if [ $type != "vide" ]; then
206	    oemkey="$common_binary_keys_d­ir"/OEM_KEY_COMPANY1_key­_AES_$type.bin
207	    command="$cmd \"$prepareimage\" trans -a GNU -k $oemkey -f SE_ReadKey_1 -v $cortex"
208	    echo "$command"
209	    $cmd "$prepareimage" trans -a GNU -k "$oemkey" -f SE_ReadKey_1 -v $cortex >> "$asmfile"
210	    ret=$?
211
212	    if [ $ret -eq 0 ]; then
213	      oemkey="$common_binary_keys_d­ir"/OEM_KEY_COMPANY2_key­_AES_$type.bin
214	      if [ -e "$oemkey" ]; then
215	        command="$cmd \"$prepareimage\" trans -a GNU -k $oemkey -f SE_ReadKey_2 -v $cortex"
216	        echo "$command"
217	        $cmd "$prepareimage" trans -a GNU -k $oemkey -f SE_ReadKey_2 -v $cortex >> "$asmfile"
218	        ret=$?
219	      fi
220	    fi
221
222	    if [ $ret -eq 0 ]; then
223	        oemkey="$common_binary_keys_d­ir"/OEM_KEY_COMPANY3_key­_AES_$type.bin
224	        if [ -e "$oemkey" ]; then
225	            command="$cmd \"$prepareimage\" trans -a GNU -k $oemkey -f SE_ReadKey_3 -v $cortex"
226	            echo "$command"
227	            $cmd "$prepareimage" trans -a GNU -k $oemkey -f SE_ReadKey_3 -v $cortex >> "$asmfile"
228	            ret=$?
229	        fi
230	    fi
231	  fi
232	fi
233
234
235	# ECC keys part
236	if [ $ret -eq 0 ]; then
237	  type="vide"
238	  if [ "$crypto" = "SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256" ]; then
239	    type="ECC"
240	  fi
241	  if [ "$crypto" = "SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256" ]; then
242	    type="ECC"
243	  fi
244
245	  if [ $type != "vide" ]; then
246	    ecckey="$common_binary_keys_d­ir"/ECCKEY1.txt
247	    command="$cmd \"$prepareimage\" trans  -a GNU -k \"$ecckey\" -f SE_ReadKey_1_Pub -v $cortex"
248	    echo "$command"
249	    $cmd "$prepareimage" trans  -a GNU -k "$ecckey" -f SE_ReadKey_1_Pub -v $cortex >> "$asmfile"
250	    ret=$?
251
252	    if [ $ret -eq 0 ]; then
253	      ecckey="$common_binary_keys_d­ir"/ECCKEY2.txt
254	      if [ -e "$ecckey" ]; then
255	        command="$cmd \"$prepareimage\" trans  -a GNU -k \"$ecckey\" -f SE_ReadKey_2_Pub -v $cortex"
256	        echo "$command"
257	        $cmd "$prepareimage" trans  -a GNU -k "$ecckey" -f SE_ReadKey_2_Pub -v $cortex >> "$asmfile"
258	        ret=$?
259	      fi
260	    fi
261
262	    if [ $ret -eq 0 ]; then
263	      ecckey="$common_binary_keys_d­ir"/ECCKEY3.txt
264	      if [ -e "$ecckey" ]; then
265	        command="$cmd \"$prepareimage\" trans  -a GNU -k \"$ecckey\" -f SE_ReadKey_3_Pub -v $cortex"
266	        echo "$command"
267	        $cmd "$prepareimage" trans  -a GNU -k "$ecckey" -f SE_ReadKey_3_Pub -v $cortex >> "$asmfile"
268	        ret=$?
269	      fi
270	    fi
271	  fi
272	fi
273	echo "    .end" >> "$asmfile"
274
275	if [ $ret -eq 0 ]; then
276	#no error recopy post build script
277	    uname  | grep -i -e windows -e mingw > /dev/null 2>&1
278	    if [ $? -eq 0 ]; then
279	        echo "recopy postbuild.sh script with "$crypto".sh script"
280	        command="cat \"$scripts_dir\"/\"$crypto.sh\""
281	        echo "$command"
282	        cat "$scripts_dir"/"$crypto.sh" > "$common_scripts_dir"/postbuild.sh
283	        ret=$?
284	    else
285	        echo "create symbolic link postbuild.sh to "$crypto".sh"
286	        command="ln -s \"$scripts_dir\"/\"$crypto.sh\" \"$common_scripts_dir\"/postbuild.sh"
287	        echo "$command"
288	        ln -s "$scripts_dir"/"$crypto.sh" "$common_scripts_dir"/postbuild.sh
289	        ret=$?
290	    fi
291	fi
292
293	if [ $ret != 0 ]; then
294	#an error
295	echo "$command" : failed >> "$output_dir"/output.txt
296	echo "$command" : failed
297	read -n 1 -s
298	exit 1
299	fi
300	exit 0
301
L476_SBSFU\SECoreBin\Scripts\SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM.sh
1	#!/bin/bash -
2	#Post build for SECBOOT_AES128_GCM_W­ITH_AES128_GCM
3	# arg1 is the build directory
4	# arg2 is the elf file path+name
5	# arg3 is the bin file path+name
6	# arg4 is the firmware Id (1/2/3)
7	# arg5 is the version
8	# arg6 when present forces "bigelf" generation
9
10
11	projectdir=$1
12	FileName=${3##*/}
13	execname=${FileName%.*}
14	elf=$2
15	bin=$3
16	fwid=$4
17	version=$5
18
19	SecureEngine=${0%/*}
20
21	userAppBinary=$projectdir"/../Binary"
22
23	sfu=$userAppBinary"/"$execname".sfu"
24	sfb=$userAppBinary"/"$execname".sfb"
25	sign=$userAppBinary"/"%execname".sign"
26	headerbin=$userAppBinary"/"$execname"sfuh.bin"
27	bigbinary=$userAppBinary"/SBSFU_"$execname".bin"
28	elfbackup=$userAppBinary"/SBSFU_"$execname".elf"
29
30	nonce=$SecureEngine"/../Binary/nonce.bin"
31	magic="SFU"$fwid
32	oemkey=$SecureEngine"/../Binary/OEM_KEY_COMPANY"$fwid"_key_AES_GCM.bin"
33	partialbin=$userAppBinary"/Partial"$execname".bin"
34	partialsfb=$userAppBinary"/Partial"$execname".sfb"
35	partialsfu=$userAppBinary"/Partial"$execname".sfu"
36	partialsign=$userAppBinary"/Partial"$execname".sign"
37	partialoffset=$userAppBinary"/Partial"$execname".offset"
38	ref_userapp=$projectdir"/RefUserApp.bin"
39	offset=512
40	alignment=16
41
42	current_directory=`pwd`
43	cd "$SecureEngine/../../"
44	SecureDir=`pwd`
45	cd "$current_directory"
46	sbsfuelf="$SecureDir/2_Images_SBSFU/STM32CubeIDE/Debug/SBSFU.elf"
47	current_directory=`pwd`
48	cd "$1/../../../../../../Middlewares/ST/STM32_Secure_Engine/Utilities/KeysAndImages"
49	basedir=`pwd`
50	cd "$current_directory"
51	# test if window executable usable
52	prepareimage=$basedir"/win/prepareimage/prepareimage.exe"
53	uname | grep -i -e windows -e mingw >/dev/null > /dev/null 2>&1
54	if [ $? -eq 0 ] && [  -e "$prepareimage" ]; then
55	  echo "prepareimage with windows executable"
56	  PATH=$basedir"\\win\\prepareimage":$PATH > /dev/null 2>&1
57	  cmd=""
58	  prepareimage="prepareimage.exe"
59	else
60	  # line for python
61	  echo "prepareimage with python script"
62	  prepareimage=$basedir/prepareimage.py
63	  cmd="python"
64	fi
65
66	# Make sure we have a Binary sub-folder in UserApp folder
67	if [ ! -e $userAppBinary ]; then
68	mkdir $userAppBinary
69	fi
70
71	command=$cmd" "$prepareimage" enc -k "$oemkey" -n "$nonce" "$bin" "$sfu
72	$command > $projectdir"/output.txt"
73	ret=$?
74	if [ $ret -eq 0 ]; then
75	  command=$cmd" "$prepareimage" sign -k "$oemkey" -n "$nonce" "$bin" "$sign
76	  $command >> $projectdir"/output.txt"
77	  ret=$?
78	  if [ $ret -eq 0 ]; then
79	    command=$cmd" "$prepareimage" pack -m "$magic" -k "$oemkey"  -r 112 -v "$version" -n "$nonce" -f "$sfu" -t "$sign" "$sfb" -o "$offset
80	    $command >> $projectdir"/output.txt"
81	    ret=$?
82	    if [ $ret -eq 0 ]; then
83	      command=$cmd" "$prepareimage" header -m "$magic" -k  "$oemkey" -r 112 -v "$version"  -n "$nonce" -f "$sfu" -t "$sign" -o "$offset" "$headerbin
84	      $command >> $projectdir"/output.txt"
85	      ret=$?
86	      if [ $ret -eq 0 ]; then
87	        command=$cmd" "$prepareimage" merge -v 0 -e 1 -i "$headerbin" -s "$sbsfuelf" -u "$elf" "$bigbinary
88	        $command >> $projectdir"/output.txt"
89	        ret=$?
90	        #Partial image generation if reference userapp exists
91	        if [ $ret -eq 0 ] && [ -e "$ref_userapp" ]; then
92	          echo "Generating the partial image .sfb"
93	          echo "Generating the partial image .sfb" >> $projectdir"/output.txt"
94	          command=$cmd" "$prepareimage" diff -1 "$ref_userapp" -2 "$bin" "$partialbin" -a "$alignment" --poffset "$partialoffset
95	          $command >> $projectdir"/output.txt"
96	          ret=$?
97	          if [ $ret -eq 0 ]; then
98	            command=$cmd" "$prepareimage" enc -k "$oemkey" -i "$nonce" "$partialbin" "$partialsfu
99	            $command >> $projectdir"/output.txt"
100	            ret=$?
101	            if [ $ret -eq 0 ]; then
102	              command=$cmd" "$prepareimage" sign -k "$oemkey" -n "$nonce" "$partialbin" "$partialsign
103	              $command >> $projectdir"/output.txt"
104	              ret=$?
105	              if [ $ret -eq 0 ]; then
106	                command=$cmd" "$prepareimage" pack -m "$magic" -k "$oemkey" -r 112 -v "$version" -i "$nonce" -f "$sfu" -t "$sign" -o "$offset" --pfw "$partialsfu" --ptag "$partialsign" --poffset  "$partialoffset" "$partialsfb
107	                $command >> $projectdir"/output.txt"
108	                ret=$?
109	              fi
110	            fi
111	          fi
112	        fi
113	        if [ $ret -eq 0 ] && [ $# = 6 ]; then
114	          echo "Generating the global elf file SBSFU and userApp"
115	          echo "Generating the global elf file SBSFU and userApp" >> $projectdir"/output.txt"
116	          uname | grep -i -e windows -e mingw > /dev/null 2>&1
117	          if [ $? -eq 0 ]; then
118	            # Set to the default installation path of the Cube Programmer tool
119	            # If you installed it in another location, please update PATH.
120	            PATH="C:\\Program Files (x86)\\STMicroelectronics\\STM32Cube\\STM32CubeProgrammer\\bin":$PATH > /dev/null 2>&1
121	            programmertool="STM32_Programmer_CLI­.exe"
122	          else
123	            which STM32_Programmer_CLI­ > /dev/null
124	            if [ $? = 0 ]; then
125	              programmertool="STM32_Programmer_CLI­"
126	            else
127	              echo "fix access path to STM32_Programmer_CLI­"
128	            fi
129	          fi
130	          command=$programmertool" -ms "$elf" "$headerbin" "$sbsfuelf
131	          $command >> $projectdir"/output.txt"
132	          ret=$?
133	        fi
134	      fi
135	    fi
136	  fi
137	fi
138
139
140	if [ $ret -eq 0 ]; then
141	  rm $sign
142	  rm $sfu
143	  rm $headerbin
144	  if [ -e "$ref_userapp" ]; then
145	    rm $partialbin
146	    rm $partialsfu
147	    rm $partialsign
148	    rm $partialoffset
149	  fi
150	  exit 0
151	else
152	  echo "$command : failed" >> $projectdir"/output.txt"
153	  if [ -e  "$elf" ]; then
154	    rm  $elf
155	  fi
156	  if [ -e "$elfbackup" ]; then
157	    rm  $elfbackup
158	  fi
159	  echo $command : failed
160	  read -n 1 -s
161	  exit 1
162	fi
163
L476_SBSFU\SECoreBin\Scripts\SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256.sh
1	#!/bin/bash -
2	#Post build for SECBOOT_ECCDSA_WITH_­AES128_CBC_SHA256
3	# arg1 is the build directory
4	# arg2 is the elf file path+name
5	# arg3 is the bin file path+name
6	# arg4 is the firmware Id (1/2/3)
7	# arg5 is the version
8	# arg6 when present forces "bigelf" generation
9	projectdir=$1
10	FileName=${3##*/}
11	execname=${FileName%.*}
12	elf=$2
13	bin=$3
14	fwid=$4
15	version=$5
16
17	SecureEngine=${0%/*}
18
19	userAppBinary=$projectdir"/../Binary"
20
21	sfu=$userAppBinary"/"$execname".sfu"
22	sfb=$userAppBinary"/"$execname".sfb"
23	sign=$userAppBinary"/"$execname".sign"
24	headerbin=$userAppBinary"/"$execname"sfuh.bin"
25	bigbinary=$userAppBinary"/SBSFU_"$execname".bin"
26
27	iv=$SecureEngine"/../Binary/iv.bin"
28	magic="SFU"$fwid
29	oemkey=$SecureEngine"/../Binary/OEM_KEY_COMPANY"$fwid"_key_AES_CBC.bin"
30	ecckey=$SecureEngine"/../Binary/ECCKEY"$fwid".txt"
31	partialbin=$userAppBinary"/Partial"$execname".bin"
32	partialsfb=$userAppBinary"/Partial"$execname".sfb"
33	partialsfu=$userAppBinary"/Partial"$execname".sfu"
34	partialsign=$userAppBinary"/Partial"$execname".sign"
35	partialoffset=$userAppBinary"/Partial"$execname".offset"
36	ref_userapp=$projectdir"/RefUserApp.bin"
37	offset=512
38	alignment=16
39
40	current_directory=`pwd`
41	cd "$SecureEngine/../../"
42	SecureDir=`pwd`
43	cd "$current_directory"
44	sbsfuelf="$SecureDir/2_Images_SBSFU/STM32CubeIDE/Debug/SBSFU.elf"
45
46	current_directory=`pwd`
47	cd "$1/../../../../../../Middlewares/ST/STM32_Secure_Engine/Utilities/KeysAndImages"
48	basedir=`pwd`
49	cd "$current_directory"
50	# test if window executable usable
51	prepareimage=$basedir"/win/prepareimage/prepareimage.exe"
52	uname | grep -i -e windows -e mingw > /dev/null 2>&1
53
54	if [ $? -eq 0 ] && [   -e "$prepareimage" ]; then
55	  echo "prepareimage with windows executable"
56	  PATH=$basedir"\\win\\prepareimage":$PATH > /dev/null 2>&1
57	  cmd=""
58	  prepareimage="prepareimage.exe"
59	else
60	  # line for python
61	  echo "prepareimage with python script"
62	  prepareimage=$basedir/prepareimage.py
63	  cmd="python"
64	fi
65
66	echo "$cmd $prepareimage" >> $1/output.txt
67	# Make sure we have a Binary sub-folder in UserApp folder
68	if [ ! -e $userAppBinary ]; then
69	mkdir $userAppBinary
70	fi
71
72
73	command=$cmd" "$prepareimage" enc -k "$oemkey" -i "$iv" "$bin" "$sfu
74	$command > "$projectdir"/output.txt
75	ret=$?
76	if [ $ret -eq 0 ]; then
77	  command=$cmd" "$prepareimage" sha256 "$bin" "$sign
78	  $command >> $projectdir"/output.txt"
79	  ret=$?
80	  if [ $ret -eq 0 ]; then
81	    command=$cmd" "$prepareimage" pack -m "$magic" -k "$ecckey" -r 28 -v "$version" -i "$iv" -f "$sfu" -t "$sign" "$sfb" -o "$offset
82	    $command >> $projectdir"/output.txt"
83	    ret=$?
84	    if [ $ret -eq 0 ]; then
85	      command=$cmd" "$prepareimage" header -m "$magic" -k  "$ecckey" -r 28 -v "$version"  -i "$iv" -f "$sfu" -t "$sign" -o "$offset" "$headerbin
86	      $command >> $projectdir"/output.txt"
87	      ret=$?
88	      if [ $ret -eq 0 ]; then
89	        command=$cmd" "$prepareimage" merge -v 0 -e 1 -i "$headerbin" -s "$sbsfuelf" -u "$elf" "$bigbinary
90	        $command >> $projectdir"/output.txt"
91	        ret=$?
92	        #Partial image generation if reference userapp exists
93	        if [ $ret -eq 0 ] && [ -e "$ref_userapp" ]; then
94	          echo "Generating the partial image .sfb"
95	          echo "Generating the partial image .sfb" >> $projectdir"/output.txt"
96	          command=$cmd" "$prepareimage" diff -1 "$ref_userapp" -2 "$bin" "$partialbin" -a "$alignment" --poffset "$partialoffset
97	          $command >> $projectdir"/output.txt"
98	          ret=$?
99	          if [ $ret -eq 0 ]; then
100	            command=$cmd" "$prepareimage" enc -k "$oemkey" -i "$iv" "$partialbin" "$partialsfu
101	            $command >> $projectdir"/output.txt"
102	            ret=$?
103	            if [ $ret -eq 0 ]; then
104	              command=$cmd" "$prepareimage" sha256 "$partialbin" "$partialsign
105	              $command >> $projectdir"/output.txt"
106	              ret=$?
107	              if [ $ret -eq 0 ]; then
108	                command=$cmd" "$prepareimage" pack -m "$magic" -k "$ecckey" -r 28 -v "$version" -i "$iv" -f "$sfu" -t "$sign" -o "$offset" --pfw "$partialsfu" --ptag "$partialsign" --poffset  "$partialoffset" "$partialsfb
109	                $command >> $projectdir"/output.txt"
110	                ret=$?
111	              fi
112	            fi
113	          fi
114	        fi
115	        if [ $ret -eq 0 ] && [ $# = 6 ]; then
116	          echo "Generating the global elf file SBSFU and userApp"
117	          echo "Generating the global elf file SBSFU and userApp" >> $projectdir"/output.txt"
118	          uname | grep -i -e windows -e mingw > /dev/null 2>&1
119	          if [ $? -eq 0 ]; then
120	            # Set to the default installation path of the Cube Programmer tool
121	            # If you installed it in another location, please update PATH.
122	            PATH="C:\\Program Files (x86)\\STMicroelectronics\\STM32Cube\\STM32CubeProgrammer\\bin":$PATH > /dev/null 2>&1
123	            programmertool="STM32_Programmer_CLI­.exe"
124	          else
125	            which STM32_Programmer_CLI­ > /dev/null
126	            if [ $? = 0 ]; then
127	              programmertool="STM32_Programmer_CLI­"
128	            else
129	              echo "fix access path to STM32_Programmer_CLI­"
130	            fi
131	          fi
132	          command=$programmertool" -ms "$elf" "$headerbin" "$sbsfuelf
133	          $command >> $projectdir"/output.txt"
134	          ret=$?
135	        fi
136	      fi
137	    fi
138	  fi
139	fi
140
141	if [ $ret -eq 0 ]; then
142	  rm $sign
143	  rm $sfu
144	  rm $headerbin
145	  if [ -e "$ref_userapp" ]; then
146	    rm $partialbin
147	    rm $partialsfu
148	    rm $partialsign
149	    rm $partialoffset
150	  fi
151	  exit 0
152	else
153	  echo "$command : failed" >> $projectdir"/output.txt"
154	  if [ -e  "$elf" ]; then
155	    rm  $elf
156	  fi
157	  if [ -e "$elfbackup" ]; then
158	    rm  $elfbackup
159	  fi
160	  echo $command : failed
161	  read -n 1 -s
162	  exit 1
163	fi
164
L476_SBSFU\SECoreBin\Scripts\SECBOOT_ECCDSA_WITHOUT_ENCRYPT_SHA256.sh
1	#!/bin/bash -
2	#Post build for SECBOOT_ECCDSA_WITHO­UT_ENCRYPT_SHA256
3	# arg1 is the build directory
4	# arg2 is the elf file path+name
5	# arg3 is the bin file path+name
6	# arg4 is the firmware Id (1/2/3)
7	# arg5 is the version
8	# arg6 when present forces "bigelf" generation
9	projectdir=$1
10	FileName=${3##*/}
11	execname=${FileName%.*}
12	elf=$2
13	bin=$3
14	fwid=$4
15	version=$5
16
17	SecureEngine=${0%/*}
18
19	userAppBinary=$projectdir"/../Binary"
20
21	sfb=$userAppBinary"/"$execname".sfb"
22	sign=$userAppBinary"/"$execname".sign"
23	headerbin=$userAppBinary"/"$execname"sfuh.bin"
24	bigbinary=$userAppBinary"/SBSFU_"$execname".bin"
25	magic="SFU"$fwid
26	ecckey=$SecureEngine"/../Binary/ECCKEY"$fwid".txt"
27	partialbin=$userAppBinary"/Partial"$execname".bin"
28	partialsfb=$userAppBinary"/Partial"$execname".sfb"
29	partialsign=$userAppBinary"/Partial"$execname".sign"
30	partialoffset=$userAppBinary"/Partial"$execname".offset"
31	ref_userapp=$projectdir"/RefUserApp.bin"
32	offset=512
33	alignment=16
34
35	current_directory=`pwd`
36	cd "$SecureEngine/../../"
37	SecureDir=`pwd`
38	cd "$current_directory"
39	sbsfuelf="$SecureDir/2_Images_SBSFU/STM32CubeIDE/Debug/SBSFU.elf"
40
41	current_directory=`pwd`
42	cd "$1/../../../../../../Middlewares/ST/STM32_Secure_Engine/Utilities/KeysAndImages"
43	basedir=`pwd`
44	cd "$current_directory"
45	# test if window executable usable
46	prepareimage=$basedir"/win/prepareimage/prepareimage.exe"
47	uname  | grep -i -e windows -e mingw > /dev/null 2>&1
48	if [ $? -eq 0 ] && [  -e "$prepareimage" ]; then
49	  echo "prepareimage with windows executable"
50	  PATH=$basedir"\\win\\prepareimage":$PATH > /dev/null 2>&1
51	  cmd=""
52	  prepareimage="prepareimage.exe"
53	else
54	  # line for python
55	  echo "prepareimage with python script"
56	  prepareimage=$basedir/prepareimage.py
57	  cmd="python"
58	fi
59
60	echo "$cmd $prepareimage" >> $1/output.txt
61	# Make sure we have a Binary sub-folder in UserApp folder
62	if [ ! -e $userAppBinary ]; then
63	mkdir $userAppBinary
64	fi
65
66
67
68	command=$cmd" "$prepareimage" sha256 "$bin" "$sign
69	$command >> $projectdir"/output.txt"
70	ret=$?
71	if [ $ret -eq 0 ]; then
72	  command=$cmd" "$prepareimage" pack -m "$magic" -k "$ecckey" -p 1 -r 44 -v "$version" -f "$bin" -t "$sign" "$sfb" -o "$offset
73	  $command >> $projectdir"/output.txt"
74	  ret=$?
75	  if [ $ret -eq 0 ]; then
76	    command=$cmd" "$prepareimage" header -m "$magic" -k  "$ecckey"  -p 1 -r 44 -v "$version"  -f "$bin" -t "$sign" -o "$offset" "$headerbin
77	    $command >> $projectdir"/output.txt"
78	    ret=$?
79	    if [ $ret -eq 0 ]; then
80	      command=$cmd" "$prepareimage" merge -v 0 -e 1 -i "$headerbin" -s "$sbsfuelf" -u "$elf" "$bigbinary
81	      $command >> $projectdir"/output.txt"
82	      ret=$?
83	      #Partial image generation if reference userapp exists
84	      if [ $ret -eq 0 ] && [ -e "$ref_userapp" ]; then
85	        echo "Generating the partial image .sfb"
86	        echo "Generating the partial image .sfb" >> $projectdir"/output.txt"
87	        command=$cmd" "$prepareimage" diff -1 "$ref_userapp" -2 "$bin" "$partialbin" -a "$alignment" --poffset "$partialoffset
88	        $command >> $projectdir"/output.txt"
89	        ret=$?
90	        if [ $ret -eq 0 ]; then
91	          command=$cmd" "$prepareimage" sha256 "$partialbin" "$partialsign
92	          $command >> $projectdir"/output.txt"
93	          ret=$?
94	          if [ $ret -eq 0 ]; then
95	            command=$cmd" "$prepareimage" pack -m "$magic" -k "$ecckey" -p 1 -r 44 -v "$version" -f "$bin" -t "$sign" -o "$offset" --pfw "$partialbin" --ptag "$partialsign" --poffset  "$partialoffset" "$partialsfb
96	            $command >> $projectdir"/output.txt"
97	            ret=$?
98	          fi
99	        fi
100	      fi
101	      if [ $ret -eq 0 ] && [ $# = 6 ]; then
102	        echo "Generating the global elf file (SBSFU and userApp)"
103	        echo "Generating the global elf file (SBSFU and userApp)" >> $projectdir"/output.txt"
104	        uname | grep -i -e windows -e mingw > /dev/null 2>&1
105	        if [ $? -eq 0 ]; then
106	          # Set to the default installation path of the Cube Programmer tool
107	          # If you installed it in another location, please update PATH.
108	          PATH="C:\\Program Files (x86)\\STMicroelectronics\\STM32Cube\\STM32CubeProgrammer\\bin":$PATH > /dev/null 2>&1
109	          programmertool="STM32_Programmer_CLI­.exe"
110	        else
111	          which STM32_Programmer_CLI­ > /dev/null
112	          if [ $? = 0 ]; then
113	            programmertool="STM32_Programmer_CLI­"
114	          else
115	            echo "fix access path to STM32_Programmer_CLI­"
116	          fi
117	        fi
118	        command=$programmertool" -ms "$elf" "$headerbin" "$sbsfuelf
119	        $command >> $projectdir"/output.txt"
120	        ret=$?
121	      fi
122	    fi
123	  fi
124	fi
125
126
127
128	exit 1
129
130	if [ $ret -eq 0 ]; then
131	  rm $sign
132	  rm $headerbin
133	  if [ -e "$ref_userapp" ]; then
134	    rm $partialbin
135	    rm $partialsign
136	    rm $partialoffset
137	  fi
138	  exit 0
139	else
140	  echo "$command : failed" >> $projectdir"/output.txt"
141	  if [ -e  "$elf" ]; then
142	    rm  $elf
143	  fi
144	  if [ -e "$elfbackup" ]; then
145	    rm  $elfbackup
146	  fi
147	  echo $command : failed
148	  read -n 1 -s
149	  exit 1
150	fi
151
L476_SBSFU\SECoreBin\Startup\se_key.s

	.section .SE_Key_Data,"a",%progbits
	.syntax unified
	.thumb
	.global SE_ReadKey_1
SE_ReadKey_1:
	PUSH {R1-R5}
	MOVW R1, #0x454f
	MOVT R1, #0x5f4d
	MOVW R2, #0x454b
	MOVT R2, #0x5f59
	MOVW R3, #0x4f43
	MOVT R3, #0x504d
	MOVW R4, #0x4e41
	MOVT R4, #0x3159
	STM R0, {R1-R4}
	POP {R1-R5}
	BX LR

    .end

L476_SBSFU\SECoreBin\Startup\startup_stm32l476xx.s

/**
  ******************************************************************************
  * @file      startup_stm32l476xx.s
  * @author    MCD Application Team
  * @brief     STM32L476xx devices vector table GCC toolchain.
  *            This module performs:
  *                - Set the initial SP
  *                - Set the initial PC == Reset_Handler,
  *                - Set the vector table entries with the exceptions ISR address,
  *                - Configure the clock system
  *                - Branches to main in the C library (which eventually
  *                  calls main()).
  *            After Reset the Cortex-M4 processor is in Thread mode,
  *            priority is Privileged, and the Stack is set to Main.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

  .syntax unified
	.cpu cortex-m4
	.fpu softvfp
	.thumb

.global	g_pfnVectors
.global	Default_Handler

/* start address for the initialization values of the .data section.
defined in linker script */
.word	_sidata
/* start address for the .data section. defined in linker script */
.word	_sdata
/* end address for the .data section. defined in linker script */
.word	_edata
/* start address for the .bss section. defined in linker script */
.word	_sbss
/* end address for the .bss section. defined in linker script */
.word	_ebss

.equ  BootRAM,        0xF1E0F85F
/**
 * @brief  This is the code that gets called when the processor first
 *          starts execution following a reset event. Only the absolutely
 *          necessary set is performed, after which the application
 *          supplied main() routine is called.
 * @param  None
 * @retval : None
*/

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
    Infinite_Loop:
	b	Infinite_Loop
    .size	Reset_Handler, .-Reset_Handler

    //ldr   sp, =_estack    /* Atollic update: set stack pointer */

/* Copy the data segment initializers from flash to SRAM */
 /*  movs	r1, #0
  b	LoopCopyDataInit

/* CopyDataInit:
	ldr	r3, =_sidata
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

/* LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
	b	LoopFillZerobss
/* Zero fill the bss segment. */
  /* ldr   sp, =_estack    /* Atollic update: set stack pointer */

/* Copy the data segment initializers from flash to SRAM */
  /* movs	r1, #0
  b	LoopCopyDataInit

/* CopyDataInit:
	ldr	r3, =_sidata
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

/* LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
	b	LoopFillZerobss
/* Zero fill the bss segment. */
/* FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

/* LoopFillZerobss:
	ldr	r3, = _ebss
	cmp	r2, r3
	bcc	FillZerobss

/* Call the clock system initialization function.*/
    //bl  SystemInit
/* Call static constructors */
    //bl __libc_init_array
/* Call the application entry point.*/
	//bl	main

/* LoopForever:
    b LoopForever

.size	Reset_Handler, .-Reset_Handler*/

/**
 * @brief  This is the code that gets called when the processor receives an
 *         unexpected interrupt.  This simply enters an infinite loop, preserving
 *         the system state for examination by a debugger.
 *
 * @param  None
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
/*Infinite_Loop:*/
	b	Infinite_Loop
	.size	Default_Handler, .-Default_Handler
/******************************************************************************
*
* The minimal vector table for a Cortex-M4.  Note that the proper constructs
* must be placed on this to ensure that it ends up at physical address
* 0x0000.0000.
*
******************************************************************************/
 	.section	.isr_vector,"a",%progbits
	.type	g_pfnVectors, %object
	.size	g_pfnVectors, .-g_pfnVectors


g_pfnVectors:
	.word	0
	.word	Reset_Handler
	.word	NMI_Handler
	.word	HardFault_Handler
	.word	MemManage_Handler
	.word	BusFault_Handler
	.word	UsageFault_Handler
	.word	0
	.word	0
	.word	0
	.word	0
	.word	SVC_Handler
	.word	DebugMon_Handler
	.word	0
	.word	PendSV_Handler
	.word	SysTick_Handler
	.word	WWDG_IRQHandler
	.word	PVD_PVM_IRQHandler
	.word	TAMP_STAMP_IRQHandler
	.word	RTC_WKUP_IRQHandler
	.word	FLASH_IRQHandler
	.word	RCC_IRQHandler
	.word	EXTI0_IRQHandler
	.word	EXTI1_IRQHandler
	.word	EXTI2_IRQHandler
	.word	EXTI3_IRQHandler
	.word	EXTI4_IRQHandler
	.word	DMA1_Channel1_IRQHandler
	.word	DMA1_Channel2_IRQHandler
	.word	DMA1_Channel3_IRQHandler
	.word	DMA1_Channel4_IRQHandler
	.word	DMA1_Channel5_IRQHandler
	.word	DMA1_Channel6_IRQHandler
	.word	DMA1_Channel7_IRQHandler
	.word	ADC1_2_IRQHandler
	.word	CAN1_TX_IRQHandler
	.word	CAN1_RX0_IRQHandler
	.word	CAN1_RX1_IRQHandler
	.word	CAN1_SCE_IRQHandler
	.word	EXTI9_5_IRQHandler
	.word	TIM1_BRK_TIM15_IRQHandler
	.word	TIM1_UP_TIM16_IRQHandler
	.word	TIM1_TRG_COM_TIM17_IRQHandler
	.word	TIM1_CC_IRQHandler
	.word	TIM2_IRQHandler
	.word	TIM3_IRQHandler
	.word	TIM4_IRQHandler
	.word	I2C1_EV_IRQHandler
	.word	I2C1_ER_IRQHandler
	.word	I2C2_EV_IRQHandler
	.word	I2C2_ER_IRQHandler
	.word	SPI1_IRQHandler
	.word	SPI2_IRQHandler
	.word	USART1_IRQHandler
	.word	USART2_IRQHandler
	.word	USART3_IRQHandler
	.word	EXTI15_10_IRQHandler
	.word	RTC_Alarm_IRQHandler
	.word	DFSDM1_FLT3_IRQHandler
	.word	TIM8_BRK_IRQHandler
	.word	TIM8_UP_IRQHandler
	.word	TIM8_TRG_COM_IRQHandler
	.word	TIM8_CC_IRQHandler
	.word	ADC3_IRQHandler
	.word	FMC_IRQHandler
	.word	SDMMC1_IRQHandler
	.word	TIM5_IRQHandler
	.word	SPI3_IRQHandler
	.word	UART4_IRQHandler
	.word	UART5_IRQHandler
	.word	TIM6_DAC_IRQHandler
	.word	TIM7_IRQHandler
	.word	DMA2_Channel1_IRQHandler
	.word	DMA2_Channel2_IRQHandler
	.word	DMA2_Channel3_IRQHandler
	.word	DMA2_Channel4_IRQHandler
	.word	DMA2_Channel5_IRQHandler
	.word	DFSDM1_FLT0_IRQHandler
	.word	DFSDM1_FLT1_IRQHandler
	.word	DFSDM1_FLT2_IRQHandler
	.word	COMP_IRQHandler
	.word	LPTIM1_IRQHandler
	.word	LPTIM2_IRQHandler
	.word	OTG_FS_IRQHandler
	.word	DMA2_Channel6_IRQHandler
	.word	DMA2_Channel7_IRQHandler
	.word	LPUART1_IRQHandler
	.word	QUADSPI_IRQHandler
	.word	I2C3_EV_IRQHandler
	.word	I2C3_ER_IRQHandler
	.word	SAI1_IRQHandler
	.word	SAI2_IRQHandler
	.word	SWPMI1_IRQHandler
	.word	TSC_IRQHandler
	.word	LCD_IRQHandler
	.word 0
	.word	RNG_IRQHandler
	.word	FPU_IRQHandler


/*******************************************************************************
*
* Provide weak aliases for each Exception handler to the Default_Handler.
* As they are weak aliases, any function with the same name will override
* this definition.
*
*******************************************************************************/

  .weak	NMI_Handler
	.thumb_set NMI_Handler,Default_Handler

  .weak	HardFault_Handler
	.thumb_set HardFault_Handler,Default_Handler

  .weak	MemManage_Handler
	.thumb_set MemManage_Handler,Default_Handler

  .weak	BusFault_Handler
	.thumb_set BusFault_Handler,Default_Handler

	.weak	UsageFault_Handler
	.thumb_set UsageFault_Handler,Default_Handler

	.weak	SVC_Handler
	.thumb_set SVC_Handler,Default_Handler

	.weak	DebugMon_Handler
	.thumb_set DebugMon_Handler,Default_Handler

	.weak	PendSV_Handler
	.thumb_set PendSV_Handler,Default_Handler

	.weak	SysTick_Handler
	.thumb_set SysTick_Handler,Default_Handler

	.weak	WWDG_IRQHandler
	.thumb_set WWDG_IRQHandler,Default_Handler

	.weak	PVD_PVM_IRQHandler
	.thumb_set PVD_PVM_IRQHandler,Default_Handler

	.weak	TAMP_STAMP_IRQHandler
	.thumb_set TAMP_STAMP_IRQHandler,Default_Handler

	.weak	RTC_WKUP_IRQHandler
	.thumb_set RTC_WKUP_IRQHandler,Default_Handler

	.weak	FLASH_IRQHandler
	.thumb_set FLASH_IRQHandler,Default_Handler

	.weak	RCC_IRQHandler
	.thumb_set RCC_IRQHandler,Default_Handler

	.weak	EXTI0_IRQHandler
	.thumb_set EXTI0_IRQHandler,Default_Handler

	.weak	EXTI1_IRQHandler
	.thumb_set EXTI1_IRQHandler,Default_Handler

	.weak	EXTI2_IRQHandler
	.thumb_set EXTI2_IRQHandler,Default_Handler

	.weak	EXTI3_IRQHandler
	.thumb_set EXTI3_IRQHandler,Default_Handler

	.weak	EXTI4_IRQHandler
	.thumb_set EXTI4_IRQHandler,Default_Handler

	.weak	DMA1_Channel1_IRQHandler
	.thumb_set DMA1_Channel1_IRQHandler,Default_Handler

	.weak	DMA1_Channel2_IRQHandler
	.thumb_set DMA1_Channel2_IRQHandler,Default_Handler

	.weak	DMA1_Channel3_IRQHandler
	.thumb_set DMA1_Channel3_IRQHandler,Default_Handler

	.weak	DMA1_Channel4_IRQHandler
	.thumb_set DMA1_Channel4_IRQHandler,Default_Handler

	.weak	DMA1_Channel5_IRQHandler
	.thumb_set DMA1_Channel5_IRQHandler,Default_Handler

	.weak	DMA1_Channel6_IRQHandler
	.thumb_set DMA1_Channel6_IRQHandler,Default_Handler

	.weak	DMA1_Channel7_IRQHandler
	.thumb_set DMA1_Channel7_IRQHandler,Default_Handler

	.weak	ADC1_2_IRQHandler
	.thumb_set ADC1_2_IRQHandler,Default_Handler

	.weak	CAN1_TX_IRQHandler
	.thumb_set CAN1_TX_IRQHandler,Default_Handler

	.weak	CAN1_RX0_IRQHandler
	.thumb_set CAN1_RX0_IRQHandler,Default_Handler

	.weak	CAN1_RX1_IRQHandler
	.thumb_set CAN1_RX1_IRQHandler,Default_Handler

	.weak	CAN1_SCE_IRQHandler
	.thumb_set CAN1_SCE_IRQHandler,Default_Handler

	.weak	EXTI9_5_IRQHandler
	.thumb_set EXTI9_5_IRQHandler,Default_Handler

	.weak	TIM1_BRK_TIM15_IRQHandler
	.thumb_set TIM1_BRK_TIM15_IRQHandler,Default_Handler

	.weak	TIM1_UP_TIM16_IRQHandler
	.thumb_set TIM1_UP_TIM16_IRQHandler,Default_Handler

	.weak	TIM1_TRG_COM_TIM17_IRQHandler
	.thumb_set TIM1_TRG_COM_TIM17_IRQHandler,Default_Handler

	.weak	TIM1_CC_IRQHandler
	.thumb_set TIM1_CC_IRQHandler,Default_Handler

	.weak	TIM2_IRQHandler
	.thumb_set TIM2_IRQHandler,Default_Handler

	.weak	TIM3_IRQHandler
	.thumb_set TIM3_IRQHandler,Default_Handler

	.weak	TIM4_IRQHandler
	.thumb_set TIM4_IRQHandler,Default_Handler

	.weak	I2C1_EV_IRQHandler
	.thumb_set I2C1_EV_IRQHandler,Default_Handler

	.weak	I2C1_ER_IRQHandler
	.thumb_set I2C1_ER_IRQHandler,Default_Handler

	.weak	I2C2_EV_IRQHandler
	.thumb_set I2C2_EV_IRQHandler,Default_Handler

	.weak	I2C2_ER_IRQHandler
	.thumb_set I2C2_ER_IRQHandler,Default_Handler

	.weak	SPI1_IRQHandler
	.thumb_set SPI1_IRQHandler,Default_Handler

	.weak	SPI2_IRQHandler
	.thumb_set SPI2_IRQHandler,Default_Handler

	.weak	USART1_IRQHandler
	.thumb_set USART1_IRQHandler,Default_Handler

	.weak	USART2_IRQHandler
	.thumb_set USART2_IRQHandler,Default_Handler

	.weak	USART3_IRQHandler
	.thumb_set USART3_IRQHandler,Default_Handler

	.weak	EXTI15_10_IRQHandler
	.thumb_set EXTI15_10_IRQHandler,Default_Handler

	.weak	RTC_Alarm_IRQHandler
	.thumb_set RTC_Alarm_IRQHandler,Default_Handler

	.weak	DFSDM1_FLT3_IRQHandler
	.thumb_set DFSDM1_FLT3_IRQHandler,Default_Handler

	.weak	TIM8_BRK_IRQHandler
	.thumb_set TIM8_BRK_IRQHandler,Default_Handler

	.weak	TIM8_UP_IRQHandler
	.thumb_set TIM8_UP_IRQHandler,Default_Handler

	.weak	TIM8_TRG_COM_IRQHandler
	.thumb_set TIM8_TRG_COM_IRQHandler,Default_Handler

	.weak	TIM8_CC_IRQHandler
	.thumb_set TIM8_CC_IRQHandler,Default_Handler

	.weak	ADC3_IRQHandler
	.thumb_set ADC3_IRQHandler,Default_Handler

	.weak	FMC_IRQHandler
	.thumb_set FMC_IRQHandler,Default_Handler

	.weak	SDMMC1_IRQHandler
	.thumb_set SDMMC1_IRQHandler,Default_Handler

	.weak	TIM5_IRQHandler
	.thumb_set TIM5_IRQHandler,Default_Handler

	.weak	SPI3_IRQHandler
	.thumb_set SPI3_IRQHandler,Default_Handler

	.weak	UART4_IRQHandler
	.thumb_set UART4_IRQHandler,Default_Handler

	.weak	UART5_IRQHandler
	.thumb_set UART5_IRQHandler,Default_Handler

	.weak	TIM6_DAC_IRQHandler
	.thumb_set TIM6_DAC_IRQHandler,Default_Handler

	.weak	TIM7_IRQHandler
	.thumb_set TIM7_IRQHandler,Default_Handler

	.weak	DMA2_Channel1_IRQHandler
	.thumb_set DMA2_Channel1_IRQHandler,Default_Handler

	.weak	DMA2_Channel2_IRQHandler
	.thumb_set DMA2_Channel2_IRQHandler,Default_Handler

	.weak	DMA2_Channel3_IRQHandler
	.thumb_set DMA2_Channel3_IRQHandler,Default_Handler

	.weak	DMA2_Channel4_IRQHandler
	.thumb_set DMA2_Channel4_IRQHandler,Default_Handler

	.weak	DMA2_Channel5_IRQHandler
	.thumb_set DMA2_Channel5_IRQHandler,Default_Handler

	.weak	DFSDM1_FLT0_IRQHandler
	.thumb_set DFSDM1_FLT0_IRQHandler,Default_Handler

	.weak	DFSDM1_FLT1_IRQHandler
	.thumb_set DFSDM1_FLT1_IRQHandler,Default_Handler

	.weak	DFSDM1_FLT2_IRQHandler
	.thumb_set DFSDM1_FLT2_IRQHandler,Default_Handler

	.weak	COMP_IRQHandler
	.thumb_set COMP_IRQHandler,Default_Handler

	.weak	LPTIM1_IRQHandler
	.thumb_set LPTIM1_IRQHandler,Default_Handler

	.weak	LPTIM2_IRQHandler
	.thumb_set LPTIM2_IRQHandler,Default_Handler

	.weak	OTG_FS_IRQHandler
	.thumb_set OTG_FS_IRQHandler,Default_Handler

	.weak	DMA2_Channel6_IRQHandler
	.thumb_set DMA2_Channel6_IRQHandler,Default_Handler

	.weak	DMA2_Channel7_IRQHandler
	.thumb_set DMA2_Channel7_IRQHandler,Default_Handler

	.weak	LPUART1_IRQHandler
	.thumb_set LPUART1_IRQHandler,Default_Handler

	.weak	QUADSPI_IRQHandler
	.thumb_set QUADSPI_IRQHandler,Default_Handler

	.weak	I2C3_EV_IRQHandler
	.thumb_set I2C3_EV_IRQHandler,Default_Handler

	.weak	I2C3_ER_IRQHandler
	.thumb_set I2C3_ER_IRQHandler,Default_Handler

	.weak	SAI1_IRQHandler
	.thumb_set SAI1_IRQHandler,Default_Handler

	.weak	SAI2_IRQHandler
	.thumb_set SAI2_IRQHandler,Default_Handler

	.weak	SWPMI1_IRQHandler
	.thumb_set SWPMI1_IRQHandler,Default_Handler

	.weak	TSC_IRQHandler
	.thumb_set TSC_IRQHandler,Default_Handler

	.weak	LCD_IRQHandler
	.thumb_set LCD_IRQHandler,Default_Handler

	.weak	RNG_IRQHandler
	.thumb_set RNG_IRQHandler,Default_Handler

	.weak	FPU_IRQHandler
	.thumb_set FPU_IRQHandler,Default_Handler

L476_SBSFU\SECoreBin\.cproject
1	<?xml version="1.0" encoding="UTF-8" standalone="no"?>
2	<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptio­nStorage">
3		<storageModule moduleId="org.eclipse.cdt.core.settings">
4			<cconfiguration id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.1178735399">
5				<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataPro­vider" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.1178735399" moduleId="org.eclipse.cdt.core.settings" name="Debug">
6					<externalSettings/>
7					<extensions>
8						<extension id="org.eclipse.cdt.core.ELF" point="org.eclipse.cdt.core.BinaryParser"/>
9						<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
10						<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
11						<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
12						<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
13						<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
14					</extensions>
15				</storageModule>
16				<storageModule moduleId="cdtBuildSystem" version="4.0.0">
17					<configuration artifactExtension="elf" artifactName="SECoreBin" buildArtefactType="org.eclipse.cdt.build.core.buildArtefactType.exe" buildProperties="org.eclipse.cdt.build.core.buildArtefactType=org.eclipse.cdt.build.core.buildArtefactType.exe,org.eclipse.cdt.build.core.buildType=org.eclipse.cdt.build.core.buildType.debug" cleanCommand="rm -rf" description="" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.1178735399" name="Debug" parent="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug" prebuildStep="&quot;../Scripts/prebuild.sh&quot; &quot;../&quot; &quot;../../Common&quot; &quot;../Output&quot;">
18						<folderInfo id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.1178735399." name="/" resourcePath="">
19							<toolChain id="com.st.stm32cube.ide.mcu.gnu.managedbuild.toolchain.exe.debug.1828906036" name="MCU ARM GCC" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.toolchain.exe.debug">
20								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.convertverilog.682321681" name="Convert to Verilog file (-O verilog)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.convertverilog" useByScannerDiscover­y="false" value="false" valueType="boolean"/>
21								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.showsize.373043708" name="Show size information about built artifact" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.showsize" useByScannerDiscover­y="false" value="true" valueType="boolean"/>
22								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.converthex.1224169032" name="Convert to Intel Hex file (-O ihex)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.converthex" useByScannerDiscover­y="false" value="false" valueType="boolean"/>
23								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.convertsymbolsrec.1735746182" name="Convert to Motorola S-record (symbols) file (-O symbolsrec)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.convertsymbolsrec" useByScannerDiscover­y="false" value="false" valueType="boolean"/>
24								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.convertbinary.1401489338" name="Convert to binary file (-O binary)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.convertbinary" useByScannerDiscover­y="false" value="true" valueType="boolean"/>
25								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.convertsrec.272464865" name="Convert to Motorola S-record file (-O srec)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.convertsrec" useByScannerDiscover­y="false" value="false" valueType="boolean"/>
26								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_mcu.1523172256" name="MCU" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_mcu" useByScannerDiscover­y="true" value="STM32L476RGTx" valueType="string"/>
27								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_board.710380704" name="Board" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_board" useByScannerDiscover­y="false" value="NUCLEO-L476RG" valueType="string"/>
28								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.instructionset.1277842179" name="Instruction set" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.instructionset" useByScannerDiscover­y="true" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.instructionset.value.thumb2" valueType="enumerated"/>
29								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.floatabi.238907076" name="Floating-point ABI" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.floatabi" useByScannerDiscover­y="true" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.floatabi.value.softfp" valueType="enumerated"/>
30								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.fpu.1612114308" name="Floating-point unit" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.fpu" useByScannerDiscover­y="true" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.fpu.value.fpv4-sp-d16" valueType="enumerated"/>
31								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_cpuid.705009189" name="CPU" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_cpuid" useByScannerDiscover­y="false" value="0" valueType="string"/>
32								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_coreid.2071783263" name="Core" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.target_coreid" useByScannerDiscover­y="false" value="0" valueType="string"/>
33								<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.runtimelibrary_c.448486557" name="Runtime library" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.runtimelibrary_c" useByScannerDiscover­y="true" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.option.runtimelibrary_c.value.nano_c" valueType="enumerated"/>
34								<targetPlatform archList="all" binaryParser="org.eclipse.cdt.core.ELF" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.targetplatform.183572217" isAbstract="false" osList="all" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.targetplatform"/>
35								<builder buildPath="${workspace_loc:/STM32L476RG_NUCLEO_2­_Images_SECoreBin}/Debug" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.builder.1027606866" keepEnvironmentInBui­ldfile="false" name="Gnu Make Builder" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.builder"/>
36								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.1513145170" name="MCU GCC Assembler" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler">
37									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.debuglevel.2100122739" name="Debug level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.debuglevel" useByScannerDiscover­y="false" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.option.debuglevel.value.g3" valueType="enumerated"/>
38									<inputType id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.input.1988509322" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.assembler.input"/>
39								</tool>
40								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.1461591759" name="MCU GCC Compiler" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler">
41									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.debuglevel.2107160264" name="Debug level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.debuglevel" useByScannerDiscover­y="false" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.debuglevel.value.g3" valueType="enumerated"/>
42									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level.1823525647" name="Optimization level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level" useByScannerDiscover­y="false" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level.value.os" valueType="enumerated"/>
43									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.ffunction.1300462352" name="Place functions in their own sections (-ffunction-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.ffunction" useByScannerDiscover­y="false" value="true" valueType="boolean"/>
44									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.fdata.68069833" name="Place data in their own sections (-fdata-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.fdata" useByScannerDiscover­y="false" value="false" valueType="boolean"/>
45									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.includepaths.1151567590" name="Include paths (-I)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.includepaths" useByScannerDiscover­y="false" valueType="includePath">
46										<listOptionValue builtIn="false" value="../Application/Core/Inc"/>
47										<listOptionValue builtIn="false" value="../../BFU/Application/BFU/App"/>
48										<listOptionValue builtIn="false" value="../../BFU/Application/BFU/Target"/>
49										<listOptionValue builtIn="false" value="../../Linker_Common/STM32CubeIDE"/>
50										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/CMSIS/Include"/>
51										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/CMSIS/Device/ST/STM32L4xx/Include"/>
52										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Inc"/>
53										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/BSP/STM32L4xx_Nucleo"/>
54										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/BSP/Components/Common"/>
55										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Cryptographic/Fw_Crypto/STM32L4/Inc"/>
56										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Core"/>
57										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Key"/>
58									</option>
59									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.definedsymbols.585907742" name="Define symbols (-D)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.definedsymbols" useByScannerDiscover­y="false" valueType="definedSymbols">
60										<listOptionValue builtIn="false" value="STM32L476xx"/>
61										<listOptionValue builtIn="false" value="USE_HAL_DRIVER"/>
62										<listOptionValue builtIn="false" value="USE_STM32L4XX_NUCLEO­"/>
63									</option>
64									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.otherflags.1938819949" name="Other flags" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.otherflags" useByScannerDiscover­y="true" valueType="stringList">
65										<listOptionValue builtIn="false" value="-Wno-strict-aliasing"/>
66									</option>
67									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.languagestandard.1943179779" name="Language standard" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.languagestandard" useByScannerDiscover­y="true" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.languagestandard.value.gnu11" valueType="enumerated"/>
68									<inputType id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.input.c.688026001" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.input.c"/>
69								</tool>
70								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.1212891457" name="MCU G++ Compiler" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler">
71									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.debuglevel.1200281319" name="Debug level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.debuglevel" useByScannerDiscover­y="false" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.debuglevel.value.g3" valueType="enumerated"/>
72									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.optimization.level.267254109" name="Optimization level" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.optimization.level" useByScannerDiscover­y="false" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.optimization.level.value.os" valueType="enumerated"/>
73									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.ffunction.1045935804" name="Place functions in their own sections (-ffunction-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.ffunction" useByScannerDiscover­y="false" value="true" valueType="boolean"/>
74									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.fdata.1463613165" name="Place data in their own sections (-fdata-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.fdata" useByScannerDiscover­y="false" value="false" valueType="boolean"/>
75									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.noexceptions.45108866" name="Disable handling exceptions (-fno-exceptions)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.noexceptions" useByScannerDiscover­y="false" value="true" valueType="boolean"/>
76									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.nortti.864301640" name="Disable generation of information about every class with virtual functions (-fno-rtti)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.nortti" useByScannerDiscover­y="false" value="true" valueType="boolean"/>
77									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.includepaths.1910946528" name="Include paths (-I)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.includepaths" useByScannerDiscover­y="false" valueType="includePath">
78										<listOptionValue builtIn="false" value="../Application/Core/Inc"/>
79										<listOptionValue builtIn="false" value="../../BFU/Application/BFU/App"/>
80										<listOptionValue builtIn="false" value="../../BFU/Application/BFU/Target"/>
81										<listOptionValue builtIn="false" value="../../Linker_Common/STM32CubeIDE"/>
82										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/CMSIS/Include"/>
83										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/CMSIS/Device/ST/STM32L4xx/Include"/>
84										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Inc"/>
85										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/BSP/STM32L4xx_Nucleo"/>
86										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Drivers/BSP/Components/Common"/>
87										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Cryptographic/Fw_Crypto/STM32L4/Inc"/>
88										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Core"/>
89										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Key"/>
90									</option>
91									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.definedsymbols.1299970052" name="Define symbols (-D)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.definedsymbols" useByScannerDiscover­y="false" valueType="definedSymbols">
92										<listOptionValue builtIn="false" value="STM32L476xx"/>
93										<listOptionValue builtIn="false" value="USE_HAL_DRIVER"/>
94										<listOptionValue builtIn="false" value="USE_STM32L4XX_NUCLEO­"/>
95									</option>
96									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="true" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.otherflags.869676532" name="Other flags" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.compiler.option.otherflags" useByScannerDiscover­y="true" valueType="stringList"/>
97								</tool>
98								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.821212999" name="MCU GCC Linker" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker">
99									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.script.153382752" name="Linker Script (-T)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.script" value="../STM32L476RGTx.ld" valueType="string"/>
100									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.gcsections.58829285" name="Discard unused sections (-Wl,--gc-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.gcsections" value="true" valueType="boolean"/>
101									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.libraries.809673735" name="Libraries (-l)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.libraries" valueType="libs">
102										<listOptionValue builtIn="false" value=":libSTM32Cryptographi­cV3.0.0_CM4_GCC.a"/>
103									</option>
104									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.directories.587000061" name="Library search path (-L)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.directories" valueType="libPaths">
105										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Cryptographic/Fw_Crypto/STM32L4/Lib"/>
106									</option>
107									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.systemcalls.169641602" name="System calls" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.systemcalls" value="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.systemcalls.value.minimalimplementatio­n" valueType="enumerated"/>
108									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.otherflags.1754363725" name="Other flags" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.option.otherflags" valueType="stringList">
109										<listOptionValue builtIn="false" value="-Xlinker -L ../../Common/Linker"/>
110									</option>
111									<inputType id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.input.1727799438" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.linker.input">
112										<additionalInput kind="additionalinputdepen­dency" paths="$(USER_OBJS)"/>
113										<additionalInput kind="additionalinput" paths="$(LIBS)"/>
114									</inputType>
115								</tool>
116								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.1296686253" name="MCU G++ Linker" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker">
117									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.script.1554527755" name="Linker Script (-T)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.script" value="../STM32L476RGTx.ld" valueType="string"/>
118									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.gcsections.747856350" name="Discard unused sections (-Wl,--gc-sections)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.gcsections" value="true" valueType="boolean"/>
119									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.libraries.1637669899" name="Libraries (-l)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.libraries" valueType="libs">
120										<listOptionValue builtIn="false" value=":STM32CryptographicV3­.0.0_CM4_GCC.a"/>
121									</option>
122									<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.directories.1671116229" name="Library search path (-L)" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.directories" valueType="libPaths">
123										<listOptionValue builtIn="false" value="../../../SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Cryptographic/Fw_Crypto/STM32L4/Lib"/>
124									</option>
125									<option id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.otherflags.1482671555" name="Other flags" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.cpp.linker.option.otherflags"/>
126								</tool>
127								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.archiver.1485873380" name="MCU GCC Archiver" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.archiver"/>
128								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.size.1842775539" name="MCU Size" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.size"/>
129								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objdump.listfile.1698533349" name="MCU Output Converter list file" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objdump.listfile"/>
130								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.hex.2128718342" name="MCU Output Converter Hex" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.hex"/>
131								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.binary.304878238" name="MCU Output Converter Binary" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.binary"/>
132								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.verilog.1331965503" name="MCU Output Converter Verilog" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.verilog"/>
133								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.srec.321581107" name="MCU Output Converter Motorola S-rec" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.srec"/>
134								<tool id="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.symbolsrec.1973507017" name="MCU Output Converter Motorola S-rec with symbols" superClass="com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.objcopy.symbolsrec"/>
135							</toolChain>
136						</folderInfo>
137						<fileInfo id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.1178735399.common.ld" name="common.ld" rcbsApplicability="disable" resourcePath="common.ld" toolsToInvoke=""/>
138						<fileInfo id="com.st.stm32cube.ide.mcu.gnu.managedbuild.config.exe.debug.1178735399.STM32L476RGTx.ld" name="STM32L476RGTx.ld" rcbsApplicability="disable" resourcePath="STM32L476RGTx.ld" toolsToInvoke=""/>
139						<sourceEntries>
140							<entry flags="VALUE_WORKSPACE_PATH­" kind="sourcePath" name=""/>
141						</sourceEntries>
142					</configuration>
143				</storageModule>
144				<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
145			</cconfiguration>
146		</storageModule>
147		<storageModule moduleId="cdtBuildSystem" version="4.0.0">
148			<project id="L476_SBSFU_SECoreBin­.fr.ac6.managedbuild.target.gnu.cross.exe.828278725" name="Executable"/>
149		</storageModule>
150		<storageModule moduleId="scannerConfiguration­">
151			<autodiscovery enabled="true" problemReportingEnab­led="true" selectedProfileId=""/>
152			<scannerConfigBuildIn­fo instanceId="fr.ac6.managedbuild.config.gnu.cross.exe.debug.1340367184;fr.ac6.managedbuild.config.gnu.cross.exe.debug.1340367184.;fr.ac6.managedbuild.tool.gnu.cross.c.compiler.27187193;fr.ac6.managedbuild.tool.gnu.cross.c.compiler.input.c.2101831956">
153				<autodiscovery enabled="false" problemReportingEnab­led="true" selectedProfileId=""/>
154			</scannerConfigBuildIn­fo>
155		</storageModule>
156		<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProv­iders"/>
157		<storageModule moduleId="refreshScope" versionNumber="2">
158			<configuration configurationName="Debug">
159				<resource resourceType="PROJECT" workspacePath="/L476_SBSFU_SECoreBin­"/>
160			</configuration>
161		</storageModule>
162		<storageModule moduleId="org.eclipse.cdt.make.core.buildtargets"/>
163	</cproject>
L476_SBSFU\SECoreBin\.project
1	<?xml version="1.0" encoding="UTF-8"?>
2	<projectDescription>
3		<name>L476_SBSFU_SECoreBin­</name>
4		<comment></comment>
5		<projects>
6		</projects>
7		<buildSpec>
8			<buildCommand>
9				<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
10				<triggers>clean,full,incremental,</triggers>
11				<arguments>
12				</arguments>
13			</buildCommand>
14			<buildCommand>
15				<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder­</name>
16				<triggers>full,incremental,</triggers>
17				<arguments>
18				</arguments>
19			</buildCommand>
20		</buildSpec>
21		<natures>
22			<nature>com.st.stm32cube.ide.mcu.MCUProjectNature</nature>
23			<nature>org.eclipse.cdt.core.cnature</nature>
24			<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
25			<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
26		</natures>
27		<linkedResources>
28			<link>
29				<name>Startup/se_stack_smuggler_GN­U.s</name>
30				<type>1</type>
31				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Core/se_stack_smuggler_GN­U.s</locationURI>
32			</link>
33			<link>
34				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_crc.c</name>
35				<type>1</type>
36				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_crc.c</locationURI>
37			</link>
38			<link>
39				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_crc_ex­.c</name>
40				<type>1</type>
41				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_crc_ex­.c</locationURI>
42			</link>
43			<link>
44				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_firewa­ll.c</name>
45				<type>1</type>
46				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_firewa­ll.c</locationURI>
47			</link>
48			<link>
49				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_flash.c</name>
50				<type>1</type>
51				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_flash.c</locationURI>
52			</link>
53			<link>
54				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_flash_­ex.c</name>
55				<type>1</type>
56				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_flash_­ex.c</locationURI>
57			</link>
58			<link>
59				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_rcc.c</name>
60				<type>1</type>
61				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_rcc.c</locationURI>
62			</link>
63			<link>
64				<name>Drivers/STM32L4xx_HAL_Driver­/stm32l4xx_hal_rcc_ex­.c</name>
65				<type>1</type>
66				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Drivers/STM32L4xx_HAL_Driver­/Src/stm32l4xx_hal_rcc_ex­.c</locationURI>
67			</link>
68			<link>
69				<name>Middlewares/STM32_Secure_Engine/se_callgate.c</name>
70				<type>1</type>
71				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Core/se_callgate.c</locationURI>
72			</link>
73			<link>
74				<name>Middlewares/STM32_Secure_Engine/se_crypto_common.c</name>
75				<type>1</type>
76				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Core/se_crypto_common.c</locationURI>
77			</link>
78			<link>
79				<name>Middlewares/STM32_Secure_Engine/se_exception.c</name>
80				<type>1</type>
81				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Core/se_exception.c</locationURI>
82			</link>
83			<link>
84				<name>Middlewares/STM32_Secure_Engine/se_fwimg.c</name>
85				<type>1</type>
86				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Core/se_fwimg.c</locationURI>
87			</link>
88			<link>
89				<name>Middlewares/STM32_Secure_Engine/se_startup.c</name>
90				<type>1</type>
91				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Core/se_startup.c</locationURI>
92			</link>
93			<link>
94				<name>Middlewares/STM32_Secure_Engine/se_user_application.c</name>
95				<type>1</type>
96				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Core/se_user_application.c</locationURI>
97			</link>
98			<link>
99				<name>Middlewares/STM32_Secure_Engine/se_utils.c</name>
100				<type>1</type>
101				<locationURI>PARENT-2-PROJECT_LOC/SBSFU_LIB_V2.7.0/Middlewares/ST/STM32_Secure_Engine/Core/se_utils.c</locationURI>
102			</link>
103		</linkedResources>
104	</projectDescription>
105
L476_SBSFU\SECoreBin\STM32L476RGTx.ld

/*
*****************************************************************************
**
**  File        : LinkerScript.ld
**
**  Abstract    : Linker script for STM32L476RGTx Device with
**                1024KByte FLASH, 96KByte RAM
**
**                Set heap size, stack size and stack location according
**                to application requirements.
**
**                Set memory bank area and size if external memory is used.
**
**  Target      : STMicroelectronics STM32
**
**
**  Distribution: The file is distributed as is, without any warranty
**                of any kind.
**
**  (c)Copyright Ac6.
**  You may use this file as-is or modify it according to the needs of your
**  project. Distribution of this file (unmodified or modified) is not
**  permitted. Ac6 permit registered System Workbench for MCU users the
**  rights to distribute the assembled, compiled & linked contents of this
**  file as part of an application binary file, provided that it is built
**  using the System Workbench for MCU toolchain.
**
*****************************************************************************
*/

/* Entry Point */
ENTRY(SE_CallGate)

/* Generate a link error if heap and stack don't fit into RAM */
_Min_Heap_Size = 0;      /* required amount of heap  */
_Min_Stack_Size = 0;     /* specific stack provided inside secured area */

INCLUDE mapping_fwimg.ld
INCLUDE mapping_sbsfu.ld

/* Define output sections */
SECTIONS
{
  .SE_CallGate_Code :
  {
    BYTE(0);           /* dummy byte to keep the callgate at 0x8000204 */
    BYTE(0);           /* dummy byte to keep the callgate at 0x8000204 */
    BYTE(0);           /* dummy byte to keep the callgate at 0x8000204 */
    BYTE(0);           /* dummy byte to keep the callgate at 0x8000204 */
    KEEP(*(.SE_CallGate_Code))
  } > SE_Entry_Secure_ROM_Region

  .SE_Key_Data : { KEEP(*(.SE_Key_Data)) } > SE_Key_region_ROM
  .SE_Startup_Code : { KEEP ( *se_startup.o (.text .text*)) } > SE_Startup_region_ROM
  .text :
  {
    . = ALIGN(8);
    *(.text)           /* .text sections (code) */
    *(.text*)          /* .text* sections (code) */
    *(.glue_7)         /* glue arm to thumb code */
    *(.glue_7t)        /* glue thumb to arm code */
    *(.eh_frame)

    KEEP (*(.init))
    KEEP (*(.fini))

    . = ALIGN(8);
    _etext = .;        /* define a global symbols at end of code */
  } >SE_ROM_region

  .isr_vector :
  {
    . = ALIGN(0x200);
    KEEP(*(.isr_vector)) /* Startup code */
    . = ALIGN(8);
  } >SE_ROM_region

  /* Constant data goes into FLASH */
  .rodata :
  {
    . = ALIGN(8);
    *(.rodata)         /* .rodata sections (constants, strings, etc.) */
    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */
    . = ALIGN(8);
  } >SE_ROM_region

  .ARM.extab (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
  . = ALIGN(8);
  *(.ARM.extab* .gnu.linkonce.armextab.*)
  . = ALIGN(8);
  } >SE_ROM_region

  .ARM (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
	. = ALIGN(8);
    __exidx_start = .;
    *(.ARM.exidx*)
    __exidx_end = .;
	. = ALIGN(8);
  } >SE_ROM_region

  .preinit_array (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
	. = ALIGN(8);
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP (*(.preinit_array*))
    PROVIDE_HIDDEN (__preinit_array_end = .);
	. = ALIGN(8);
  } >SE_ROM_region

  .init_array (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
	. = ALIGN(8);
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP (*(SORT(.init_array.*)))
    KEEP (*(.init_array*))
    PROVIDE_HIDDEN (__init_array_end = .);
	. = ALIGN(8);
  } >SE_ROM_region

  .fini_array (READONLY) : /* The READONLY keyword is only supported in GCC11 and later, remove it if using GCC10 or earlier. */
  {
	. = ALIGN(8);
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP (*(SORT(.fini_array.*)))
    KEEP (*(.fini_array*))
    PROVIDE_HIDDEN (__fini_array_end = .);
	. = ALIGN(8);
  } >SE_ROM_region

  /* used by the startup to initialize data */
  _sidata = LOADADDR(.data);

  /* Initialized data sections goes into RAM, load LMA copy after code */
  .data :
  {
    . = ALIGN(8);
    _sdata = .;        /* create a global symbol at data start */
    *(.data)           /* .data sections */
    *(.data*)          /* .data* sections */

    . = ALIGN(8);
    _edata = .;        /* define a global symbol at data end */
  } >SE_RAM_region AT>SE_ROM_region


  /* Uninitialized data section */
  . = ALIGN(4);
  .bss :
  {
    /* This is used by the startup in order to initialize the .bss section */
    _sbss = .;         /* define a global symbol at bss start */
    __bss_start__ = _sbss;
    *(.bss)
    *(.bss*)
    *(COMMON)

    . = ALIGN(4);
    _ebss = .;         /* define a global symbol at bss end */
    __bss_end__ = _ebss;
  } >SE_RAM_region

  /* User_heap_stack section, used to check that there is enough RAM left */

  /* Remove information from the standard libraries */
  /DISCARD/ :
  {
    libc.a ( * )
    libm.a ( * )
    libgcc.a ( * )
  }

  .ARM.attributes 0 : { *(.ARM.attributes) }
}



L476_SBSFU\.project
1	<?xml version="1.0" encoding="UTF-8"?>
2	<projectDescription>
3		<name>L476_SBSFU</name>
4		<comment></comment>
5		<projects>
6		</projects>
7		<buildSpec>
8		</buildSpec>
9		<natures>
10			<nature>com.st.stm32cube.ide.mcu.MCUProjectNature</nature>
11			<nature>com.st.stm32cube.ide.mcu.MCUCubeProjectNature­</nature>
12			<nature>com.st.stm32cube.ide.mcu.MCURootProjectNature­</nature>
13			<nature>com.st.stm32cube.ide.mcu.MCUCubeIdeServicesRe­vAev2ProjectNature</nature>
14			<nature>com.st.stm32cube.ide.mcu.MCUMultiCpuProjectNa­ture</nature>
15		</natures>
16	</projectDescription>
17
